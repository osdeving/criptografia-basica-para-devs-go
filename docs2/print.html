<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jwt Go Demo</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jwt Go Demo</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64-e-codificação"><a class="header" href="#base64-e-codificação">Base64 e Codificação</a></h1>
<style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  th, td {
    border: 1px solid black;
    text-align: center;
    padding: 8px;
  }
</style>
<p>Como funciona uma codificação? Imagine que você tem uma regra que diz o seguinte: caso a entrada for 'a', então o valor será 97, caso a entrada for 'b', então o valor será 98, caso for 'c', então o valor será 99, e assim em diante. Isso é um de-para e é também conhecido como tabela ASCII e envolve outros caracteres além do alfabeto. Descrevi um tipo de codificação.</p>
<p>Base64 é uma regra de codificação (Encode) que aplicamos na entrada produzindo uma saída. Isso significa que podemos lêr a entrada em base64 e produzir uma saída decodificada ou ler uma entrada decodificada e codificar em base64, respectivamente conhecidos como Encode e Decode.</p>
<p>A diferença em relação a tabela ASCII, é que a entrada pode ser qualquer coisa e não se limita apenas a caracteres individuais. No caso do Base64, a codificação funciona agrupando a entrada em blocos de 3 bytes (24 bits) e dividindo-os em 4 grupos de 6 bits. Cada um desses grupos de 6 bits é então convertido para um caractere correspondente em uma tabela de 64 símbolos. Essa table inclui as letras maiúsculas e minúsculas do alfabeto, seguido pelos números de 0 a 9 e então por dois caracteres especiais (+ e / no Base64 padrão e _ e - no Base64URL). Quando a entrada não é um múltiplo exato de 3 bytes, a codificação adiciona um caractere de preenchimento (=) para manter a consistência.</p>
<p>No Base64, a conversão ocorre em blocos e garante que qualquer sequência de bytes possam ser representadas apenas com caracteres seguros para transporte em protocolos como e-mails (MIME), URLs e JSON. Isso torna o Base64 útil para codificar binários, imagens, chaves criptográficas e outros dados que não são diretamente representáveis como texto legível.</p>
<p>O processo inverso, conhecido como decodificação (Decode), pega uma string codificada em Base64 e reconstrói os bytes originais, revertendo a conversão de 6 bits para 8 bits e removendo qualquer padding (=) que tenha sido adicionado na codificação. Assim como podemos converter a → 97 na tabela ASCII e depois reverter 97 → a, no Base64 podemos pegar "TWFu" e recuperar "Man" ou vice-versa, a partir de "Man" obter "TWFu".</p>
<p>No entanto, é importante lembrar que Base64 não é uma criptografia, pois qualquer pessoa pode decodificá-lo facilmente. Ele é apenas um método de representação de dados que facilita o transporte e armazenamento em sistemas que não suportam caracteres binários diretamente. Nota, o Base64 aumenta o tamanho dos dados em 33% em relação ao original.</p>
<h2 id="como-funciona-na-prática"><a class="header" href="#como-funciona-na-prática">Como funciona na prática?</a></h2>
<p>Vamos supor que a entrada sera a string "Rox". Cada caractere em um computador é representado por um número inteiro conforme a tabela ASCII.</p>
<h3 id="passo-1-obter-os-valores-ascii"><a class="header" href="#passo-1-obter-os-valores-ascii">Passo 1: Obter os valores ASCII</a></h3>
<p>Primeiro, vamos converter os caracteres em seus valores numéricos:</p>
<ul>
<li>R → 82</li>
<li>o → 111</li>
<li>x → 120</li>
</ul>
<p>Agora, precisamos representar esses números em binário (base 2), pois a codificação Base64 trabalha diretamente com bits:</p>
<h3 id="passo-2-converter-os-valores-ascii-para-binário-8-bits-cada"><a class="header" href="#passo-2-converter-os-valores-ascii-para-binário-8-bits-cada">Passo 2: Converter os valores ASCII para binário (8 bits cada)</a></h3>
<ul>
<li>R (82) → 01010010</li>
<li>o (111) → 01101111</li>
<li>x (120) → 01111000</li>
</ul>
<p>Agora temos um total de 3 bytes (24 bits), que são agrupados assim:</p>
<p>01010010 01101111 01111000</p>
<h3 id="passo-3-dividir-em-blocos-de-6-bits"><a class="header" href="#passo-3-dividir-em-blocos-de-6-bits">Passo 3: Dividir em blocos de 6 bits</a></h3>
<p>O Base64 trabalha com grupos de 6 bits, então precisamos separar nossos 24 bits assim:</p>
<p>010100 100110 111101 111000</p>
<p>Agora, cada grupo de 6 bits será convertido em um decimal cujo qual representa um índice na tabela Base64.</p>
<h3 id="passo-4-converter-os-grupos-de-6-bits-para-decimal"><a class="header" href="#passo-4-converter-os-grupos-de-6-bits-para-decimal">Passo 4: Converter os grupos de 6 bits para decimal</a></h3>
<ul>
<li>010100 → 20</li>
<li>100110 → 38</li>
<li>111101 → 61</li>
<li>111000 → 56</li>
</ul>
<p>Agora, usamos a tabela Base64 para converter esses números em caracteres.</p>
<h3 id="passo-5-mapear-os-valores-na-tabela-base64"><a class="header" href="#passo-5-mapear-os-valores-na-tabela-base64">Passo 5: Mapear os valores na tabela Base64</a></h3>
<p>A tabela Base64 contém 64 caracteres indexados de 0 até 63. Essa tabela segue uma ordem específica:</p>
<ol>
<li>Letras maiúsculas (A-Z) → índices 0 a 25</li>
<li>Letras minúsculas (a-z) → índices 26 a 51</li>
<li>Números (0-9) → índices 52 a 61</li>
<li>Caracteres especiais (+ e /) → índices 62 e 63</li>
</ol>
<p>Representação em Go:</p>
<pre><code class="language-go">const base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
</code></pre>
<p>Agora, usamos essa tabela para mapear os valores 20, 38, 61 e 56:</p>
<ul>
<li>base64Table[20] → "U"</li>
<li>base64Table[38] → "m"</li>
<li>base64Table[61] → "9"</li>
<li>base64Table[56] → "4"</li>
</ul>
<p>Com isso, o texto "Rox" foi convertido para Base64 como "Um94"</p>
<h3 id="resumo"><a class="header" href="#resumo">Resumo</a></h3>
<p>1 - Convertemos os caracteres para seus valores ASCII (R = 82, o = 111, x = 120).</p>
<p>2 - Transformamos esses valores em binário (01010010 01101111 01111000).</p>
<p>3 - Dividimos em blocos de 6 bits (010100 100110 111101 111000).</p>
<p>4 - Convertemos cada grupo de 6 bits em um número decimal (20, 38, 61, 56).</p>
<p>5 - Mapeamos esses números na tabela Base64, resultando na string "Um94".</p>
<p>Bem tranquilo, certo?</p>
<h2 id="implementação-em-go"><a class="header" href="#implementação-em-go">Implementação em Go</a></h2>
<p>O maior desafio que teremos é agrupar os bits em grupos de 6 bits, pois normalmente estamos trabalhando com 8 bits (1 byte). Isso implica que, a cada 3 bytes (24 bits no total), teremos 4 grupos de 6 bits, pois 24 / 6 = 4.</p>
<hr />
<summary>Extra: Entendendo o bitwise AND
<details>
<br>
<p>Se tivermos um valor binário qualquer e aplicarmos uma máscara bit a bit (bitwise AND) com 0b111111 (0x3F em hexadecimal), conseguimos extrair exatamente 6 bits da posição desejada.</p>
<p>Isso funciona porque o operador AND (&), mantém apenas os bits onde há 1 nos dois operadores, então podemos isolar porções específicas de um número maior.</p>
<h4 id="exemplo-prático"><a class="header" href="#exemplo-prático">Exemplo prático:</a></h4>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)
</code></pre>
<p>Note que AND tem o poder de desligar o bit ou mantê-lo sem modificação.</p>
<table border="1">
  <tr>
    <th>A</th>
    <th>AND</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>
<br>
<p>Ou seja:</p>
<ul>
<li>Se você aplicar a máscara b00000000, vai apagar tudo</li>
<li>Se você aplicar a máscara b00000001 vai apagar tudo e, para o primeiro bit, vai depender se o outro valor tem 1 ou 0: se tiver 1, ele será mantido, se tiver 0, ele apaga.</li>
</ul>
<p>Outro exemplo: pegar apenas os bits 3 e 4 de um byte qualquer</p>
<pre>
BYTE qualquer:            <span style="color:#ffcc00;">01010010</span>  (82 em decimal)
Máscara de 6 bits:        <span style="color:#00ccff;">00111111</span>  (0x3F em hexadecimal)
Resultado após AND:       <span style="color:#ff6666;">00010010</span>  (18 em decimal)
</pre>
</details>
</summary>
<hr />
<p>Podemos trabalhar diretamente com 3 bytes em um inteiro e percorrer a mensagem de entrada de 3 em 3 bytes e para cada passagem jogar os 3 bytes no inteiro e extrair os valores usando máscara de bits.</p>
<pre><code class="language-go">for i := 0; i &lt; len(input); i += 6 {
    
    blk := int32(in[i    ]) &lt;&lt; 16 | 
           int32(in[i + 1]) &lt;&lt; 8  | 
           int32(in[i + 2])

    out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)

}
</code></pre>
<hr />
<summary>Extra: Explicação do código
<details>
<br>
<p>O que foi feito?</p>
<br>
<p>Criamos um inteiro de 32 bits (int32) e jogamos os 3 bytes do input em cima dele. Para o primeiro byte (na posição i) jogamos para a esquerda 16 bits, para o segundo byte (na posição i + 1) jogamos para a esquerda 8 bits e para o terceiro byte (na posição i + 2) não precisamos jogar nada para a esquerda.</p>
<p>
Imagine que são caixas que cabem 1 byte, o inteiro possui 4 dessas caixas, então precisamos jogar o primeiro byte para a esquerda 16 bits para que ele ocupe a terceira posição, o segundo byte para a esquerda 8 bits e o terceiro byte não precisamos jogar nada para a esquerda porque vai começar no bit 0. Graficamente temos isso:</p>
<pre>
Byte i + 0 = <span style="color:#ff6666;">01101111</span>  (111 em decimal)
Byte i + 1 = <span style="color:#00ccff;">01111000</span>  (120 em decimal)
Byte i + 2 = <span style="color:#ffcc00;">01010010</span>  (82 em decimal) <br>
blk = <span style="color:lightblue"> 000000000 00000000 00000000 00000000</span><br>
Primeiro byte entra começando no bit 16
blk = <span style="color:lightblue"> 000000000<span style="color:#ffcc00;">01010010</span>00000000 00000000</span><br>
Segundo byte entra começando no bit 8
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span>00000000</span><br>
Terceiro byte entra começando no bit 0
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Vamos em câmera lenta. Suponha que</p>
<pre>
in[i    ] = b10000000
in[i + 1] = b00000001
in[i + 2] = b00010000
</pre>
<pre><code class="language-go">blk := int32(in[i    ]) &lt;&lt; 16  // blk = 00000000_10000000_00000000_00000000
blk  |= int32(in[i + 1]) &lt;&lt; 8  // blk = 00000000_10000000_00000001_00000000
blk |= int32(in[i + 2])        // blk = 00000000_10000000_00000001_00010000
</code></pre>
<p>Ou seja, ligou o bit 32 vindo do primeiro byte (ele já estava na posição 8, deslocou 16), o bit 8 do segundo byte (estava na posição 0 e deslocou 8) e o bit 5 (estava na posição 5 do terceiro byte e não teve deslocamento).</p>
<p>Sei que vocẽ já entendeu, mas cabe lembrar que OR funciona da seguinte forma, você tem um valor qualquer com alguns bits ligados e outros não, quando você aplica o OR com outro valor, o que já existe no seu continua, o que não existe no seu, mas existe no outro cara, ele passa a existir no seu. P.ex.: o seu é b00010000 o outro cara é b00000001 agora o seu será b00010001. Veja a tabela do OR para refrescar a memória:</p>
<table border="1">
  <tr>
  <th>A</th>
  <th>OR</th>
  <th>B</th>
  <th>C</th>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>1</td>
  <td>1</td>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>0</td>
  <td>1</td>
  </tr>
  <tr>
  <td>0</td>
  <td>OR</td>
  <td>0</td>
  <td>0</td>
  </tr>
</table>
<br>
<p>Agora que temos os 3 bytes dentro de um único inteiro de 32 bits (blk), precisamos extrair 4 grupos de 6 bits, pois cada caractere Base64 é representado por exatamente 6 bits.</p>
<p>A extração é feita aplicando deslocamento de bits (>>) e uma máscara (& 0b00111111), que serve para zerar os bits irrelevantes e pegar exatamente os 6 bits desejados.</p>
<p>Graficamente, temos:</p>
<pre>
blk = <span style="color:lightblue">00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Agora, extraímos os grupos de 6 bits um por um:</p>
<ul>
  <li>Primeiros 6 bits: Para extrair os bits mais à esquerda, deslocamos 18 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_1 = (blk >> 18) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000000_00010010 → 000100</span>
b64_1 = <span style="color:#ffcc00;">000100</span>
</pre>
<ul>
  <li>Segundos 6 bits: Deslocamos 12 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_2 = (blk >> 12) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000010_01010010 → 010100</span>
b64_2 = <span style="color:#00ccff;">010100</span>
</pre>
<ul>
  <li>Terceiros 6 bits: Deslocamos 6 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_3 = (blk >> 6) & 0b00111111   <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 011110
b64_3 = <span style="color:#ff6666;">011110</span>
</pre>
<ul>
  <li>Últimos 6 bits: Não há deslocamento, apenas aplicamos a máscara.</li>
</ul>
<pre>
b64_4 = blk & 0b00111111 <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 100010
b64_4 = <span style="color:#ff9999;">100010</span>
</pre>
<p>Agora, temos os 4 índices da tabela Base64 prontos para serem mapeados!</p>
<p>Isso significa que podemos simplesmente usar o array <code>b64</code> para obter os caracteres correspondentes, indexando diretamente com <code>b64_1</code>, <code>b64_2</code>, <code>b64_3</code> e <code>b64_4</code>.</p>
<pre>
b64_1 = <span style="color:#ffcc00;">000100</span>  (4 em decimal)  →  Índice <code>b64[4]</code>  →  <span style="color:#ffcc00;">T</span>
b64_2 = <span style="color:#00ccff;">010100</span>  (20 em decimal) →  Índice <code>b64[20]</code> →  <span style="color:#00ccff;">U</span>
b64_3 = <span style="color:#ff6666;">011110</span>  (30 em decimal) →  Índice <code>b64[30]</code> →  <span style="color:#ff6666;">e</span>
b64_4 = <span style="color:#ff9999;">100010</span>  (34 em decimal) →  Índice <code>b64[34]</code> →  <span style="color:#ff9999;">Y</span>
</pre>
<p>Ou seja, os números binários extraídos representam <strong>índices na tabela Base64</strong>, e ao acessar <code>b64[4]</code>, <code>b64[20]</code>, etc., obtemos os caracteres finais da string codificada.</p>
</details>
</summary>
<hr />
<p>Agora só precisamos lidar com casos onde o input tem menos que 3 bytes ou o input não é múltiplo de 3 bytes</p>
<pre><code class="language-go">if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)

</code></pre>
<p>
Quando a entrada nã é múltiplo de 3 significa que ao sairmos do laço principal restará 1 ou 2 bytes. A especificação do Base64 exige que tenhamos 4 grupos fechados de 6 bits, que resultam 4 caracteres da tabela. 
</p>
<p>
Quando sobrar apenas 1 byte, teremos que agrupar em blocos de 6 bits e ter um total de 4 blocos. Como obter um total de 4 blocos de 6 bits com apenas 8 bits? A especificação diz que temos que pegar os 6 bits e obter qual o valor da tabela, para os 2 bits que sobrarem colocamos zeros **à direita** para completar 6 bits e então obtemos o valor na tabela e para os dois grupos restantes simplesmente consideramos o valor '='.
</p>
<p>
Então temos que: O primeiro grupo de 6 bits do byte pega um valor normalmente da tabela, o outro valor é obtido completando os 2 bits que sobraram com quatro zeros à direita e os outros dois grupos de 6 bits consideramos o '=' para cada um.
</p>
<p>
Quando sobram 2 bytes a regra é a mesma. Isto é, dos 16 bits teremos 2 valores _cheios_ e os 4 bits que sobram recebem dois zeros à direita e, diferente do caso que sobra apenas 1 byte, nesse caso precisamos de apenas um '=' para completar o grupo de 4 valores uma vez que já temos 3 grupos prontos.
</p>
<p>
P.ex.:
</p>
<p>
Se tivermos 1 byte sobrando (A = 01000001 em binário = 65 em decimal), precismos transformar isso em 4 blocos de 6 bits. Então fazemos o seguinte:
</p>
<pre>
<span style="color:yellow">010000</span><span style="color:rebeccapurple">01</span><span style="color:red">0000</span><span style="color:lightblue">=</span><span style="color:lightgreen">=</span>
</pre>
<p>Para os dois primeiros (coincidentemente) teremos o mesmo valor na b64table ('Q') e para os outros dois teremos o '='. Assim, ficamos com</p>
<pre>
<strong>QQ==</strong>
</pre>
<p>Com isso, c código completo fica assim:</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"encoding/base64"
)

const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func Encb64(in []byte) string {
	
    var out []byte
	len := len(in)
	rem := len % 3

    for i := 0; i &lt; len - rem; i += 3 {
    
        blk := int64(in[i    ]) &lt;&lt; 16 | 
               int64(in[i + 1]) &lt;&lt; 8  | 
               int64(in[i + 2])

        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)
	}

	if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)
}

func main() {
    testCases := []string{"Manaed", "1234567890"}
	
    for _, test := range testCases {
		encoded := Encb64([]byte(test))
		encondedGo := base64.StdEncoding.EncodeToString([]byte(test))
		fmt.Println("Base64 de ", test, ": ", encoded)
		fmt.Println("Base64 Go : ", test, ": ", encondedGo)
		
	}
}
</code></pre>
<p>Curiosidade: nossa versão fica alguns ms mais lenta que a versão do Go, sintam-se à vontade para estudar a versão em Go, agora poderão entender todo o código!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checksum-e-crc---verificação-de-integridade"><a class="header" href="#checksum-e-crc---verificação-de-integridade">Checksum e CRC - Verificação de Integridade</a></h1>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Na seção anterior, discutimos a codificação e o transporte de dados. Agora, avançamos para um aspecto essencial da transmissão e armazenamento de informações: a verificação de integridade. Esse processo garante que os dados recebidos são os mesmos que foram enviados, sem terem sido alterados ou corrompidos durante a transmissão ou armazenamento.</p>
<p>A integridade dos dados pode ser comprometida por diversos fatores, como erros humanos, falhas sistêmicas (por exemplo, setores defeituosos em discos rígidos) ou perdas de pacotes em redes devido a interferências ou congestionamento.</p>
<p>Para detectar essas falhas, foram desenvolvidos mecanismos como os checksums e os CRC (Cyclic Redundancy Check), que permitem identificar se os dados foram alterados de forma acidental.</p>
<p>É importante diferenciar esses métodos das funções hash criptográficas, como MD5 e SHA-256, que abordaremos mais adiante neste livro. Enquanto checksums e CRCs são projetados para detectar erros acidentais, funções hash criptográficas garantem a integridade contra modificações intencionais, oferecendo resistência a ataques e manipulação maliciosa.</p>
<p>Nesta seção, exploraremos como checksums simples podem ser utilizados para verificar integridade e, em seguida, como os CRC oferecem um método mais robusto para detectar erros em sistemas computacionais.</p>
<h2 id="bit-de-paridade-parity-bit"><a class="header" href="#bit-de-paridade-parity-bit">Bit de Paridade (Parity Bit)</a></h2>
<p>Parity bit é um código de detecção de erros em que um bit extra é adicionado ao final da mensagem para garantir que o número total de bits "1" seja par (paridade par) ou ímpar (paridade ímpar). Se um único bit for invertido durante a transmissão, o receptor perceberá a inconsistência e poderá solicitar o reenvio.</p>
<p>Exemplo de paridade par:</p>
<pre><code>Mensagem original: 10101110 (8 bits)
Número de bits "1": 5
Bit de paridade: 1 (para tornar o total par)
Mensagem transmitida: 101011101
</code></pre>
<p>Se um erro ocorrer e inverter um bit:</p>
<pre><code>Recebido: 101001101 (erro no terceiro bit)
Número de bits "1": 4 → Inconsistência detectada.
</code></pre>
<p>Embora simples, a paridade tem limitações: não detecta erros em um número par de bits invertidos, tornando-a inadequada para muitas aplicações.</p>
<p>Como alternativa, poderíamos enviar a mensagem duas vezes e comparar ambas as cópias. No entanto, isso dobra o consumo de banda e não garante detecção total de erros se ambas as cópias forem corrompidas de forma idêntica.</p>
<p>O ideal é encontrar um código de verificação que minimize o custo de transmissão e maximize a capacidade de detecção de erros. Os dois métodos mais utilizados são:</p>
<ul>
<li>Checksums – Somam os valores dos bytes da mensagem e armazenam o resultado junto com os dados.</li>
<li>Cyclic Redundancy Check (CRC) – Usa operações matemáticas sobre polinômios para gerar um código de verificação mais robusto.</li>
</ul>
<p>Nos próximos tópicos, exploraremos esses métodos em detalhes, mostrando suas implementações e aplicações.</p>
<h2 id="checksum"><a class="header" href="#checksum">Checksum</a></h2>
<p>O checksum é a forma mais simples de verificação de integridade, sendo calculado somando os valores dos bytes ou palavras de um dado e armazenando essa soma junto com os dados. Ao receber ou ler os dados, a soma é recalculada e comparada com o checksum armazenado. Se os valores diferirem, isso indica um erro na transmissão ou no armazenamento.</p>
<h3 id="exemplo-de-checksum-simples-soma-de-bytes"><a class="header" href="#exemplo-de-checksum-simples-soma-de-bytes">Exemplo de Checksum Simples (Soma de Bytes)</a></h3>
<p>Vamos criar uma implementação básica de checksum em Go, somando os valores dos bytes da mensagem e calculando o módulo 256 para manter um valor fixo de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Função de checksum simples (soma dos bytes módulo 256)
func SimpleChecksum(data []byte) byte {
	var checksum byte = 0
	for _, b := range data {
		checksum += b
	}
	return checksum
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("Checksum de 'HELLO': 0x%X\n", SimpleChecksum(data))
}
</code></pre>
<p>Um algorítmo simples como o demonstrado acima possui algumas limitações importantes:</p>
<ul>
<li>Não detecta trocas na ordem dos bytes (ABC e CBA geram o mesmo checksum)</li>
<li>Colisões serão frequentes (diferentes mensagens podem gerar o mesmo valor de checksum)</li>
<li>Não detecta alguns tiopos de erro bit a bit</li>
</ul>
<p>Para resolver esses problemas, foram criadas versões mais sofisticadas, como o CRC.</p>
<h2 id="checksum-no-udpip"><a class="header" href="#checksum-no-udpip">Checksum no UDP/IP</a></h2>
<p>O protocolo UDP (User Datagram Protocol) e o cabeçalho IP (Internet Protocol) utilizam um checksum baseado em complemento de um, que é uma técnica mais avançada do que a simples soma de bytes. Esse método melhora a detecção de erros, sendo amplamente usado na transmissão de pacotes de rede.</p>
<p>Como o checksum do UDP/IP funciona?</p>
<ul>
<li>A mensagem (ou cabeçalho IP) é dividida em blocos de 16 bits.</li>
<li>Os blocos são somados usando aritmética de complemento de um.</li>
<li>O complemento de um do resultado final é armazenado como o checksum.</li>
<li>No destino, o receptor soma todos os blocos novamente, incluindo o checksum recebido.</li>
<li>Se o resultado for 0xFFFF, os dados são considerados íntegros; caso contrário, há erro na transmissão.</li>
</ul>
<p>Isso permite detectar a maioria dos erros comuns em transmissões de rede.</p>
<h3 id="implementação-do-checksum-udpip-em-go"><a class="header" href="#implementação-do-checksum-udpip-em-go">Implementação do Checksum UDP/IP em Go</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
)

// Função para calcular o checksum do UDP/IP usando complemento de um
func UDPChecksum(data []byte) uint16 {
	var sum uint32

	// Processa os dados em blocos de 16 bits
	for i := 0; i &lt; len(data)-1; i += 2 {
		word := binary.BigEndian.Uint16(data[i : i+2]) // Converte dois bytes em um uint16
		sum += uint32(word)
	}

	// Se o número de bytes for ímpar, adiciona o último byte com padding
	if len(data)%2 != 0 {
		sum += uint32(data[len(data)-1]) &lt;&lt; 8
	}

	// Adiciona os "overflows" da soma (carry bits)
	for (sum &gt;&gt; 16) &gt; 0 {
		sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16)
	}

	// Retorna o complemento de um do resultado final
	return uint16(^sum)
}

func main() {
	data := []byte("HELLOUDP")
	checksum := UDPChecksum(data)
	fmt.Printf("Checksum UDP de 'HELLOUDP': 0x%X\n", checksum)
}

</code></pre>
<p>Essa implementação reflete como os protocolos UDP e IP realizam a verificação de integridade, garantindo que os pacotes de rede cheguem corretamente ao destino.</p>
<h2 id="crc---cyclic-redundancy-check"><a class="header" href="#crc---cyclic-redundancy-check">CRC - Cyclic Redundancy Check</a></h2>
<p>O CRC (Cyclic Redundancy Check) é um método de detecção de erros baseado em operações matemáticas sobre polinômios binários. Em vez de apenas somar valores, o CRC trata os dados como um número binário e divide esse número por um polinômio pré-determinado, registrando o resto da divisão como código de verificação.</p>
<p>O CRC é amplamente usado em:</p>
<ul>
<li>Transmissões de rede (Ethernet, Wi-Fi)</li>
<li>Armazenamento de arquivos (ZIP, RAR)</li>
<li>Sistemas embarcados (CD-ROM, comunicações seriais)</li>
</ul>
<h3 id="implementação-do-crc-8-em-go"><a class="header" href="#implementação-do-crc-8-em-go">Implementação do CRC-8 em Go</a></h3>
<p>O CRC-8 é uma das versões mais simples, usando um polinômio de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela CRC-8 para polinômio 0x07 (x^8 + x^2 + x + 1)
var crc8Table [256]byte

// Inicializa a tabela CRC-8
func init() {
	const poly = byte(0x07)
	for i := 0; i &lt; 256; i++ {
		crc := byte(i)
		for j := 0; j &lt; 8; j++ {
			if (crc &amp; 0x80) != 0 {
				crc = (crc &lt;&lt; 1) ^ poly
			} else {
				crc &lt;&lt;= 1
			}
		}
		crc8Table[i] = crc
	}
}

// Calcula CRC-8 para um conjunto de dados
func CRC8(data []byte) byte {
	crc := byte(0)
	for _, b := range data {
		crc = crc8Table[crc^b]
	}
	return crc
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("CRC-8 de 'HELLO': 0x%X\n", CRC8(data))
}
</code></pre>
<p>O CRC, diferente do checksum, detecta trocas na ordem dos bytes, detecta erros simples de mútiplos bits errados e possui menor taxa de colisões. Mas o CRC-8 não é reistente a ataques maliciosos (não deve ser usado para segurança) e pode falhar na detecção de alguns padrões específicos de erro se o polinômio não for bem escolhido.</p>
<h2 id="variações-do-crc"><a class="header" href="#variações-do-crc">Variações do CRC</a></h2>
<p>CRC-16
CRC-32
CRC-64
Adler-32
Fletcher-16/32</p>
<p>Cada algoritmo tem um nível diferente de eficiência e resistência a erros. CRC-32, por exemplo, é usado no ZIP e no protocolo de rede Ethernet devido à sua confiabilidade e baixo custo computacional.</p>
<h2 id="diferença-entre-checksum-crc-e-funções-hash"><a class="header" href="#diferença-entre-checksum-crc-e-funções-hash">Diferença entre Checksum, CRC e Funções Hash</a></h2>
<h3 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h3>
<p>O checksum é uma técnica básica e eficiente para detecção de erros simples, mas tem falhas para detecção de padrões mais complexos. O CRC usa divisão polinomial para criar uma verificação mais robusta contra corrupção de dados, sendo amplamente utilizado em redes e armazenamento. Nenhum desses métodos deve ser confundido com funções hash criptográficas, que garantem segurança contra alterações intencionais nos dados.</p>
<p>Se queremos segurança contra modificações maliciosas, devemos usar HMAC, SHA-256 ou outras funções hash seguras.</p>
<p>Agora que entendemos essas formas de verificação de integridade fraca, podemos avançar para a família MD (Message Digest), que evolui de checksums simples para funções hash mais sofisticadas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-e-sha-256"><a class="header" href="#hashing-e-sha-256">Hashing e SHA-256</a></h1>
<h2 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-e-sha-256-1"><a class="header" href="#hashing-e-sha-256-1">Hashing e SHA-256</a></h1>
<h2 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="família-de-algoritmos-md---message-digest"><a class="header" href="#família-de-algoritmos-md---message-digest">Família de Algoritmos MD - Message Digest</a></h1>
<h2 id="md2"><a class="header" href="#md2">MD2</a></h2>
<p>O primeiro algoritmo amplamente publicado da família MD (Message Digest) foi o MD2 e foi desenvolvido por Ronald Rivest em 1989 (não achei nenhuma publicação do MD1 nem do MD3). Ele foi projetado especificamente para computadores de 8 bits. Apesar de ter sido uma inovação importante, o MD2 se tornou obsoleto com o tempo devido a ataques criptográficos bem-sucedidos. Suas principais características eram:</p>
<ul>
<li>Tamanho da saída: 128 bits (16 bytes)</li>
<li>Entrada de tamanho variável</li>
<li>Projetado para máquinas de 8 bits</li>
<li>Inseguro desde 2004 devido a ataques práticos</li>
<li>Lento em hardware moderno devido à otimização para 8 bits</li>
</ul>
<h3 id="como-o-md2-funciona"><a class="header" href="#como-o-md2-funciona">Como o MD2 Funciona?</a></h3>
<p>A especificação do MD2 pode ser encontrada na RFC 1319. Esse algorítmo transforma qualquer entrada em um hash de 128bits. Ele faz isso seguindo 3 etapas principais:</p>
<h4 id="1---padding"><a class="header" href="#1---padding">1 - Padding</a></h4>
<p>Para garantir que o tamanho da entrada seja um múltiplo de 16 bytes, adicionamos bytes de padding no final. A regra é a seguinte:</p>
<ul>
<li>se o tamanho da mensagem já for múltiplo de 16, adicionamos 16 bytes com o valor 0x10 (16 em decimal).</li>
<li>se faltar N bytes para completar 16, adicionamos N bytes com o valor de N.</li>
</ul>
<p>Exemplo:</p>
<p><img src="conceitos/images/padding-md2.png" alt="Padding MD2" /></p>
<p>Ou seja:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Etapa</strong></th><th><strong>Dados</strong></th></tr></thead><tbody>
<tr><td><strong>Entrada original</strong></td><td>Hexa: <code>[41 42 43]</code> = <code>"ABC"</code></td></tr>
<tr><td><strong>Tamanho</strong></td><td><strong>3 bytes</strong></td></tr>
<tr><td><strong>Padding necessário</strong></td><td><code>16 - 3 = 13</code> bytes</td></tr>
<tr><td><strong>Preenchimento</strong></td><td><strong>Faltam 13 bytes</strong>, então usamos <code>0x0D</code> (13)</td></tr>
<tr><td><strong>Resultado final</strong></td><td><code>[41 42 43 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D]</code></td></tr>
</tbody></table>
</div>
<p>Se a entrada tivesse 15 bytes, haveria um padding de 1 byte com o valor 0x01, se tivesse exatamente 16 bytes, faríamos um padding de mais 16 bytes com o valor 0x10 (16 em decimal), e assim por diante.</p>
<h4 id="2---checksum"><a class="header" href="#2---checksum">2 - Checksum</a></h4>
<p>O MD2 adiciona um checksum de 16 bytes, que é computado iterando sobre a mensagem e aplicando XOR com uma tabela de permutação.</p>
<p>Essa tabela de permutação S-box (256 valores) foi escolhida manualmente por Rivest e é baseada em uma permutação "aleatória" dos dígitos de Pi.</p>
<p>Uma S-box (Substitution Box) é uma tabela de substituição não linear usada em criptografia para aumentar a confusão, um conceito fundamental introduzido por Claude Shannon em seu estudo seminal sobre teoria da criptografia (Shannon, 1949)[1].</p>
<p>O objetivo do checksum no MD2 é adicionar redundância e garantir que qualquer alteração na mensagem original impacte significativamente o resultado final. O checksum não serve como verificação de integridade tradicional (como em CRCs), mas sim para aumentar a resistência do algoritmo contra colisões.</p>
<h5 id="como-o-checksum-é-calculado"><a class="header" href="#como-o-checksum-é-calculado">Como o Checksum é Calculado?</a></h5>
<p>A cada bloco de 16 bytes da mensagem (com padding já aplicado), percorremos byte a byte e atualizamos o checksum usando a tabela S-Box.</p>
<p>O cálculo segue a seguinte fórmula:</p>
<pre><code>C[j] = C[j] XOR S[M[i * 16 + j] XOR L]
L = C[j]
</code></pre>
<p>Onde:</p>
<ul>
<li>C[j] -&gt; byte j do checksum</li>
<li>M[i * 16 + j] -&gt; byte j do bloco i da mensagem</li>
<li>S[x] -&gt; S-Box, uma tabela de substituição com 256 valores, indexada pelo resultado do XOR</li>
<li>L -&gt; Último valor atualizado do checksum, começando com 0.</li>
</ul>
<p>Veja um passo a passo com valores reais:</p>
<p>Suponha que:</p>
<ul>
<li>C[3] = 0xA5</li>
<li>M[3] = 0x7F</li>
<li>L = 0x2C</li>
<li>S[0x53] = 0xD4 (porque 0x7F XOR 0x2C = 0x53)</li>
</ul>
<p>Agora, aplicamos:</p>
<pre><code>C[3] = C[3] XOR S[ M[3] XOR L ]
     = 0xA5 XOR S[0x53]
     = 0xA5 XOR 0xD4
     = 0x71

L = C[3] = 0x71

</code></pre>
<p>Essa fase adiciona o efeito de difusão na mensagem antes da fase final.</p>
<p>A difusão é um conceito introduzido por Claude Shannon [Shannon, 1949] [1], onde pequenas mudanças na entrada devem se espalhar por toda a saída, dificultando a recuperação do texto original a partir do hash ou da cifra</p>
<p>Após processar todos os blocos, os 16 bytes do checksum são anexados à mensagem.</p>
<h5 id="implementação-em-go-1"><a class="header" href="#implementação-em-go-1">Implementação em Go</a></h5>
<pre><code class="language-go">var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
	251, 140, 206, 36, 255, 96, 147, 158, 69, 48, 36, 136, 74, 95, 35, 94,
	191, 249, 189, 14, 125, 77, 135, 55, 146, 147, 238, 93, 139, 140, 74, 38,
	192, 89, 246, 116, 40, 158, 136, 171, 166, 123, 101, 26, 52, 36, 252, 176,
	191, 226, 174, 121, 38, 160, 202, 64, 141, 197, 210, 251, 144, 45, 47, 157,
	202, 121, 128, 192, 105, 111, 94, 108, 218, 158, 71, 89, 152, 76, 108, 188,
	50, 203, 61, 117, 158, 140, 76, 144, 55, 199, 24, 97, 46, 24, 94, 82,
	113, 72, 54, 86, 109, 98, 125, 204, 159, 107, 38, 249, 72, 36, 84, 113,
	194, 250, 70, 161, 78, 245, 121, 158, 239, 190, 42, 222, 104, 63, 93, 106,
	242, 216, 64, 122, 174, 210, 194, 79, 124, 55, 198, 156, 168, 40, 56, 156,
	64, 54, 73, 87, 179, 51, 173, 40, 180, 199, 47, 105, 26, 43, 76, 174,
	45, 195, 89, 147, 67, 252, 184, 248, 128, 137, 223, 62, 142, 119, 196, 32,
	32, 129, 107, 244, 153, 178, 61, 134, 240, 144, 47, 226, 121, 69, 116, 48,
	155, 158, 112, 164, 109, 140, 167, 220, 111, 115, 137, 187, 61, 122, 82, 194,
	218, 102, 243, 99, 208, 172, 193, 141, 145, 226, 218, 162, 232, 64, 202, 47,
	118, 164, 108, 173, 98, 217, 187, 178, 244, 130, 108, 78, 122, 84, 133, 150,
}

func computeChecksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0 // Inicializa L com 0

	// Percorre a mensagem em blocos de 16 bytes
	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			c := message[i+j]
			checksum[j] ^= SBox[c^L] // Calcula o novo valor do checksum
			L = checksum[j]           // Atualiza L para o próximo passo
		}
	}
	return checksum
}
</code></pre>
<h4 id="3---processamento-principal"><a class="header" href="#3---processamento-principal">3 - Processamento Principal</a></h4>
<p>Agora pegamos a <strong>mensagem com padding</strong> e <strong>checksum</strong> e a processamos utilizando um buffer intermediário de <strong>48 bytes</strong>. O objetivo desta fase é misturar os dados de forma não linear para aumentar a resistência a colisões.</p>
<p>Diferente de outros algoritmos como o MD4 e MD5, que usam operações de <strong>rotação bitwise</strong> para aumentar a difusão dos bits, o MD2 utiliza <strong>apenas operações XOR e tabelas de substituição</strong> (S-Box). Isso se deve ao fato de que ele foi projetado para <strong>arquiteturas de 8 bits</strong>, onde operações bitwise mais complexas poderiam ser ineficientes.</p>
<h5 id="estrutura-do-buffer-de-48-bytes"><a class="header" href="#estrutura-do-buffer-de-48-bytes">Estrutura do Buffer de 48 Bytes</a></h5>
<p>O <strong>buffer de processamento</strong> (<code>X</code>) é um array de <strong>48 bytes</strong>, onde os primeiros <strong>16 bytes</strong> armazenam o hash intermediário, os <strong>segundos 16 bytes</strong> armazenam um bloco da mensagem e os <strong>últimos 16 bytes</strong> contêm a mistura do bloco da mensagem com os primeiros 16 bytes.</p>
<pre><code>X = [H(0) H(1) .. H(15) | M(0) M(1)... M(15) | H(0) XOR M(0), ... , H(15) XOR M(15)]
</code></pre>
<p>Onde:</p>
<ul>
<li><code>H</code> representa os primeiros 16 bytes do buffer, que armazenam o estado atual do hash.</li>
<li><code>M</code> representa os 16 bytes do bloco da mensagem sendo processado.</li>
</ul>
<h5 id="etapas-do-processamento"><a class="header" href="#etapas-do-processamento">Etapas do Processamento</a></h5>
<p>A cada <strong>bloco de 16 bytes</strong>, fazemos o seguinte:</p>
<ol>
<li><strong>Copiamos o bloco da mensagem (<code>M</code>) para os bytes 16 a 31</strong> do buffer.</li>
<li><strong>Criamos a mistura dos primeiros 16 bytes (<code>H</code>) com o bloco <code>M</code></strong>, armazenando nos bytes 32 a 47.</li>
<li>Executamos 18 rodadas de processamento, onde aplicamos XOR sequencialmente nos 48 bytes do buffer usando a tabela S-Box. O número 18 não foi escolhido arbitrariamente: ele está relacionado ao fato de que o MD2 foi projetado para rodar eficientemente em arquiteturas de 8 bits. Como a S-Box tem 256 valores possíveis (8 bits), e um bloco do MD2 possui 16 bytes, Rivest determinou que 18 rodadas forneciam difusão suficiente sem comprometer o desempenho em hardware de baixa capacidade. Esse valor foi escolhido de forma empírica para equilibrar segurança e eficiência computacional.</li>
</ol>
<p>Cada rodada segue esta fórmula:</p>
<pre><code>X[j] = X[j] XOR SBox[T]
T = X[j]
</code></pre>
<p>Sendo que <code>T</code> é um acumulador que começa em zero e é atualizado ao longo da iteração.</p>
<p>Isso garante que o hash seja alterado a cada rodada, propagando as mudanças nos bytes de maneira não linear.</p>
<h5 id="exemplo-de-transformação"><a class="header" href="#exemplo-de-transformação">Exemplo de Transformação</a></h5>
<p>Suponha que o buffer <code>X</code> comece com:</p>
<pre><code>X = [ A1 A2 ... A16 | B1 B2 ... B16 | C1 C2 ... C16 ]
</code></pre>
<p>Após aplicar a <strong>permutação com a S-Box</strong>, obtemos:</p>
<pre><code>X' = [ P1 P2 ... P16 | Q1 Q2 ... Q16 | R1 R2 ... R16 ]
</code></pre>
<p>Essa transformação acontece <strong>18 vezes</strong>, garantindo uma alta difusão dos bits.</p>
<p>A implementação do <strong>processamento principal</strong> segue abaixo:</p>
<pre><code class="language-go">func processMD2Blocks(message []byte) [16]byte {
	var X [48]byte // Buffer intermediário de 48 bytes

	for i := 0; i &lt; len(message); i += 16 {
		// Copia o bloco da mensagem para os bytes 16 a 31 do buffer
		copy(X[16:32], message[i:i+16])

		// Preenche os últimos 16 bytes com H ⊕ M
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0

		// 18 rodadas de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T] // Permutação não linear usando a S-Box
				T = X[j]        // Atualiza T
			}
			T += byte(round) // Incrementa T a cada rodada
		}
	}

	// O hash final é extraído dos primeiros 16 bytes do buffer X
	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}
</code></pre>
<h5 id="conceitos-aplicados"><a class="header" href="#conceitos-aplicados">Conceitos Aplicados</a></h5>
<p>Este processamento principal do MD2 explora três princípios fundamentais da criptografia:</p>
<p>Confusão ([Shannon, 1949][1])
A permutação S-Box adiciona um grau de não linearidade ao algoritmo, tornando difícil estabelecer relações diretas entre a entrada e a saída.</p>
<p>Difusão ([Shannon, 1949][1])
Cada byte do hash final depende de todos os bytes da mensagem de entrada, devido à aplicação iterativa da S-Box e do XOR.</p>
<p>Avalanche Effect
Pequenas mudanças na entrada resultam em grandes mudanças no hash, pois cada rodada mistura bits de diferentes partes da mensagem.</p>
<p>Após esse processo, os primeiros 16 bytes do buffer X formam o hash MD2 final.</p>
<h3 id="implementação-completa-do-algoritmo-md2-em-go"><a class="header" href="#implementação-completa-do-algoritmo-md2-em-go">Implementação Completa do Algoritmo MD2 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela de permutação S-box
var S = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	// (o restante foi omitido por brevidade, consulte a RFC 1319)
}

func MD2(input []byte) [16]byte {
	// Parte 1: Padding
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	input = append(input, padding...)

	// Parte 2: Checksum
	var checksum [16]byte
	var L byte = 0
	for i := 0; i &lt; len(input); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= S[input[i+j]^L]
			L = checksum[j]
		}
	}
	input = append(input, checksum[:]...)

	// Parte 3: Transformação Principal
	var X [48]byte
	
    for i := 0; i &lt; len(input); i += 16 {
		
        // Copia bloco para X
		copy(X[16:32], input[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[16+j] ^ X[j]
		}
		var t byte = 0

		// 18 rounds de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= S[t]
				t = X[j]
			}
			t += byte(round)
		}
	}

	// O hash final está nos primeiros 16 bytes de X
	var hash [16]byte
	
    copy(hash[:], X[:16])
	
    return hash
}

func main() {
	data := []byte("Mensagem de teste")
	hash := MD2(data)
	fmt.Printf("MD2 Hash: %x\n", hash)
}
</code></pre>
<h2 id="md4---a-evolução-do-message-digest"><a class="header" href="#md4---a-evolução-do-message-digest">MD4 - A Evolução do Message Digest</a></h2>
<p>O MD4 (Message Digest 4) foi desenvolvido por Ronald Rivest em 1990 como uma melhoria do MD2, projetado especificamente para processadores de 32 bits. Ele introduziu um novo modelo de operação baseado em três rodadas de funções não lineares, tornando-o muito mais rápido que o MD2.</p>
<p>No entanto, o MD4 é extremamente fraco e foi quebrado rapidamente. Mesmo assim, sua estrutura inspirou diretamente o MD5 e SHA-1, servindo de base para os algoritmos de hash modernos e que veremos logo mais.</p>
<h3 id="como-o-md4-funciona"><a class="header" href="#como-o-md4-funciona">Como o MD4 Funciona?</a></h3>
<p>A especificação do MD4 pode ser encontrada na RFC 1320. O algoritmo transforma qualquer entrada em um hash de 128 bits usando 3 rodadas de operações baseadas em soma modular e funções booleanas.</p>
<p>O MD4 segue 4 etapas principais:</p>
<p>1 - Padding</p>
<ul>
<li>O comprimento da mensagem é ajustado para que seja múltiplo de 512 bits (64 bytes).</li>
<li>Um bit 1 é adicionado, seguido de zeros até que faltem 64 bits para completar um bloco.</li>
<li>Os últimos 64 bits armazenam o tamanho original da mensagem (antes do padding)</li>
</ul>
<p>Exemplo:</p>
<p>Se tivermos a mensagem "abc", que tem 24 bits (3 bytes), adicionamos:</p>
<pre><code>01100001 01100010 01100011 10000000 00000000 ... (até completar 448 bits)

</code></pre>
<p>E então adicionamos os 64 bits finais contendo o tamanho da mensagem.</p>
<p>2 - Inicialização dos Registradores</p>
<p>MD4 usa quatro registradores de 32 bits, inicializados com valores fixos:</p>
<pre><code>A = 0x67452301
B = 0xEFCDAB89
C = 0x98BADCFE
D = 0x10325476

</code></pre>
<p>Esses valores são inspirados na constante da raiz quadrada de números primos.</p>
<p>3 - Processamento em 3 Rodadas</p>
<p>A mensagem é dividida em blocos de 512 bits (64 bytes), e cada bloco passa por três rodadas de operações matemáticas:</p>
<p>3.1 - Função F (AND, OR, NOT)</p>
<pre><code>F(X, Y, Z) = (X AND Y) OR (NOT X AND Z)

</code></pre>
<p>Essa função favore um dos valores (X) e ajuda na difusão.</p>
<p>3.2 - Função G (Majority Vote)</p>
<pre><code>G(X, Y, Z) = (X AND Y) OR (X AND Z) OR (Y AND Z)

</code></pre>
<p>Utiliza uma "votação" entre os três valores.</p>
<p>3.3 - Função H (XOR)</p>
<pre><code>H(X, Y, Z) = X XOR Y XOR Z

</code></pre>
<p>Mistura os bits de forma caótica.</p>
<p>Cada uma dessas funções é aplicada a cada bloco de 512 bits da mensagem, alterando os registradores A, B, C e D.</p>
<p>4 - Hash Final</p>
<p>Após todas as rodadas, os valores finais dos registradores A, B, C e D são concatenados para formar um hash de 128 bits (16 bytes).</p>
<h3 id="implementação-do-md4-em-go"><a class="header" href="#implementação-do-md4-em-go">Implementação do MD4 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"crypto/md2"
	"encoding/hex"
	"fmt"
	"golang.org/x/crypto/md2" // Biblioteca oficial do Go para MD2
)

// Tabela de permutação S-box (definida na RFC 1319)
var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
}

// Aplicar Padding conforme RFC 1319
func md2Padding(input []byte) []byte {
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	return append(input, padding...)
}

// Calcular Checksum
func md2Checksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0

	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= SBox[message[i+j]^L]
			L = checksum[j]
		}
	}

	return checksum
}

// Aplicar Transformação Principal
func md2Transform(message []byte) [16]byte {
	var X [48]byte

	for i := 0; i &lt; len(message); i += 16 {
		copy(X[16:32], message[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T]
				T = X[j]
			}
			T += byte(round)
		}
	}

	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}

// Função principal MD2
func MD2(input []byte) [16]byte {
	padded := md2Padding(input)
	checksum := md2Checksum(padded)
	message := append(padded, checksum[:]...)
	return md2Transform(message)
}

// Função para comparar com a implementação oficial
func compareWithLibrary(input string) {
	hash := MD2([]byte(input))
	fmt.Printf("Nosso MD2: %x\n", hash)

	libHash := md2.New()
	libHash.Write([]byte(input))
	fmt.Printf("MD2 OpenSSL: %x\n", libHash.Sum(nil))
}

func main() {
	testInput := "Mensagem de teste"
	compareWithLibrary(testInput)
}

</code></pre>
<p>Podemos comparar também com o openssl para ver se a mensagem bate:</p>
<pre><code class="language-bash">echo -n "Mensagem de teste" | openssl md2
</code></pre>
<h4 id="ataques-contra-o-md4"><a class="header" href="#ataques-contra-o-md4">Ataques Contra o MD4</a></h4>
<p>O MD4 foi um grande avanço na época, mas também teve falhas graves de segurança. Aqui, exploramos os ataques mais relevantes que levaram à sua obsolescência.</p>
<p>1 - Ataque de Colisão (1995) - Hans Dobbertin</p>
<p>Em 1995, o criptógrafo Hans Dobbertin publicou um ataque prático contra o MD4, demonstrando que era possível encontrar colisões em alguns segundos.</p>
<p>Isso quebra a confiabilidade do algoritmo, pois qualquer atacante pode substituir um documento sem alterar seu hash.</p>
<p>Como Dobbertin quebrou o MD4?
Ele explorou fraquezas estruturais nas três rodadas do MD4, usando um método conhecido como differential cryptanalysis.</p>
<p>Ele encontrou colisões em menos de 1 minuto usando um computador comum da época!</p>
<p>2 - Ataque de Colisão Rápido (2007) - Wang et al.</p>
<p>Em 2007, Xiaoyun Wang, Hongbo Yu e Yiqun Lisa Yin aprimoraram os ataques de Dobbertin e conseguiram gerar colisões em tempo real.</p>
<p>3 - Ataque de Pré-imagem (2009)</p>
<p>Em 2009, pesquisadores mostraram que dado um hash MD4, era possível reconstruir uma entrada que produzia o mesmo valor.</p>
<p>Esse ataque é catastrófico para aplicações que dependem de integridade, como assinaturas digitais.</p>
<p>4 - Ataque a Senhas no NTLM (Windows)</p>
<p>O MD4 foi usado no NTLM (Microsoft Windows Authentication). Como os ataques de colisão e pré-imagem são rápidos, foi possível quebrar senhas NTLM em milissegundos.</p>
<h3 id="implementando-um-ataque-de-colisão-contra-md4-em-go"><a class="header" href="#implementando-um-ataque-de-colisão-contra-md4-em-go">Implementando um Ataque de Colisão Contra MD4 em Go</a></h3>
<p>Vamos gerar duas mensagens diferentes com o mesmo hash.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Simulação de colisão no MD4
func findCollision() {
	msg1 := []byte("Ataque123")
	msg2 := []byte("At4que123") // Alteração mínima

	hash1 := md4(msg1)
	hash2 := md4(msg2)

	fmt.Printf("Mensagem 1: %s\nHash 1: %x\n", msg1, hash1)
	fmt.Printf("Mensagem 2: %s\nHash 2: %x\n", msg2, hash2)

	if hash1 == hash2 {
		fmt.Println("Colisão encontrada!")
	} else {
		fmt.Println("Nenhuma colisão encontrada.")
	}
}

func main() {
	findCollision()
}

</code></pre>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="família-de-algoritmos-des---data-encryption-standard"><a class="header" href="#família-de-algoritmos-des---data-encryption-standard">Família de Algoritmos DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="família-de-algoritmos-sha---secure-hash-algorithms"><a class="header" href="#família-de-algoritmos-sha---secure-hash-algorithms">Família de Algoritmos SHA - Secure Hash Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pbkdf2-argon2-e-scrypt---hash-para-senhas"><a class="header" href="#pbkdf2-argon2-e-scrypt---hash-para-senhas">PBKDF2, Argon2 e Scrypt - Hash para Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorítmos-de-criptografia"><a class="header" href="#algorítmos-de-criptografia">Algorítmos de Criptografia</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="des---data-encryption-standard"><a class="header" href="#des---data-encryption-standard">DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3des---triple-des"><a class="header" href="#3des---triple-des">3DES - Triple DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aes---advanced-encryption-standard"><a class="header" href="#aes---advanced-encryption-standard">AES - Advanced Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rsa---rivest-shamir-e-adleman"><a class="header" href="#rsa---rivest-shamir-e-adleman">RSA - Rivest, Shamir e Adleman</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecdsa---elliptic-curve-digital-signature-algorithm"><a class="header" href="#ecdsa---elliptic-curve-digital-signature-algorithm">ECDSA - Elliptic Curve Digital Signature Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hmac---assinaturas-seguras"><a class="header" href="#hmac---assinaturas-seguras">HMAC - Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografia-simétrica-vs-assimétrica"><a class="header" href="#criptografia-simétrica-vs-assimétrica">Criptografia Simétrica vs Assimétrica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls-e-certificados-ssl"><a class="header" href="#tls-e-certificados-ssl">TLS e Certificados SSL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="como-funciona-o-handshake-tls"><a class="header" href="#como-funciona-o-handshake-tls">Como Funciona o Handshake TLS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="certificados-e-autoridades-certificadoras"><a class="header" href="#certificados-e-autoridades-certificadoras">Certificados e Autoridades Certificadoras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cipher-suites-e-forward-secrecy"><a class="header" href="#cipher-suites-e-forward-secrecy">Cipher Suites e Forward Secrecy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go"><a class="header" href="#exemplo-prático-com-go">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segurança-em-apis-rest"><a class="header" href="#segurança-em-apis-rest">Segurança em APIs REST</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="https-obrigatório"><a class="header" href="#https-obrigatório">HTTPS Obrigatório</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protegendo-endpoints-com-jwt"><a class="header" href="#protegendo-endpoints-com-jwt">Protegendo Endpoints com JWT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limiting-e-proteção-contra-dos"><a class="header" href="#rate-limiting-e-proteção-contra-dos">Rate Limiting e Proteção contra DoS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assinaturas-hmac-para-webhooks"><a class="header" href="#assinaturas-hmac-para-webhooks">Assinaturas HMAC para Webhooks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-web-token-jwt"><a class="header" href="#json-web-token-jwt">JSON Web Token (JWT)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estrutura-de-um-jwt"><a class="header" href="#estrutura-de-um-jwt">Estrutura de um JWT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assinatura-e-verificação"><a class="header" href="#assinatura-e-verificação">Assinatura e Verificação</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt-expiração-e-refresh-token"><a class="header" href="#jwt-expiração-e-refresh-token">JWT Expiração e Refresh Token</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-1"><a class="header" href="#exemplo-prático-com-go-1">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-20-e-openid-connect"><a class="header" href="#oauth-20-e-openid-connect">OAuth 2.0 e OpenID Connect</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluxo-authorization-code"><a class="header" href="#fluxo-authorization-code">Fluxo Authorization Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-credentials-e-machine-to-machine"><a class="header" href="#client-credentials-e-machine-to-machine">Client Credentials e Machine-to-Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-scopes-e-permissões"><a class="header" href="#oauth-scopes-e-permissões">OAuth Scopes e Permissões</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-2"><a class="header" href="#exemplo-prático-com-go-2">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-web-token-jwt-1"><a class="header" href="#json-web-token-jwt-1">JSON Web Token (JWT)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estrutura-de-um-jwt-1"><a class="header" href="#estrutura-de-um-jwt-1">Estrutura de um JWT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assinatura-e-verificação-1"><a class="header" href="#assinatura-e-verificação-1">Assinatura e Verificação</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt-expiração-e-refresh-token-1"><a class="header" href="#jwt-expiração-e-refresh-token-1">JWT Expiração e Refresh Token</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-3"><a class="header" href="#exemplo-prático-com-go-3">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-20-e-openid-connect-1"><a class="header" href="#oauth-20-e-openid-connect-1">OAuth 2.0 e OpenID Connect</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluxo-authorization-code-1"><a class="header" href="#fluxo-authorization-code-1">Fluxo Authorization Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-credentials-e-machine-to-machine-1"><a class="header" href="#client-credentials-e-machine-to-machine-1">Client Credentials e Machine-to-Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-scopes-e-permissões-1"><a class="header" href="#oauth-scopes-e-permissões-1">OAuth Scopes e Permissões</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-4"><a class="header" href="#exemplo-prático-com-go-4">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colisão-de-hash-e-birthday-attack"><a class="header" href="#colisão-de-hash-e-birthday-attack">Colisão de Hash e Birthday Attack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ataques-a-tls---beast-poodle-mitm"><a class="header" href="#ataques-a-tls---beast-poodle-mitm">Ataques a TLS - BEAST, POODLE, MITM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quebra-de-senhas---ataques-de-força-bruta-e-rainbow-tables"><a class="header" href="#quebra-de-senhas---ataques-de-força-bruta-e-rainbow-tables">Quebra de Senhas - Ataques de Força Bruta e Rainbow Tables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="armazenamento-seguro-de-senhas"><a class="header" href="#armazenamento-seguro-de-senhas">Armazenamento Seguro de Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bcrypt-argon2-e-pbkdf2"><a class="header" href="#bcrypt-argon2-e-pbkdf2">Bcrypt, Argon2 e PBKDF2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erros-comuns-no-hashing-de-senhas"><a class="header" href="#erros-comuns-no-hashing-de-senhas">Erros Comuns no Hashing de Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerenciamento-de-tokens-seguros"><a class="header" href="#gerenciamento-de-tokens-seguros">Gerenciamento de Tokens Seguros</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="armazenando-tokens-com-segurança"><a class="header" href="#armazenando-tokens-com-segurança">Armazenando Tokens com Segurança</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expiração-e-rotação-de-tokens"><a class="header" href="#expiração-e-rotação-de-tokens">Expiração e Rotação de Tokens</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist-de-segurança-para-apis"><a class="header" href="#checklist-de-segurança-para-apis">Checklist de Segurança para APIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criando-um-servidor-oauth2-com-go"><a class="header" href="#criando-um-servidor-oauth2-com-go">Criando um Servidor OAuth2 com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protegendo-um-backend-com-jwt-e-tls"><a class="header" href="#protegendo-um-backend-com-jwt-e-tls">Protegendo um Backend com JWT e TLS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementando-um-webhook-seguro-com-hmac"><a class="header" href="#implementando-um-webhook-seguro-com-hmac">Implementando um Webhook Seguro com HMAC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliotecas-recomendadas"><a class="header" href="#bibliotecas-recomendadas">Bibliotecas Recomendadas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links-e-leituras-adicionais"><a class="header" href="#links-e-leituras-adicionais">Links e Leituras Adicionais</a></h1>
<p>[1] Claude E. Shannon, "Communication Theory of Secrecy Systems," Bell System Technical Journal, vol. 28, no. 4, pp. 656-715, 1949.</p>
<p>[2] R. Rivest, "The MD5 Message-Digest Algorithm," RFC 1321, April 1992. [Online]. Available: https://www.rfc-editor.org/rfc/rfc1321</p>
<p>[3] National Institute of Standards and Technology (NIST), "Advanced Encryption Standard (AES)", <em>FIPS PUB 197</em>, 2001. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/197/final</p>
<p>[4] National Institute of Standards and Technology (NIST), "Data Encryption Standard (DES)", <em>FIPS PUB 46-3</em>, 1999. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/46/3/final</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
