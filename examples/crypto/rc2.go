package main

import (
	"fmt"
)

type RC2 struct {
	K [64]uint16
}

var piTable = [256]byte{
	217, 120, 249, 196, 25, 221, 181, 237, 40, 231, 230, 173, 232, 96, 49, 222,
	179, 48, 65, 199, 251, 236, 139, 148, 245, 131, 160, 218, 251, 82, 206, 78,
	43, 250, 126, 186, 26, 187, 234, 242, 47, 238, 122, 169, 104, 121, 145, 21,
	178, 7, 63, 148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90,
	144, 50, 39, 53, 88, 98, 103, 30, 126, 6, 204, 24, 234, 236, 202, 241,
	18, 214, 227, 20, 101, 190, 70, 97, 122, 166, 148, 132, 123, 223, 203, 224,
	231, 174, 218, 35, 9, 168, 142, 23, 73, 158, 198, 133, 220, 249, 91, 17,
	149, 184, 115, 171, 99, 190, 52, 210, 105, 242, 60, 192, 175, 43, 252, 107,
	5, 211, 38, 141, 250, 13, 140, 153, 233, 212, 153, 197, 1, 193, 73, 209,
	76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164,
	100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 222, 180, 247,
	244, 197, 225, 211, 138, 225, 114, 167, 40, 249, 193, 171, 239, 35, 114, 15,
	0, 203, 101, 191, 51, 238, 110, 200, 103, 119, 160, 46, 219, 56, 85, 66,
	94, 250, 109, 133, 203, 72, 66, 189, 226, 134, 59, 26, 192, 202, 254, 31,
	157, 130, 206, 247, 121, 245, 0, 70, 66, 205, 201, 164, 39, 184, 144, 90,
	23, 94, 11, 243, 140, 248, 135, 132, 59, 73, 41, 122, 10, 196, 153, 34,
}

func expandKey(L []byte, T1 int) [64]uint16 {
	var K [64]uint16
	var buf [128]byte
	copy(buf[:], L)
	t := len(L)
	if t < 128 {
		for i := t; i < 128; i++ {
			buf[i] = piTable[(int(buf[i-1])+int(buf[i-t]))%256]
		}
	}
	T8 := (T1 + 7) / 8
	TM := byte(0xFF >> ((8*T8 - T1) & 7))
	buf[128-T8] = piTable[buf[128-T8]&TM]
	for i := 127 - T8; i >= 0; i-- {
		buf[i] = piTable[buf[i+1]^buf[i+T8]]
	}
	for i := 0; i < 64; i++ {
		K[i] = uint16(buf[2*i]) | uint16(buf[2*i+1])<<8
	}
	return K
}

func (rc2 *RC2) EncryptBlock(B []byte) []byte {
	R := make([]uint16, 4)
	for i := 0; i < 4; i++ {
		R[i] = uint16(B[2*i]) | uint16(B[2*i+1])<<8
	}
	j := 0
	for i := 0; i < 5; i++ {
		R[0] = R[0] + (R[1]&^R[3])^(R[2]&R[3]) + rc2.K[j]; R[0] = R[0]<<1 | R[0]>>15; j++
		R[1] = R[1] + (R[2]&^R[0])^(R[3]&R[0]) + rc2.K[j]; R[1] = R[1]<<2 | R[1]>>14; j++
		R[2] = R[2] + (R[3]&^R[1])^(R[0]&R[1]) + rc2.K[j]; R[2] = R[2]<<3 | R[2]>>13; j++
		R[3] = R[3] + (R[0]&^R[2])^(R[1]&R[2]) + rc2.K[j]; R[3] = R[3]<<5 | R[3]>>11; j++
	}
	R[0] += rc2.K[R[3]&63]
	R[1] += rc2.K[R[0]&63]
	R[2] += rc2.K[R[1]&63]
	R[3] += rc2.K[R[2]&63]
	for i := 0; i < 6; i++ {
		R[0] = R[0] + (R[1]&^R[3])^(R[2]&R[3]) + rc2.K[j]; R[0] = R[0]<<1 | R[0]>>15; j++
		R[1] = R[1] + (R[2]&^R[0])^(R[3]&R[0]) + rc2.K[j]; R[1] = R[1]<<2 | R[1]>>14; j++
		R[2] = R[2] + (R[3]&^R[1])^(R[0]&R[1]) + rc2.K[j]; R[2] = R[2]<<3 | R[2]>>13; j++
		R[3] = R[3] + (R[0]&^R[2])^(R[1]&R[2]) + rc2.K[j]; R[3] = R[3]<<5 | R[3]>>11; j++
	}
	R[0] += rc2.K[R[3]&63]
	R[1] += rc2.K[R[0]&63]
	R[2] += rc2.K[R[1]&63]
	R[3] += rc2.K[R[2]&63]
	for i := 0; i < 5; i++ {
		R[0] = R[0] + (R[1]&^R[3])^(R[2]&R[3]) + rc2.K[j]; R[0] = R[0]<<1 | R[0]>>15; j++
		R[1] = R[1] + (R[2]&^R[0])^(R[3]&R[0]) + rc2.K[j]; R[1] = R[1]<<2 | R[1]>>14; j++
		R[2] = R[2] + (R[3]&^R[1])^(R[0]&R[1]) + rc2.K[j]; R[2] = R[2]<<3 | R[2]>>13; j++
		R[3] = R[3] + (R[0]&^R[2])^(R[1]&R[2]) + rc2.K[j]; R[3] = R[3]<<5 | R[3]>>11; j++
	}
	out := make([]byte, 8)
	for i := 0; i < 4; i++ {
		out[2*i] = byte(R[i])
		out[2*i+1] = byte(R[i] >> 8)
	}
	return out
}

func main() {
	key := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	plain := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	rc2 := RC2{expandKey(key, 64)}
	ct := rc2.EncryptBlock(plain)
	fmt.Printf("Ciphertext: %X\n", ct)
}
