<!DOCTYPE HTML>
<html lang="pt_BR" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Operadores Bitwise - Criptografia para Desenvolvedores Go</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Criptografia para Desenvolvedores Go</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operadores-bitwise"><a class="header" href="#operadores-bitwise">Operadores Bitwise</a></h1>
<h2 id="o-que-são-operadores-bit-a-bit"><a class="header" href="#o-que-são-operadores-bit-a-bit">O que são operadores bit a bit?</a></h2>
<p>Operadores bitwise (bit a bit) são operadores que atuam diretamente sobre os bits de inteiros binários. São fundamentais em implementações de algoritmos criptográficos, protocolos binários, manipulação de flags e otimizações de espaço e tempo.</p>
<p>Ao contrário dos operadores aritméticos tradicionais <code>(+, -, *, /)</code>, operadores bitwise operam posição a posição, diretamente sobre os bits das representações binárias dos operandos.</p>
<h2 id="operadores-fundamentais"><a class="header" href="#operadores-fundamentais">Operadores Fundamentais</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operador</th><th>Nome</th><th>Descrição</th></tr></thead><tbody>
<tr><td>&amp;</td><td>AND</td><td>Retorna 1 se ambos os bits forem 1.</td></tr>
<tr><td>|</td><td>OR</td><td>Retorna 1 se pelo menos um dos bits é 1.</td></tr>
<tr><td>^</td><td>XOR</td><td>Exclusivo: Retorna 1 se exatamente um dos bits é 1.</td></tr>
<tr><td>~</td><td>NOT</td><td>Inverte todos os bits.</td></tr>
<tr><td>&amp;^</td><td>AND NOT (Go)</td><td>Zera os bits do primeiro operando que forem 1 no segundo operando.</td></tr>
<tr><td>&lt;&lt;</td><td>Deslocamento à esquerda</td><td>Desloca os bits n posições à esquerda. (equivalente a multiplicar por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
<tr><td>&gt;&gt;</td><td>Deslocamento à direita</td><td>Desloca os bits n posições à direita. (equivalente a dividir por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
</tbody></table>
</div>
<p>A tabela a seguir ilustra como os operadores bitwise atuam sobre valores binários. Os exemplos utilizam inteiros de 8 bits para facilitar a visualização:</p>
<div class="table-wrapper"><table><thead><tr><th>Expressão</th><th>Operação</th><th>Resultado Binário</th><th>Resultado Decimal</th></tr></thead><tbody>
<tr><td><code>0b1100 &amp; 0b1010</code></td><td>AND</td><td><code>0b1000</code></td><td><code>8</code></td></tr>
<tr><td><code>0b1100 | 0b1010</code></td><td>OR</td><td><code>0b1110</code></td><td><code>14</code></td></tr>
<tr><td><code>0b1100 ^ 0b1010</code></td><td>XOR</td><td><code>0b0110</code></td><td><code>6</code></td></tr>
<tr><td><code>^0b1100</code></td><td>NOT (unário)</td><td><code>0b...11110011</code>¹</td><td>depende do tipo</td></tr>
<tr><td><code>0b0001 &lt;&lt; 2</code></td><td>Shift à esquerda</td><td><code>0b0100</code></td><td><code>4</code></td></tr>
<tr><td><code>0b1000 &gt;&gt; 2</code></td><td>Shift à direita</td><td><code>0b0010</code></td><td><code>2</code></td></tr>
<tr><td><code>0b1111 &amp;^ 0b0101</code></td><td>AND NOT (Go)</td><td><code>0b1010</code>²</td><td><code>10</code></td></tr>
</tbody></table>
</div>
<p>¹ Em Go, o operador <code>^</code> representa o NOT unário. O resultado depende do tipo da variável (<code>uint8</code>, <code>int</code>, etc.). Por exemplo, <code>^uint8(0b1100)</code> resulta em <code>0b11110011</code> (243 decimal).</p>
<p>² O operador <code>&amp;^</code> é específico da linguagem Go e realiza uma operação conhecida como "bit clear". Ele equivale a <code>a &amp; (~b)</code>, ou seja, <strong>faz um NOT bit a bit do segundo operando e aplica AND com o primeiro</strong>. Em C, essa operação seria expressa como <code>a &amp; (~b)</code>.</p>
<h2 id="exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc"><a class="header" href="#exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc">Exemplo prático 1: isolando bits com máscaras (Base64, SHA, etc)</a></h2>
<p>Uma das aplicações mais comuns do operador AND (<code>&amp;</code>) é a extração de porções específicas de um número binário, por meio de máscaras. Isso é amplamente usado em codificações como Base64, compressão, protocolos e algoritmos criptográficos.</p>
<p>Suponha que você queira extrair os 6 bits menos significativos de um byte. Para isso, podemos usar uma máscara <code>0b00111111</code>, que equivale a <code>0x3F</code> em hexadecimal. Veja:</p>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)

</code></pre>
<p>O operador <code>&amp;</code> preserva apenas os bits em que ambos os operandos são 1. Portanto, ele serve como uma forma seletiva de “manter” ou “zerar” bits.</p>
<p><strong>Tabela verdade para <code>AND</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>AND</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>&amp;</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>&amp;</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>Com isso, chegamos à conclusão de que:</p>
<ul>
<li>
<p>Uma máscara 0b00000000 apaga todos os bits.</p>
</li>
<li>
<p>Uma máscara 0b00000001 testa apenas o bit menos significativo.</p>
</li>
<li>
<p>Para extrair bits específicos, basta construir uma máscara com 1s nas posições desejadas.</p>
</li>
</ul>
<p>Por exemplo, podemos extrair os bits 3 e 4 de um byte da seguinte forma:</p>
<pre><code>BYTE qualquer:            01010010  (82)
Máscara:                  00011000  (0x18)
Resultado após AND:       00010000  (16)
</code></pre>
<h2 id="exemplo-prático-2-usando-bits-como-flags"><a class="header" href="#exemplo-prático-2-usando-bits-como-flags">Exemplo prático 2: usando bits como flags</a></h2>
<p>Uma aplicação prática de operadores bitwise é o uso de flags, onde cada bit representa uma característica binária (ligado ou desligado). Esse padrão é comum em linguagens como C, Go e Rust, e em estruturas compactas de controle, como permissões ou estados.</p>
<p>Abaixo, usaremos o contexto do anime Naruto para ilustrar como os operadores bitwise podem ser usados para representar e manipular características das personagens.</p>
<h3 id="definindo-estilos-de-um-ninja"><a class="header" href="#definindo-estilos-de-um-ninja">Definindo estilos de um ninja</a></h3>
<p>Abaixo, cada constante representa uma posição de bit única:</p>
<pre><code class="language-go">type NinjaRank uint8

const (
	Genin     NinjaRank = 1 &lt;&lt; iota // 00000001
	Chunin                          // 00000010
	Jounin                          // 00000100
	Ambu                            // 00001000
	Sannin                          // 00010000
	Kage                            // 00100000
	Sage                            // 01000000
	Jinchuriki                      // 10000000
)
</code></pre>
<h4 id="combinando-características-com-or-"><a class="header" href="#combinando-características-com-or-">Combinando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto  := Genin  | Sage   | Jinchuriki       // 10100001
tsunade := Jounin | Sannin | Kage             // 00110100
kakashi := Jounin | Ambu                      // 00001100
</code></pre>
<p><strong>Tabela verdade para <code>OR</code></strong></p>
<p>Para entender como a combinação funciona bit a bit, veja a tabela verdade da operação OR:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>|</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>O operador <code>|</code> retorna <code>1</code> sempre que pelo menos um dos bits for <code>1</code>. Por isso ele é ideal para adicionar flags a uma variável sem interferir nos bits já definidos.</p>
<h4 id="testando-características-com-and-"><a class="header" href="#testando-características-com-and-">Testando características com AND (<code>&amp;</code>)</a></h4>
<pre><code class="language-go">if naruto &amp; Genin == Genin {
	fmt.Println("Naruto é Genin.")
}
</code></pre>
<h4 id="adicionando-características-com-or-"><a class="header" href="#adicionando-características-com-or-">Adicionando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto |= Jounin // promove Naruto para Jounin
</code></pre>
<h4 id="removendo-características-com-and-not-"><a class="header" href="#removendo-características-com-and-not-">Removendo características com AND NOT (<code>&amp;^</code>)</a></h4>
<pre><code class="language-go">kakashi &amp;^= Kage // remove o status de Kage de Kakashi
</code></pre>
<p><strong>Tabela verdade para <code>NOT</code></strong></p>
<p>O operador NOT (<code>~</code>) inverte cada bit individualmente:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>NOT</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>~</td><td>0</td></tr>
<tr><td>0</td><td>~</td><td>1</td></tr>
</tbody></table>
</div>
<h2 id="exemplo-prático-3-usando-xor-em-prngs-e-criptografia"><a class="header" href="#exemplo-prático-3-usando-xor-em-prngs-e-criptografia">Exemplo prático 3: usando <code>XOR</code> em PRNGs e criptografia</a></h2>
<p>O operador XOR (<code>^</code>) é um dos mais utilizados em criptografia moderna, principalmente por suas propriedades de reversibilidade e difusão controlada. Ele também aparece como base de muitos geradores de números pseudoaleatórios (PRNGs), como a família <strong>Xorshift</strong>.</p>
<p>A propriedade central do <code>XOR</code> é:</p>
<pre><code>A ^ A = 0        (auto-cancelamento)
A ^ 0 = A        (identidade)
A ^ B ^ B = A    (reversível)
</code></pre>
<p>Essas propriedades tornam o <code>XOR</code> ideal para cifragem, embaralhamento e geração determinística de entropia.</p>
<h3 id="xorshift-simplificado"><a class="header" href="#xorshift-simplificado">Xorshift simplificado</a></h3>
<p>A seguir, um PRNG de 32 bits usando apenas <code>XOR</code> e <code>shifts</code>:</p>
<pre><code class="language-go">package main

import "fmt"

func xorshift32(x uint32) uint32 {
	x ^= x &lt;&lt; 13
	x ^= x &gt;&gt; 17
	x ^= x &lt;&lt; 5
	return x
}

func main() {
	seed := uint32(123456789)
	for i := 0; i &lt; 5; i++ {
		seed = xorshift32(seed)
		fmt.Printf("Valor %d: %032b\n", i+1, seed)
	}
}
</code></pre>
<p>Esse gerador, embora simples, é capaz de produzir uma sequência pseudoaleatória com boa dispersão de bits. Ele é construído exclusivamente com operadores <code>^</code>, <code>&lt;&lt;</code> e <code>&gt;&gt;</code>.</p>
<p><strong>Tabela verdade para <code>XOR</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>XOR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>^</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>^</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>^</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>^</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>A operação retorna <code>1</code> apenas quando os bits são diferentes. Por isso, é chamada de <em>OU exclusivo</em> (exclusive OR).</p>
<h2 id="exemplo-prático-4-deslocamento-de-bits--e-"><a class="header" href="#exemplo-prático-4-deslocamento-de-bits--e-">Exemplo prático 4: deslocamento de bits (<code>&lt;&lt;</code> e <code>&gt;&gt;</code>)</a></h2>
<p>Os operadores de deslocamento <code>&lt;&lt;</code> (shift à esquerda) e <code>&gt;&gt;</code> (shift à direita) são amplamente utilizados em operações de dispersão, ajustes de bits e estruturação de dados binários. Eles são comuns em geradores pseudoaleatórios, cifras e funções de hash.</p>
<p>A operação <code>x &lt;&lt; n</code> desloca os bits de <code>x</code> para a esquerda em <code>n</code> posições, preenchendo com <code>0</code> à direita. Já <code>x &gt;&gt; n</code> desloca os bits para a direita, preenchendo com <code>0</code> à esquerda (em inteiros sem sinal).</p>
<h3 id="aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register"><a class="header" href="#aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register">Aplicação prática: passo de um LFSR (Linear Feedback Shift Register)</a></h3>
<p>Sem entrar nos detalhes do algoritmo agora, podemos observar um exemplo de uso de deslocamento para atualizar um valor de estado:</p>
<pre><code class="language-go">package main

import "fmt"

func stepLFSR(state uint8) uint8 {
	feedback := ((state &gt;&gt; 0) ^ (state &gt;&gt; 2)) &amp; 1
	state = (state &gt;&gt; 1) | (feedback &lt;&lt; 7)
	return state
}

func main() {
	state := uint8(0b10010010)
	for i := 0; i &lt; 5; i++ {
		state = stepLFSR(state)
		fmt.Printf("Estado %d: %08b\n", i+1, state)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li>
<p>Um bit de realimentação é calculado via <code>XOR</code> de dois bits do estado.</p>
</li>
<li>
<p>O estado é deslocado para a direita <code>(&gt;&gt; 1)</code>, descartando o LSB.</p>
</li>
<li>
<p>O novo bit de feedback é colocado na posição mais à esquerda via feedback <code>&lt;&lt; 7</code>.</p>
</li>
</ul>
<p>Embora não exista uma tabela verdade para o deslocamento, segue um exemplo visual do deslocamento:</p>
<div class="table-wrapper"><table><thead><tr><th>Operação</th><th>Entrada</th><th>Resultado</th><th>Observação</th></tr></thead><tbody>
<tr><td><code>x &lt;&lt; 1</code></td><td><span style="color:#ff6666;">0</span>1010010</td><td>1010010<span style="color:#66ccff;">0</span></td><td>Perde o MSB, ganha 0 no LSB</td></tr>
<tr><td><code>x &gt;&gt; 1</code></td><td>0101001<span style="color:#ff6666;">0</span></td><td><span style="color:#66ccff;">0</span>0101001</td><td>Perde o LSB, ganha 0 no MSB</td></tr>
<tr><td><code>x &gt;&gt; 3</code></td><td>111<span style="color:#ff6666;">00000</span></td><td><span style="color:#66ccff;">000</span>11100</td><td>Bits deslizam 3 casas à direita</td></tr>
</tbody></table>
</div>
<p>Esse comportamento é determinístico, barato computacionalmente e essencial para muitas transformações em cifras e PRNGs.</p>
<h2 id="importância-em-criptografia"><a class="header" href="#importância-em-criptografia">Importância em Criptografia</a></h2>
<p>Operadores bitwise são usados constantemente em algoritmos criptográficos. Exemplos:</p>
<ul>
<li>
<p>O <code>XOR</code> (<code>^</code>) é a operação mais usada em cifras de fluxo e blocos — por exemplo, no modo CTR ou no cálculo de paridade.</p>
</li>
<li>
<p>Cifras de fluxo: cada byte da mensagem é combinado com um byte do keystream usando <code>XOR</code>.</p>
</li>
<li>
<p>Funções hash: o <code>XOR</code> é usado para compressão, mistura e difusão de bits internos.</p>
</li>
<li>
<p><code>AND</code>, (<code>&amp;</code>) <code>OR</code> (<code>|</code>), e <code>NOT</code> (<code>~</code>) são usados em compressão de mensagens, máscaras, e manipulação de estruturas internas como as de <strong>SHA-2</strong>.</p>
</li>
<li>
<p>Shifts (<code>&lt;&lt;, &gt;&gt;</code>) implementam rotações e misturas, fundamentais em <strong>S-Boxes</strong> e funções de dispersão.</p>
</li>
</ul>
<h2 id="considerações"><a class="header" href="#considerações">Considerações</a></h2>
<p>Dominar os operadores bitwise é essencial para compreender o funcionamento interno de muitos algoritmos criptográficos. Além disso, esse tipo de manipulação é eficiente, compacta e amplamente utilizada em implementações de baixo nível, seja em bibliotecas de segurança, protocolos ou microcontroladores.</p>
<p>Nos próximos tópicos, aplicaremos esses conceitos na manipulação de blocos de dados, operações estruturais e transformação binária direta.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../conceitos/manipulacao-de-dados/endianness.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../conceitos/manipulacao-de-dados/operacoes-em-blocos.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../conceitos/manipulacao-de-dados/endianness.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../conceitos/manipulacao-de-dados/operacoes-em-blocos.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
