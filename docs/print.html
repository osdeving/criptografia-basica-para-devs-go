<!DOCTYPE HTML>
<html lang="pt_BR" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Criptografia para Desenvolvedores Go</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Criptografia para Desenvolvedores Go</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="manipulação-de-dados"><a class="header" href="#manipulação-de-dados">Manipulação de Dados</a></h1>
<p>Esta seção estabelece os fundamentos práticos para entender como os dados binários são tratados internamente — ponto essencial para compreender cifras, hashes e protocolos.</p>
<p>Começaremos com uma explicação rápida sobre endianness em <strong>Endianness – Organização de Bytes na Memória</strong>, que aborda como diferentes arquiteturas armazenam inteiros e como isso afeta a interoperabilidade e o uso seguro da criptografia.</p>
<p>Em seguida, em <strong>Operadores Bitwise</strong>, exploraremos os operadores bit a bit, que são fundamentais para a construção de cifras e hashes. Mostraremos como AND, OR, XOR e deslocamentos são usados na manipulação de bits, no controle de flags e na implementação de PRNGs e mecanismos criptográficos.</p>
<p>Veremos depois, em <strong>Operações em Blocos</strong>, os modos de operação (ECB, CBC, etc.) como técnicas de controle de fluxo entre blocos de dados — uma estrutura essencial para cifras reais. Aqui a conexão com criptografia é mais acentuada, mas o foco continua sendo como manipular blocos binários de forma sistemática.</p>
<p>Na sequência, estudaremos três conceitos fundamentais para o projeto de cifras modernas: <strong>Confusão e Difusão</strong>, <strong>S-Box</strong> e <strong>Permutações e Trocas</strong>. Embora estejam mais diretamente associados ao campo da criptografia, todos eles são, na essência, formas especializadas de manipulação de dados binários. Por esse motivo, optamos por incluí-los nesta seção, mantendo a coerência conceitual com os tópicos anteriores.</p>
<blockquote>
<p>Esses conceitos serão reaproveitados ao longo do livro e servem de base para o entendimento de algoritmos criptográficos reais. O objetivo é diminuir o esforço cognitivo ao apresentar tópicos mais avançados, dando a chance do leitor se familiarizar com tópicos mais gerais envolvendo manipulação de dados.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução"><a class="header" href="#introdução">Introdução</a></h1>
<p>Antes de explorarmos algoritmos criptográficos como funções hash, cifras de bloco ou mecanismos de assinatura, é essencial compreender <strong>como os dados são representados e manipulados em baixo nível</strong>. A criptografia opera sobre sequências binárias, e muitas de suas construções dependem de operações como <strong>máscaras de bits, deslocamentos, permutações, concatenação e particionamento de blocos</strong>.</p>
<p>Esta seção reúne os fundamentos práticos que formam a base para a implementação e compreensão de algoritmos criptográficos. Embora não envolvam segurança por si só, esses conceitos estruturam a <strong>transformação e o fluxo de dados</strong>, e são usados repetidamente em construções como:</p>
<ul>
<li>
<p>Expansão e compressão de blocos (como em DES)</p>
</li>
<li>
<p>Rotação de palavras (como em SHA e AES)</p>
</li>
<li>
<p>Aplicação de máscaras e XORs (ubíquos em todas as cifras)</p>
</li>
<li>
<p>Organização de blocos e endianness (em PBKDF2, HMAC, etc.)</p>
</li>
</ul>
<p>Mesmo algoritmos clássicos, como MD2, baseiam parte de sua segurança e funcionamento em <strong>operações simples, porém precisas, sobre bytes e bits</strong>. Por isso, essa preparação técnica é indispensável para leitura crítica, implementação correta e análise de sistemas criptográficos.</p>
<p>Nos próximos tópicos, cobriremos:</p>
<ul>
<li>
<p>A ordem dos bytes na memória (<strong>endianness</strong>)</p>
</li>
<li>
<p>Os operadores de bit mais utilizados (<strong>bitwise</strong>)</p>
</li>
<li>
<p>Como manipular dados em blocos, rotacionar e reorganizar estruturas</p>
</li>
</ul>
<p>Esses conceitos serão reaproveitados ao longo de todo o conteúdo técnico do livro e facilitarão a compreensão tanto matemática quanto prática dos algoritmos, reduzindo o esforço cognitivo necessário para entender as diversas manipulações de dados.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="endianness---organização-de-bytes-na-memória"><a class="header" href="#endianness---organização-de-bytes-na-memória">Endianness - Organização de Bytes na Memória</a></h1>
<h2 id="o-que-é-endianness"><a class="header" href="#o-que-é-endianness">O que é Endianness?</a></h2>
<p><strong>Endianness</strong> refere-se à ordem na qual os bytes de uma palavra multibyte (como <code>int32</code>, <code>uint64</code>, etc.) são armazenados na memória. Essa ordem pode variar entre arquiteturas e afeta diretamente a forma como os dados binários são interpretados em operações de leitura, escrita, serialização e comunicação entre sistemas.</p>
<p>Existem dois modelos principais: <strong>Little-endian</strong> e <strong>Big-endian</strong>.</p>
<h2 id="little-endian"><a class="header" href="#little-endian">Little-endian</a></h2>
<p>Nesse modelo, o <strong>byte menos significativo</strong> (<em>LSB – Least Significant Byte</em>) é armazenado primeiro, no menor endereço de memória. Suponha que o valor <code>0x12345678</code> (em hexadecimal) seja armazenado em 4 bytes. A ordem de armazenamento será:</p>
<div class="table-wrapper"><table><thead><tr><th>Endereço</th><th>Byte</th></tr></thead><tbody>
<tr><td>0x1000</td><td>0x78</td></tr>
<tr><td>0x1001</td><td>0x56</td></tr>
<tr><td>0x1002</td><td>0x34</td></tr>
<tr><td>0x1003</td><td>0x12</td></tr>
</tbody></table>
</div>
<h2 id="big-endian"><a class="header" href="#big-endian">Big-endian</a></h2>
<p>Neste modelo, o <strong>byte mais significativo</strong> (<em>MSB – Most Significant Byte</em>) é armazenado primeiro. Para o mesmo valor <code>0x12345678</code>, teríamos:</p>
<div class="table-wrapper"><table><thead><tr><th>Endereço</th><th>Byte</th></tr></thead><tbody>
<tr><td>0x1000</td><td>0x12</td></tr>
<tr><td>0x1001</td><td>0x34</td></tr>
<tr><td>0x1002</td><td>0x56</td></tr>
<tr><td>0x1003</td><td>0x78</td></tr>
</tbody></table>
</div>
<h2 id="implementação-em-go"><a class="header" href="#implementação-em-go">Implementação em Go</a></h2>
<p>Vamos verificar a ordem dos bytes em memória e converter entre endiannesses.</p>
<h3 id="detectando-o-endianness-do-sistema"><a class="header" href="#detectando-o-endianness-do-sistema">Detectando o endianness do sistema</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
	"unsafe"
)

func main() {
	var i int32 = 0x01020304
	ptr := (*[4]byte)(unsafe.Pointer(&amp;i))

	if ptr[0] == 0x04 {
		fmt.Printf("Primeiro byte é %v → sistema é Little-endian (ex: x86)\n", ptr[0])
	} else {
		fmt.Printf("Primeiro byte é %v → sistema é Big-endian\n", ptr[0])
	}
}
</code></pre>
<p>Saída esperada:</p>
<pre><code>Primeiro byte é 4 → sistema é Little-endian (ex: x86)
</code></pre>
<h3 id="conversão-explícita-usando-o-pacote-encodingbinary"><a class="header" href="#conversão-explícita-usando-o-pacote-encodingbinary">Conversão explícita usando o pacote encoding/binary</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
	"unsafe"
)

func main() {
	var i uint32 = 0x01020304
	b := make([]byte, 4)

	binary.BigEndian.PutUint32(b, i)
	fmt.Printf("Big-endian: % x\n", b)

	binary.LittleEndian.PutUint32(b, i)
	fmt.Printf("Little-endian: % x\n", b)
}
</code></pre>
<p>Saída esperada:</p>
<pre><code>Big-endian:    01 02 03 04
Little-endian: 04 03 02 01

</code></pre>
<h2 id="considerações"><a class="header" href="#considerações">Considerações</a></h2>
<p>Saber lidar com endianness é fundamental ao manipular dados binários em protocolos, arquivos binários, criptografia ou comunicação entre sistemas heterogêneos. Por exemplo:</p>
<ul>
<li>
<p>Algoritmos como <strong>SHA</strong> e <strong>MD5</strong> especificam explicitamente a ordem dos bytes em suas operações internas.</p>
</li>
<li>
<p>Protocolos de rede, como <strong>TCP/IP</strong>, utilizam o modelo <strong>big-endian</strong>, também chamado de <em>network byte order</em>.</p>
</li>
</ul>
<p>Arquiteturas modernas como x86 e x86-64 (Intel/AMD) adotam o modelo little-endian como padrão. Isso significa que o byte menos significativo de uma palavra é armazenado no menor endereço de memória. Essa decisão de projeto afeta diretamente a forma como inteiros são representados internamente e exige atenção ao manipular dados provenientes de ambientes que utilizam big-endian, como redes ou formatos binários padronizados.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operadores-bitwise"><a class="header" href="#operadores-bitwise">Operadores Bitwise</a></h1>
<h2 id="o-que-são-operadores-bit-a-bit"><a class="header" href="#o-que-são-operadores-bit-a-bit">O que são operadores bit a bit?</a></h2>
<p>Operadores bitwise (bit a bit) são operadores que atuam diretamente sobre os bits de inteiros binários. São fundamentais em implementações de algoritmos criptográficos, protocolos binários, manipulação de flags e otimizações de espaço e tempo.</p>
<p>Ao contrário dos operadores aritméticos tradicionais <code>(+, -, *, /)</code>, operadores bitwise operam posição a posição, diretamente sobre os bits das representações binárias dos operandos.</p>
<h2 id="operadores-fundamentais"><a class="header" href="#operadores-fundamentais">Operadores Fundamentais</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operador</th><th>Nome</th><th>Descrição</th></tr></thead><tbody>
<tr><td>&amp;</td><td>AND</td><td>Retorna 1 se ambos os bits forem 1.</td></tr>
<tr><td>|</td><td>OR</td><td>Retorna 1 se pelo menos um dos bits é 1.</td></tr>
<tr><td>^</td><td>XOR</td><td>Exclusivo: Retorna 1 se exatamente um dos bits é 1.</td></tr>
<tr><td>~</td><td>NOT</td><td>Inverte todos os bits.</td></tr>
<tr><td>&amp;^</td><td>AND NOT (Go)</td><td>Zera os bits do primeiro operando que forem 1 no segundo operando.</td></tr>
<tr><td>&lt;&lt;</td><td>Deslocamento à esquerda</td><td>Desloca os bits n posições à esquerda. (equivalente a multiplicar por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
<tr><td>&gt;&gt;</td><td>Deslocamento à direita</td><td>Desloca os bits n posições à direita. (equivalente a dividir por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
</tbody></table>
</div>
<p>A tabela a seguir ilustra como os operadores bitwise atuam sobre valores binários. Os exemplos utilizam inteiros de 8 bits para facilitar a visualização:</p>
<div class="table-wrapper"><table><thead><tr><th>Expressão</th><th>Operação</th><th>Resultado Binário</th><th>Resultado Decimal</th></tr></thead><tbody>
<tr><td><code>0b1100 &amp; 0b1010</code></td><td>AND</td><td><code>0b1000</code></td><td><code>8</code></td></tr>
<tr><td><code>0b1100 | 0b1010</code></td><td>OR</td><td><code>0b1110</code></td><td><code>14</code></td></tr>
<tr><td><code>0b1100 ^ 0b1010</code></td><td>XOR</td><td><code>0b0110</code></td><td><code>6</code></td></tr>
<tr><td><code>^0b1100</code></td><td>NOT (unário)</td><td><code>0b...11110011</code>¹</td><td>depende do tipo</td></tr>
<tr><td><code>0b0001 &lt;&lt; 2</code></td><td>Shift à esquerda</td><td><code>0b0100</code></td><td><code>4</code></td></tr>
<tr><td><code>0b1000 &gt;&gt; 2</code></td><td>Shift à direita</td><td><code>0b0010</code></td><td><code>2</code></td></tr>
<tr><td><code>0b1111 &amp;^ 0b0101</code></td><td>AND NOT (Go)</td><td><code>0b1010</code>²</td><td><code>10</code></td></tr>
</tbody></table>
</div>
<p>¹ Em Go, o operador <code>^</code> representa o NOT unário. O resultado depende do tipo da variável (<code>uint8</code>, <code>int</code>, etc.). Por exemplo, <code>^uint8(0b1100)</code> resulta em <code>0b11110011</code> (243 decimal).</p>
<p>² O operador <code>&amp;^</code> é específico da linguagem Go e realiza uma operação conhecida como "bit clear". Ele equivale a <code>a &amp; (~b)</code>, ou seja, <strong>faz um NOT bit a bit do segundo operando e aplica AND com o primeiro</strong>. Em C, essa operação seria expressa como <code>a &amp; (~b)</code>.</p>
<h2 id="exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc"><a class="header" href="#exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc">Exemplo prático 1: isolando bits com máscaras (Base64, SHA, etc)</a></h2>
<p>Uma das aplicações mais comuns do operador AND (<code>&amp;</code>) é a extração de porções específicas de um número binário, por meio de máscaras. Isso é amplamente usado em codificações como Base64, compressão, protocolos e algoritmos criptográficos.</p>
<p>Suponha que você queira extrair os 6 bits menos significativos de um byte. Para isso, podemos usar uma máscara <code>0b00111111</code>, que equivale a <code>0x3F</code> em hexadecimal. Veja:</p>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)

</code></pre>
<p>O operador <code>&amp;</code> preserva apenas os bits em que ambos os operandos são 1. Portanto, ele serve como uma forma seletiva de “manter” ou “zerar” bits.</p>
<p><strong>Tabela verdade para <code>AND</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>AND</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>&amp;</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>&amp;</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>Com isso, chegamos à conclusão de que:</p>
<ul>
<li>
<p>Uma máscara 0b00000000 apaga todos os bits.</p>
</li>
<li>
<p>Uma máscara 0b00000001 testa apenas o bit menos significativo.</p>
</li>
<li>
<p>Para extrair bits específicos, basta construir uma máscara com 1s nas posições desejadas.</p>
</li>
</ul>
<p>Por exemplo, podemos extrair os bits 3 e 4 de um byte da seguinte forma:</p>
<pre><code>BYTE qualquer:            01010010  (82)
Máscara:                  00011000  (0x18)
Resultado após AND:       00010000  (16)
</code></pre>
<h2 id="exemplo-prático-2-usando-bits-como-flags"><a class="header" href="#exemplo-prático-2-usando-bits-como-flags">Exemplo prático 2: usando bits como flags</a></h2>
<p>Uma aplicação prática de operadores bitwise é o uso de flags, onde cada bit representa uma característica binária (ligado ou desligado). Esse padrão é comum em linguagens como C, Go e Rust, e em estruturas compactas de controle, como permissões ou estados.</p>
<p>Abaixo, usaremos o contexto do anime Naruto para ilustrar como os operadores bitwise podem ser usados para representar e manipular características das personagens.</p>
<h3 id="definindo-estilos-de-um-ninja"><a class="header" href="#definindo-estilos-de-um-ninja">Definindo estilos de um ninja</a></h3>
<p>Abaixo, cada constante representa uma posição de bit única:</p>
<pre><code class="language-go">type NinjaRank uint8

const (
	Genin     NinjaRank = 1 &lt;&lt; iota // 00000001
	Chunin                          // 00000010
	Jounin                          // 00000100
	Ambu                            // 00001000
	Sannin                          // 00010000
	Kage                            // 00100000
	Sage                            // 01000000
	Jinchuriki                      // 10000000
)
</code></pre>
<h4 id="combinando-características-com-or-"><a class="header" href="#combinando-características-com-or-">Combinando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto  := Genin  | Sage   | Jinchuriki       // 10100001
tsunade := Jounin | Sannin | Kage             // 00110100
kakashi := Jounin | Ambu                      // 00001100
</code></pre>
<p><strong>Tabela verdade para <code>OR</code></strong></p>
<p>Para entender como a combinação funciona bit a bit, veja a tabela verdade da operação OR:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>|</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>O operador <code>|</code> retorna <code>1</code> sempre que pelo menos um dos bits for <code>1</code>. Por isso ele é ideal para adicionar flags a uma variável sem interferir nos bits já definidos.</p>
<h4 id="testando-características-com-and-"><a class="header" href="#testando-características-com-and-">Testando características com AND (<code>&amp;</code>)</a></h4>
<pre><code class="language-go">if naruto &amp; Genin == Genin {
	fmt.Println("Naruto é Genin.")
}
</code></pre>
<h4 id="adicionando-características-com-or-"><a class="header" href="#adicionando-características-com-or-">Adicionando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto |= Jounin // promove Naruto para Jounin
</code></pre>
<h4 id="removendo-características-com-and-not-"><a class="header" href="#removendo-características-com-and-not-">Removendo características com AND NOT (<code>&amp;^</code>)</a></h4>
<pre><code class="language-go">kakashi &amp;^= Kage // remove o status de Kage de Kakashi
</code></pre>
<p><strong>Tabela verdade para <code>NOT</code></strong></p>
<p>O operador NOT (<code>~</code>) inverte cada bit individualmente:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>NOT</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>~</td><td>0</td></tr>
<tr><td>0</td><td>~</td><td>1</td></tr>
</tbody></table>
</div>
<h2 id="exemplo-prático-3-usando-xor-em-prngs-e-criptografia"><a class="header" href="#exemplo-prático-3-usando-xor-em-prngs-e-criptografia">Exemplo prático 3: usando <code>XOR</code> em PRNGs e criptografia</a></h2>
<p>O operador XOR (<code>^</code>) é um dos mais utilizados em criptografia moderna, principalmente por suas propriedades de reversibilidade e difusão controlada. Ele também aparece como base de muitos geradores de números pseudoaleatórios (PRNGs), como a família <strong>Xorshift</strong>.</p>
<p>A propriedade central do <code>XOR</code> é:</p>
<pre><code>A ^ A = 0        (auto-cancelamento)
A ^ 0 = A        (identidade)
A ^ B ^ B = A    (reversível)
</code></pre>
<p>Essas propriedades tornam o <code>XOR</code> ideal para cifragem, embaralhamento e geração determinística de entropia.</p>
<h3 id="xorshift-simplificado"><a class="header" href="#xorshift-simplificado">Xorshift simplificado</a></h3>
<p>A seguir, um PRNG de 32 bits usando apenas <code>XOR</code> e <code>shifts</code>:</p>
<pre><code class="language-go">package main

import "fmt"

func xorshift32(x uint32) uint32 {
	x ^= x &lt;&lt; 13
	x ^= x &gt;&gt; 17
	x ^= x &lt;&lt; 5
	return x
}

func main() {
	seed := uint32(123456789)
	for i := 0; i &lt; 5; i++ {
		seed = xorshift32(seed)
		fmt.Printf("Valor %d: %032b\n", i+1, seed)
	}
}
</code></pre>
<p>Esse gerador, embora simples, é capaz de produzir uma sequência pseudoaleatória com boa dispersão de bits. Ele é construído exclusivamente com operadores <code>^</code>, <code>&lt;&lt;</code> e <code>&gt;&gt;</code>.</p>
<p><strong>Tabela verdade para <code>XOR</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>XOR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>^</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>^</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>^</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>^</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>A operação retorna <code>1</code> apenas quando os bits são diferentes. Por isso, é chamada de <em>OU exclusivo</em> (exclusive OR).</p>
<h2 id="exemplo-prático-4-deslocamento-de-bits--e-"><a class="header" href="#exemplo-prático-4-deslocamento-de-bits--e-">Exemplo prático 4: deslocamento de bits (<code>&lt;&lt;</code> e <code>&gt;&gt;</code>)</a></h2>
<p>Os operadores de deslocamento <code>&lt;&lt;</code> (shift à esquerda) e <code>&gt;&gt;</code> (shift à direita) são amplamente utilizados em operações de dispersão, ajustes de bits e estruturação de dados binários. Eles são comuns em geradores pseudoaleatórios, cifras e funções de hash.</p>
<p>A operação <code>x &lt;&lt; n</code> desloca os bits de <code>x</code> para a esquerda em <code>n</code> posições, preenchendo com <code>0</code> à direita. Já <code>x &gt;&gt; n</code> desloca os bits para a direita, preenchendo com <code>0</code> à esquerda (em inteiros sem sinal).</p>
<h3 id="aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register"><a class="header" href="#aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register">Aplicação prática: passo de um LFSR (Linear Feedback Shift Register)</a></h3>
<p>Sem entrar nos detalhes do algoritmo agora, podemos observar um exemplo de uso de deslocamento para atualizar um valor de estado:</p>
<pre><code class="language-go">package main

import "fmt"

func stepLFSR(state uint8) uint8 {
	feedback := ((state &gt;&gt; 0) ^ (state &gt;&gt; 2)) &amp; 1
	state = (state &gt;&gt; 1) | (feedback &lt;&lt; 7)
	return state
}

func main() {
	state := uint8(0b10010010)
	for i := 0; i &lt; 5; i++ {
		state = stepLFSR(state)
		fmt.Printf("Estado %d: %08b\n", i+1, state)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li>
<p>Um bit de realimentação é calculado via <code>XOR</code> de dois bits do estado.</p>
</li>
<li>
<p>O estado é deslocado para a direita <code>(&gt;&gt; 1)</code>, descartando o LSB.</p>
</li>
<li>
<p>O novo bit de feedback é colocado na posição mais à esquerda via feedback <code>&lt;&lt; 7</code>.</p>
</li>
</ul>
<p>Embora não exista uma tabela verdade para o deslocamento, segue um exemplo visual do deslocamento:</p>
<div class="table-wrapper"><table><thead><tr><th>Operação</th><th>Entrada</th><th>Resultado</th><th>Observação</th></tr></thead><tbody>
<tr><td><code>x &lt;&lt; 1</code></td><td><span style="color:#ff6666;">0</span>1010010</td><td>1010010<span style="color:#66ccff;">0</span></td><td>Perde o MSB, ganha 0 no LSB</td></tr>
<tr><td><code>x &gt;&gt; 1</code></td><td>0101001<span style="color:#ff6666;">0</span></td><td><span style="color:#66ccff;">0</span>0101001</td><td>Perde o LSB, ganha 0 no MSB</td></tr>
<tr><td><code>x &gt;&gt; 3</code></td><td>111<span style="color:#ff6666;">00000</span></td><td><span style="color:#66ccff;">000</span>11100</td><td>Bits deslizam 3 casas à direita</td></tr>
</tbody></table>
</div>
<p>Esse comportamento é determinístico, barato computacionalmente e essencial para muitas transformações em cifras e PRNGs.</p>
<h2 id="importância-em-criptografia"><a class="header" href="#importância-em-criptografia">Importância em Criptografia</a></h2>
<p>Operadores bitwise são usados constantemente em algoritmos criptográficos. Exemplos:</p>
<ul>
<li>
<p>O <code>XOR</code> (<code>^</code>) é a operação mais usada em cifras de fluxo e blocos — por exemplo, no modo CTR ou no cálculo de paridade.</p>
</li>
<li>
<p>Cifras de fluxo: cada byte da mensagem é combinado com um byte do keystream usando <code>XOR</code>.</p>
</li>
<li>
<p>Funções hash: o <code>XOR</code> é usado para compressão, mistura e difusão de bits internos.</p>
</li>
<li>
<p><code>AND</code>, (<code>&amp;</code>) <code>OR</code> (<code>|</code>), e <code>NOT</code> (<code>~</code>) são usados em compressão de mensagens, máscaras, e manipulação de estruturas internas como as de <strong>SHA-2</strong>.</p>
</li>
<li>
<p>Shifts (<code>&lt;&lt;, &gt;&gt;</code>) implementam rotações e misturas, fundamentais em <strong>S-Boxes</strong> e funções de dispersão.</p>
</li>
</ul>
<h2 id="considerações-1"><a class="header" href="#considerações-1">Considerações</a></h2>
<p>Dominar os operadores bitwise é essencial para compreender o funcionamento interno de muitos algoritmos criptográficos. Além disso, esse tipo de manipulação é eficiente, compacta e amplamente utilizada em implementações de baixo nível, seja em bibliotecas de segurança, protocolos ou microcontroladores.</p>
<p>Nos próximos tópicos, aplicaremos esses conceitos na manipulação de blocos de dados, operações estruturais e transformação binária direta.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operações-em-blocos"><a class="header" href="#operações-em-blocos">Operações em Blocos</a></h1>
<h2 id="o-que-são-modos-de-operação"><a class="header" href="#o-que-são-modos-de-operação">O que são modos de operação?</a></h2>
<p>Muitos algoritmos lidam com blocos de dados de tamanho fixo, como 64 ou 128 bits. Quando a entrada é maior que um único bloco, é necessário dividir os dados e aplicar transformações <strong>bloco a bloco</strong>, seguindo um <strong>modo de operação</strong>.</p>
<p>Embora esses modos sejam usados em contextos criptográficos, o objetivo aqui é entender <strong>como os dados são processados tecnicamente</strong>, sem considerar a lógica de cifra. Vamos nos concentrar em:</p>
<ul>
<li>Como os blocos são encadeados</li>
<li>Qual a dependência entre entradas e saídas</li>
<li>Como o estado interno evolui</li>
<li>Como entrada, saída e IV interagem</li>
</ul>
<p>Para fins ilustrativos, faremos comentários como <code>// aplicar cifra aqui</code>, mas <strong>não implementaremos cifra real nesta seção</strong>.</p>
<h2 id="divisão-em-blocos"><a class="header" href="#divisão-em-blocos">Divisão em blocos</a></h2>
<p>Antes de aplicar qualquer modo de operação, os dados precisam ser divididos em blocos de tamanho fixo. Se os dados não são múltiplo do tamanho do bloco, algum tipo de preenchimento (padding) será necessário. Veremos mais sobre padding em uma seção posterior, em especial quando estivermos falando sobre Base64.</p>
<p>Exemplo com blocos de 8 bytes:</p>
<pre><code>Entrada (24 bytes): "ExemploDeTextoCriptografado"

Blocos:
B1 = "ExemploD"
B2 = "eTextoCr"
B3 = "iptograf"
B4 = "ado\x00\x00\x00" // padding se aplicado
</code></pre>
<p>A seguir, vamos examinar os principais modos de operação: ECB, CBC, CFB, OFB, CTR e outros opcionais.</p>
<h2 id="ecb--electronic-codebook"><a class="header" href="#ecb--electronic-codebook">ECB — Electronic Codebook</a></h2>
<p>O modo ECB é o mais simples de todos: cada bloco de entrada é processado <strong>de forma independente</strong> dos demais. Não há encadeamento, nem dependência de bloco anterior. Por isso, é possível aplicar a transformação a todos os blocos <strong>em paralelo</strong>.</p>
<p>Uma analogia útil é pensar em ECB como um carimbo: para cada pedaço do texto, aplica-se sempre o mesmo molde. Se dois blocos forem iguais, o resultado será o mesmo.</p>
<p>Apesar de sua simplicidade, esse comportamento pode expor padrões quando blocos repetidos resultam em saídas repetidas — por isso o ECB é desaconselhado em aplicações criptográficas. Mas como modelo de operação, é útil para entender a base dos modos.</p>
<h3 id="funcionamento"><a class="header" href="#funcionamento">Funcionamento</a></h3>
<pre><code>Entrada:     B1   B2   B3   B4
             |    |    |    |
             v    v    v    v
Saída:      C1   C2   C3   C4

// Cada Ci = cifra(Bi)
</code></pre>
<h3 id="implementação-simulada-em-go"><a class="header" href="#implementação-simulada-em-go">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func ecb(blocks []string) []string {
	out := make([]string, len(blocks))
	for i, b := range blocks {
		// Simulando uma "cifra" com reverso de string
		out[i] = reverse(b) // aplicar cifra real aqui
	}
	return out
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	saida := ecb(blocos)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Esse código demonstra a ideia de que cada bloco é transformado isoladamente. A função <code>reverse</code> simula uma transformação sem depender de contexto.</p>
<p>Nos próximos modos, veremos como introduzir <strong>estado</strong> e <strong>encadeamento</strong> entre os blocos.</p>
<h2 id="cbc--cipher-block-chaining"><a class="header" href="#cbc--cipher-block-chaining">CBC — Cipher Block Chaining</a></h2>
<p>O modo CBC introduz encadeamento entre os blocos de dados. Aqui, cada bloco de entrada é combinado (via <code>XOR</code>) com o bloco de saída anterior <strong>antes</strong> da transformação ser aplicada. Isso garante que blocos idênticos de entrada não gerem saídas idênticas, desde que a inicialização seja diferente.</p>
<p>O primeiro bloco é combinado com um <strong>vetor de inicialização</strong>  (<em>IV - Initialization Vector</em> ), que deve ser único e imprevisível para cada mensagem.</p>
<p>Pense em CBC como uma corrente: cada elo (bloco) depende do anterior. Se você mudar um elo, o restante da corrente será alterado. Esse encadeamento dá mais segurança estrutural ao fluxo de blocos.</p>
<h3 id="funcionamento-1"><a class="header" href="#funcionamento-1">Funcionamento</a></h3>
<pre><code>Entrada:     B1   B2   B3   B4
              |    |    |    |
IV ---&gt; XOR   |    |    |    |
        v     v    v    v    v
      cifra  XOR  XOR  XOR  ...
        |     |    |    |    |
       C1 -&gt; C2 -&gt; C3 -&gt; C4

// C1 = cifra(B1 ⊕ IV)
// C2 = cifra(B2 ⊕ C1)
// C3 = cifra(B3 ⊕ C2)
// C4 = cifra(B4 ⊕ C3)
</code></pre>
<h3 id="implementação-simulada-em-go-1"><a class="header" href="#implementação-simulada-em-go-1">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func cbc(blocks []string, iv string) []string {
	out := make([]string, len(blocks))
	prev := iv
	for i, b := range blocks {
		mix := xor(b, prev)
		out[i] = reverse(mix) // aplicar cifra real aqui
		prev = out[i]         // saída vira entrada para o próximo XOR
	}
	return out
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678" // mesmo tamanho de bloco
	saida := cbc(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Aqui, usamos uma função <code>xor</code> simples para combinar blocos. A função <code>reverse</code>, como antes, simula a aplicação de uma cifra. O encadeamento é visível no uso da variável <code>prev</code>, que propaga o resultado entre os blocos.</p>
<p>No próximo modo, veremos como esse encadeamento pode ser reorganizado para permitir recuperação de dados em tempo real.</p>
<h1 id="cfb--cipher-feedback"><a class="header" href="#cfb--cipher-feedback">CFB — Cipher Feedback</a></h1>
<p>O modo CFB transforma uma cifra de bloco em um sistema que se comporta como uma cifra de fluxo. Diferente do ECB e CBC, o CFB permite operar em unidades menores que o bloco (como bytes ou bits), o que é útil para aplicações onde os dados não chegam em blocos completos.</p>
<p>Apesar de utilizar uma cifra de bloco internamente, o que realmente é cifrado é o <strong>vetor de realimentação</strong>. Esse vetor é processado com a cifra, e o resultado é combinado (via XOR) com o bloco ou byte de entrada para gerar a saída.</p>
<h3 id="funcionamento-versão-em-blocos-inteiros"><a class="header" href="#funcionamento-versão-em-blocos-inteiros">Funcionamento (versão em blocos inteiros)</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV -----&gt; cifra     |      |      |
           |         |      |      |
           v         v      v      v
          XOR       XOR   XOR   XOR
           |         |      |      |
          C1  ---&gt;  C2 -&gt;  C3 -&gt;  C4

// C1 = P1 ⊕ cifra(IV)
// C2 = P2 ⊕ cifra(C1)
// C3 = P3 ⊕ cifra(C2)
// C4 = P4 ⊕ cifra(C3)
</code></pre>
<p>Diferente do CBC, a cifra é aplicada sobre a saída anterior, não sobre a entrada. Isso permite que a cifra seja usada como um gerador de fluxo pseudoaleatório que é então combinado com os dados reais.</p>
<h3 id="implementação-simulada-em-go-2"><a class="header" href="#implementação-simulada-em-go-2">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func cfb(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	estado := iv
	for i, p := range entrada {
		keystream := reverse(estado) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
		estado = saida[i] // realimentado com saída
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678"
	saida := cfb(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li><code>reverse</code> representa a cifra aplicada sobre o estado interno</li>
<li><code>estado</code> é atualizado com a saída anterior, simulando o feedback</li>
<li><code>xor</code> combina a saída da cifra com o bloco de entrada</li>
</ul>
<p>Nos modos seguintes, veremos como separar o fluxo gerado da entrada original (OFB) e como introduzir contadores (CTR).</p>
<h1 id="ofb--output-feedback"><a class="header" href="#ofb--output-feedback">OFB — Output Feedback</a></h1>
<p>O modo OFB (Output Feedback) é semelhante ao CFB, mas com uma diferença importante: o <strong>vetor de realimentação é atualizado independentemente da entrada</strong>. Isso significa que o fluxo pseudoaleatório gerado pela cifra é completamente dissociado do texto de entrada, permitindo paralelismo na geração e reutilização do keystream.</p>
<p>Na prática, o OFB transforma uma cifra de bloco em uma cifra de fluxo pura, onde o texto de entrada é combinado com uma sequência pseudoaleatória de bits gerados iterativamente a partir do IV.</p>
<h3 id="funcionamento-2"><a class="header" href="#funcionamento-2">Funcionamento</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV -----&gt; cifra ---&gt; cifra ---&gt; cifra ---&gt;
              |       |       |      |
              v       v       v      v
            XOR     XOR     XOR    XOR
              |       |       |      |
             C1      C2      C3     C4

// E1 = cifra(IV)
// E2 = cifra(E1)
// E3 = cifra(E2)
// E4 = cifra(E3)
// Ci = Pi ⊕ Ei
</code></pre>
<p>Como o OFB não depende da entrada anterior, ele é ideal para ambientes em que erros de transmissão não podem propagar corrompendo blocos seguintes.</p>
<h3 id="implementação-simulada-em-go-3"><a class="header" href="#implementação-simulada-em-go-3">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func ofb(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	estado := iv
	for i, p := range entrada {
		keystream := reverse(estado) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
		estado = keystream // fluxo é autônomo
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678"
	saida := ofb(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li>O <code>estado</code> é atualizado <strong>somente pela cifra anterior</strong>, sem depender da entrada</li>
<li>O fluxo gerado é previsível e determinístico para o mesmo IV</li>
</ul>
<p>O modo OFB é adequado para aplicações onde a integridade parcial dos dados deve ser preservada mesmo em caso de erros de transmissão.</p>
<p>No próximo modo, introduziremos um contador para gerar blocos independentes — o modo CTR.</p>
<h1 id="ctr--counter-mode"><a class="header" href="#ctr--counter-mode">CTR — Counter Mode</a></h1>
<p>O modo CTR (Counter) transforma uma cifra de bloco em uma cifra de fluxo por meio da geração de um <strong>keystream determinístico</strong>, baseado em um contador. Ao invés de realimentar saídas anteriores, ele cifra valores sequenciais derivados de um IV (Initialization Vector).</p>
<p>Cada bloco de texto é combinado (via XOR) com a cifra do contador correspondente. Isso permite que cada bloco seja processado <strong>de forma independente</strong>, facilitando a paralelização.</p>
<h3 id="funcionamento-3"><a class="header" href="#funcionamento-3">Funcionamento</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV+0 --&gt; cifra        
         |           |      |      |
         v           v      v      v
        XOR         XOR   XOR    XOR
         |           |      |      |
        C1          C2     C3     C4

// C1 = P1 ⊕ cifra(IV + 0)
// C2 = P2 ⊕ cifra(IV + 1)
// C3 = P3 ⊕ cifra(IV + 2)
// C4 = P4 ⊕ cifra(IV + 3)
</code></pre>
<p>Esse modo é muito utilizado por sua eficiência e por permitir operações em paralelo. Como o contador é previsível, os blocos de keystream podem ser gerados antes mesmo da chegada da mensagem.</p>
<h3 id="implementação-simulada-em-go-4"><a class="header" href="#implementação-simulada-em-go-4">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
	"strconv"
)

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func padCounter(base string, count int) string {
	suffix := fmt.Sprintf("%08d", count)
	return base[:len(base)-len(suffix)] + suffix
}

func ctr(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	for i, p := range entrada {
		counter := padCounter(iv, i)
		keystream := reverse(counter) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "0000000000000000" // deve ter tamanho fixo
	saida := ctr(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Nesta simulação:</p>
<ul>
<li>O contador é representado por um sufixo decimal no <code>IV</code></li>
<li>A função <code>reverse</code> simula a cifra aplicada ao contador</li>
<li>Cada bloco é processado com base em um valor de contador diferente</li>
</ul>
<p>O CTR é amplamente utilizado em prática (por exemplo, em AES-CTR), sendo considerado seguro e eficiente quando o <code>IV</code> não é reutilizado com a mesma chave.</p>
<h1 id="xts--xex-based-tweaked-codebook-mode-with-ciphertext-stealing"><a class="header" href="#xts--xex-based-tweaked-codebook-mode-with-ciphertext-stealing">XTS — XEX-based Tweaked Codebook Mode with Ciphertext Stealing</a></h1>
<p>O modo XTS foi projetado especificamente para cifragem de <strong>unidades de armazenamento em blocos</strong>, como discos e SSDs. Ele combina uma cifra de bloco (como AES) com uma estrutura especial chamada <strong>tweak</strong>, que personaliza a operação para cada setor ou bloco físico, evitando repetições previsíveis.</p>
<p>XTS é um modo baseado em <strong>XEX (XOR-Encrypt-XOR)</strong> com <strong>roubo de texto cifrado (ciphertext stealing)</strong>, permitindo lidar com entradas que não são múltiplas do tamanho do bloco sem recorrer a padding.</p>
<blockquote>
<p>XTS é o modo de operação recomendado por padrões como IEEE P1619 para cifragem de dados em discos.</p>
</blockquote>
<h3 id="estrutura-geral"><a class="header" href="#estrutura-geral">Estrutura geral</a></h3>
<ul>
<li>Usa <strong>duas chaves</strong>: uma para a cifra principal (<code>K1</code>) e outra para o tweak (<code>K2</code>)</li>
<li>Gera um tweak a partir do número de setor ou posição lógica do bloco</li>
<li>Aplica o tweak com XOR antes e depois da cifra (XOR-Encrypt-XOR)</li>
</ul>
<h3 id="funcionamento-simplificado"><a class="header" href="#funcionamento-simplificado">Funcionamento simplificado</a></h3>
<pre><code>Para cada bloco i:

Tweak_i = cifra(K2, bloco_logico) &lt;&lt; i // ajustado por multiplicador

M_i' = P_i ⊕ Tweak_i
C_i' = cifra(K1, M_i')
C_i  = C_i' ⊕ Tweak_i
</code></pre>
<p>Essa construção garante que dois blocos com mesmo conteúdo, mas localização diferente no disco, produzam saídas diferentes. Além disso, XTS suporta entradas que não completam um bloco inteiro usando roubo de bits do bloco seguinte (ciphertext stealing).</p>
<h3 id="simulação-conceitual"><a class="header" href="#simulação-conceitual">Simulação conceitual</a></h3>
<p>Para simplificar, podemos demonstrar apenas a ideia do uso de tweak e da dupla XOR:</p>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func xts(blocks []string, tweakBase string) []string {
	saida := make([]string, len(blocks))
	for i, p := range blocks {
		tweak := genTweak(tweakBase, i)
		m1 := xor(p, tweak)
		cifra := reverse(m1) // cifra principal simulada
		saida[i] = xor(cifra, tweak)
	}
	return saida
}

func genTweak(base string, i int) string {
	b := []byte(base)
	for j := range b {
		b[j] = b[j] ^ byte(i) // mistura simples com índice
	}
	return string(b)
}

func reverse(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; j; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	tweak := "SETORESP"
	saida := xts(blocos, tweak)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<h3 id="características"><a class="header" href="#características">Características</a></h3>
<ul>
<li>Suporta operação paralela</li>
<li>Seguro contra repetições de padrões em setores</li>
<li>Recomendado para cifragem de disco e armazenamento</li>
</ul>
<p>Embora mais complexo que os modos anteriores, o XTS resolve limitações práticas importantes na cifragem de dispositivos reais.</p>
<p>Com isso, encerramos os principais modos de operação. A seguir, faremos uma comparação entre eles, destacando características técnicas e aplicações ideais.</p>
<h1 id="comparação-entre-modos-de-operação"><a class="header" href="#comparação-entre-modos-de-operação">Comparação entre Modos de Operação</a></h1>
<p>A análise técnica dos modos de operação não deve ser feita apenas com base em características isoladas, mas também considerando seu contexto histórico e a motivação por trás de cada proposta. A seguir, apresentamos uma visão evolutiva e comparativa entre os modos ECB, CBC, CFB, OFB, CTR e XTS.</p>
<h2 id="evolução-histórica-e-motivação"><a class="header" href="#evolução-histórica-e-motivação">Evolução histórica e motivação</a></h2>
<p>O primeiro modo amplamente utilizado foi o <strong>ECB (Electronic Codebook)</strong>. Seu funcionamento direto e paralelizável o tornava atraente, mas rapidamente ficou claro que ele era <strong>inadequado para dados estruturados</strong>: blocos iguais produziam saídas idênticas, expondo padrões — o que compromete completamente a segurança.</p>
<p>Para contornar esse problema, surgiu o <strong>CBC (Cipher Block Chaining)</strong>. Ele introduziu <strong>encadeamento entre os blocos</strong>: cada bloco depende do anterior. Isso impede que blocos idênticos de entrada produzam saídas idênticas, mesmo com a mesma chave. Contudo, essa segurança adicional vem ao custo da <strong>impossibilidade de paralelismo na cifragem</strong> — já que é preciso aguardar o resultado do bloco anterior.</p>
<p>O modo <strong>CFB (Cipher Feedback)</strong> foi criado como alternativa ao CBC para contextos de <strong>transmissão de dados em tempo real</strong>, permitindo cifragem de <strong>tamanhos menores que o bloco</strong> (como bytes ou bits). Seu encadeamento ocorre via saída anterior, o que o torna seguro, mas ainda dependente do processamento sequencial.</p>
<p>Já o <strong>OFB (Output Feedback)</strong> nasce como uma variação do CFB, buscando resolver a propagação de erros: ao invés de realimentar com a saída cifrada, o OFB <strong>gera um fluxo independente da entrada</strong>, tornando o sistema mais tolerante a falhas e adequado para ambientes ruidosos (como transmissões digitais).</p>
<p>O modo <strong>CTR (Counter Mode)</strong> representa uma mudança significativa: elimina o encadeamento e adota um <strong>contador como fonte de entropia</strong>. Cada bloco da entrada é combinado com a cifra do contador correspondente. Com isso, torna-se <strong>totalmente paralelizável</strong>, ideal para ambientes de alto desempenho, redes e sistemas distribuídos. A cifragem pode inclusive ser precomputada, desde que o contador e a chave sejam fixos.</p>
<p>Por fim, o modo <strong>XTS</strong> surge para atender <strong>um problema prático não resolvido por nenhum dos anteriores</strong>: a cifragem segura de blocos físicos em discos. Ele se baseia em XEX (XOR-Encrypt-XOR), utiliza dois conjuntos de chaves, gera um tweak exclusivo por posição e ainda lida com blocos incompletos sem padding (via ciphertext stealing). XTS é, portanto, uma construção especializada, recomendada por padrões como o IEEE P1619.</p>
<h2 id="relações-e-compensações"><a class="header" href="#relações-e-compensações">Relações e compensações</a></h2>
<p>Cada modo surgiu como resposta a uma limitação do anterior:</p>
<ul>
<li><strong>CBC</strong> corrige a repetição de padrões do <strong>ECB</strong>.</li>
<li><strong>CFB</strong> adapta o CBC para trabalhar em unidades menores.</li>
<li><strong>OFB</strong> remove a propagação de erros do CFB.</li>
<li><strong>CTR</strong> substitui todos os anteriores quando o foco é paralelismo e desempenho.</li>
<li><strong>XTS</strong> trata o caso específico de cifragem de setores físicos.</li>
</ul>
<p>É importante compreender essas relações para fazer escolhas adequadas em projetos reais. Modos de operação não são equivalentes: cada um atende a um cenário específico de uso e impõe restrições distintas.</p>
<p>Na próxima seção, faremos considerações finais sobre segurança, desempenho e práticas recomendadas.</p>
<h1 id="considerações-finais-sobre-modos-de-operação"><a class="header" href="#considerações-finais-sobre-modos-de-operação">Considerações Finais sobre Modos de Operação</a></h1>
<p>Os modos de operação analisados neste capítulo evidenciam como decisões de projeto em criptografia envolvem trocas entre <strong>segurança</strong>, <strong>eficiência</strong>, <strong>flexibilidade</strong> e <strong>resiliência a falhas</strong>. Nenhum modo é universalmente superior: cada um resolve um subconjunto de problemas e impõe restrições específicas.</p>
<p>O objetivo deste capítulo foi <strong>isolar os modos de operação</strong>, apresentando suas características técnicas e funcionais de forma independente de algoritmos específicos. A relação com cifras reais (como AES ou ChaCha20), bem como as <strong>implicações práticas de segurança</strong> na escolha do modo, serão retomadas e aprofundadas em seções posteriores do livro.</p>
<h2 id="sobre-segurança"><a class="header" href="#sobre-segurança">Sobre segurança</a></h2>
<ul>
<li><strong>ECB</strong> deve ser evitado em qualquer situação onde haja estrutura ou repetição nos dados. Seu uso é restrito a testes ou casos didáticos.</li>
<li><strong>CBC</strong>, <strong>CFB</strong> e <strong>OFB</strong> oferecem segurança razoável quando combinados com IVs aleatórios e não reutilizados.</li>
<li><strong>CTR</strong> e <strong>XTS</strong> são considerados seguros e modernos, desde que o <strong>contador ou tweak não se repita</strong> com a mesma chave.</li>
</ul>
<h2 id="sobre-desempenho-e-paralelismo"><a class="header" href="#sobre-desempenho-e-paralelismo">Sobre desempenho e paralelismo</a></h2>
<ul>
<li><strong>CTR</strong> e <strong>XTS</strong> são os únicos modos que permitem paralelismo total na cifra e decifra.</li>
<li><strong>ECB</strong> também é paralelizável, mas inseguro.</li>
<li><strong>CBC</strong>, <strong>CFB</strong> e <strong>OFB</strong> são sequenciais na cifra e, portanto, menos eficientes para grandes volumes de dados ou ambientes concorrentes.</li>
</ul>
<h2 id="sobre-robustez"><a class="header" href="#sobre-robustez">Sobre robustez</a></h2>
<ul>
<li><strong>OFB</strong> e <strong>CTR</strong> não propagam erros em cadeia, tornando-os ideais para canais com ruído.</li>
<li><strong>CBC</strong> e <strong>CFB</strong> propagam erros de forma localizada, e podem corromper blocos subsequentes na decifra.</li>
</ul>
<h2 id="escolha-prática"><a class="header" href="#escolha-prática">Escolha prática</a></h2>
<p>A escolha do modo de operação deve considerar:</p>
<ul>
<li>A natureza dos dados (texto, fluxo, armazenamento físico)</li>
<li>A sensibilidade a erros de transmissão</li>
<li>A necessidade de desempenho e paralelismo</li>
<li>As garantias de segurança esperadas</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Caso de uso</th><th>Modo recomendado</th></tr></thead><tbody>
<tr><td>Criptografia de disco</td><td>XTS</td></tr>
<tr><td>Comunicação em tempo real</td><td>CFB ou OFB</td></tr>
<tr><td>Alta performance em redes</td><td>CTR</td></tr>
<tr><td>Arquivos e backups</td><td>CBC</td></tr>
</tbody></table>
</div>
<p>Em todos os casos, o uso de <strong>vetores de inicialização (IVs)</strong> únicos e imprevisíveis é essencial para garantir a segurança dos modos baseados em encadeamento ou contadores.</p>
<p>Com isso, concluímos a análise dos modos de operação. As próximas seções tratarão da implementação de cifras reais e da integração com essas estruturas de controle de fluxo.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="confusão-e-difusão"><a class="header" href="#confusão-e-difusão">Confusão e Difusão</a></h1>
<p>As propriedades de <strong>confusão</strong> e <strong>difusão</strong> são dois princípios fundamentais estabelecidos por Shannon [1], constituindo pilares da segurança em sistemas criptográficos modernos. Esses conceitos têm como objetivo maximizar a incerteza e a dispersão das relações estatísticas entre a mensagem não cifrada e a mensagem cifrada, dificultando ataques baseados em análise de frequência ou estrutura.</p>
<h2 id="definições-formais"><a class="header" href="#definições-formais">Definições formais</a></h2>
<p><strong>Confusão</strong>: o objetivo é tornar complexa a relação entre a chave de encriptação e o texto cifrado. De acordo com Shannon, "o sistema deve ser projetado de modo que cada bit da chave afete, de forma imprevisível, muitos bits da saída". Confusão impede que um atacante deduza partes da chave mesmo conhecendo partes do texto cifrado.</p>
<p><strong>Difusão</strong>: refere-se à dispersão estatística do conteúdo da mensagem não cifrada ao longo da mensagem cifrada. Ou seja, um pequeno número de bits alterados na entrada deve afetar um grande número de bits na saída. A difusão elimina padrões e distribui redundâncias da mensagem original.</p>
<p>Esse comportamento, em que pequenas alterações na entrada produzem grandes alterações na saída, é conhecido como <strong>efeito avalanche</strong>, e é resultado da aplicação combinada de confusão e difusão.</p>
<p>Essas duas propriedades são frequentemente implementadas em cifras modernas por meio de redes de substituição e permutação redes de substituição e permutação (Substitution-Permutation Networks), conforme discutido por Donald Knuth em <em>The Art of Computer Programming</em> [5], onde destaca a importância da aleatoriedade controlada na construção de algoritmos seguros.</p>
<h2 id="exemplo-prático-simulações-de-confusão-e-difusão-em-go"><a class="header" href="#exemplo-prático-simulações-de-confusão-e-difusão-em-go">Exemplo Prático: Simulações de Confusão e Difusão em Go</a></h2>
<p>Para isolar os conceitos, não implementamos uma cifra completa, mas sim funções que exemplificam mecanicamente confusão (via substituições não lineares com chave) e difusão (via permutações e operações de dispersão simples).</p>
<p>A estrutura será:</p>
<ul>
<li>
<p>Confusão: uso de uma substituição baseada em chave (S-Box parametrizada).</p>
</li>
<li>
<p>Difusão: uso de permutação fixa e dispersão via operações XOR.</p>
</li>
</ul>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"fmt"
)

// Gera uma S-Box pseudoaleatória baseada em uma chave
func generateSBox(key []byte) [256]byte {
	var sbox [256]byte
	hash := sha256.Sum256(key)
	seed := uint32(0)
	for i := 0; i &lt; 4; i++ {
		seed ^= uint32(hash[i]) &lt;&lt; (8 * i)
	}
	for i := range sbox {
		sbox[i] = byte((i*int(seed) + 31) % 256)
	}
	return sbox
}

// Confusão: aplica substituição não linear via S-Box
func confusion(input []byte, sbox [256]byte) []byte {
	out := make([]byte, len(input))
	for i, b := range input {
		out[i] = sbox[b]
	}
	return out
}

// Difusão: permutação e dispersão via XOR entre posições
func diffusion(input []byte) []byte {
	out := make([]byte, len(input))
	for i := range input {
		out[i] = input[i]
		if i &gt; 0 {
			out[i] ^= input[i-1]
		}
	}
	return out
}

func main() {
	key := []byte("chave-secreta")
	entrada := []byte("mensagem123456")

	sbox := generateSBox(key)
	c := confusion(entrada, sbox)
	d := diffusion(c)

	fmt.Printf("Original : %x\n", entrada)
	fmt.Printf("Confusão : %x\n", c)
	fmt.Printf("Difusão  : %x\n", d)
}

</code></pre>
<p>Análise do código:</p>
<p>Observe que:</p>
<ul>
<li>
<p>A função generateSBox cria uma tabela de substituição (S-Box) que introduz confusão, pois depende da chave de entrada.</p>
</li>
<li>
<p>A função diffusion implementa uma difusão simples, propagando a influência de cada byte anterior sobre o próximo com XOR.</p>
</li>
</ul>
<h2 id="considerações-finais"><a class="header" href="#considerações-finais">Considerações Finais</a></h2>
<p>A aplicação isolada de confusão e difusão permite o estudo modular de suas propriedades, sem a complexidade adicional de um esquema criptográfico completo. Shannon já antecipava que a combinação adequada dessas técnicas seria suficiente para criar sistemas resistentes à análise estatística.</p>
<p>Knuth, por sua vez, destacou que a boa aleatorização estruturada é o centro da segurança criptográfica — e que difusão e confusão são ferramentas matemáticas precisamente voltadas a esse objetivo.</p>
<p>O leitor é convidado a explorar esses conceitos com maior profundidade consultando a referência [1] e [5].</p>
<h2 id="referências"><a class="header" href="#referências">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-boxes-substituições-não-lineares"><a class="header" href="#s-boxes-substituições-não-lineares">S-Boxes: Substituições Não Lineares</a></h1>
<p>As S-Boxes (Substitution Boxes) são funções fundamentais em cifras simétricas modernas. Elas realizam substituições não lineares, introduzindo confusão no sistema criptográfico, conforme definido por Shannon [1]. Em redes de substituição-permutação (SPN) e cifras de Feistel, as S-Boxes são os principais elementos responsáveis por tornar complexa a relação entre a chave e o texto cifrado.</p>
<h2 id="definição-formal"><a class="header" href="#definição-formal">Definição Formal</a></h2>
<p>Uma S-Box é uma função</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></p>
<p>que mapeia uma entrada binária de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits para uma saída de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> bits. Quando <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, a S-Box é dita bijetiva (ou uma permutação) se cada saída for única.</p>
<p>Exemplo típico:</p>
<ul>
<li>No AES, a S-Box é uma permutação de 8 bits para 8 bits, isto é, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<p>Propriedades desejáveis:</p>
<ul>
<li>
<p>Não-linearidade alta (distância de Hamming em relação a todas funções lineares).</p>
</li>
<li>
<p>Avalanche: uma mudança de 1 bit na entrada afeta múltiplos bits da saída.</p>
</li>
<li>
<p>Resistência a diferenciais e lineares: saída deve ser estatisticamente imprevisível sob diferenças ou aproximações lineares na entrada.</p>
</li>
</ul>
<p>Métodos de construção:</p>
<p>A criação de S-Boxes pode ser feita de diferenes maneiras, dependendo do contexto e objetivos de segurança:</p>
<ol>
<li>Baseadas em estruturas algébricas</li>
</ol>
<ul>
<li>AES (Rijndael) utiliza a inversa multiplicativa no corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8665em;vertical-align:-0.1776em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5224em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1776em;"><span></span></span></span></span></span></span></span></span></span>, seguida de uma transformação afim:
<ul>
<li>Inverso: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> (com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6554em;vertical-align:-0.011em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</li>
<li>Transformação afim: multiplicação e soma sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p>Essa construção é baseada no padrão FIPS 197 [2]. e foi escolhida por sua alta não-linearidade e resistência a ataques diferenciais.</p>
<ol start="2">
<li>Baseadas em constantes (look-up fixo)</li>
</ol>
<ul>
<li>
<p>MD2 define uma S-Box de 256 bytes fixos, supostamente derivada dos dígitos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. A origem exata nunca foi publicada por Rivest, mas acredita-se que a sequência tenha sido escolhida de forma a evitar padrões evidentes [3].</p>
</li>
<li>
<p>DES usa oito S-Boxes diferentes com mapeamentos de 6 bits para 4 bits, cuidadosamente projetadas para resistir a criptoanálise diferencial (ver Coppersmith [4]).</p>
</li>
</ul>
<ol start="3">
<li>Pseudoaleatórias derivadas de chave</li>
</ol>
<ul>
<li>Em cifras modernas como Blowfish, a S-Box é preenchida dinamicamente durante a expansão da chave. Isso dificulta análise e torna a estrutura dependente da chave secreta.</li>
</ul>
<h2 id="exemplo-prático-em-go-construindo-uma-s-box-simples"><a class="header" href="#exemplo-prático-em-go-construindo-uma-s-box-simples">Exemplo prático em Go: Construindo uma S-Box simples</a></h2>
<p>Aqui, mostramos duas formas distintas de definir S-Boxes em Go:</p>
<ol>
<li>AES-like (algébrica) - inverso multiplicativo seguido de transformação afim (simplificada).</li>
<li>MD2-like (constante fixa) - look-up fixo.</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"math/bits"
)

// Exemplo simplificado de S-Box: inverso em GF(2^8) + afim (AES-like simplificada)
func simpleAffineSBox() [256]byte {
	var sbox [256]byte
	for i := 0; i &lt; 256; i++ {
		inv := inverseByte(byte(i))
		sbox[i] = inv ^ bits.RotateLeft8(inv, 1) ^ 0x63 // afim simplificada
	}
	return sbox
}

// Inverso multiplicativo em GF(2^8) com polinômio redutor x^8 + x^4 + x^3 + x + 1
func inverseByte(x byte) byte {
	if x == 0 {
		return 0
	}
	var inv byte = 1
	for i := 1; i &lt; 256; i++ {
		if byteMultiply(x, inv) == 1 {
			return inv
		}
		inv++
	}
	return 0
}

// Multiplicação em GF(2^8)
func byteMultiply(a, b byte) byte {
	var p byte = 0
	for b != 0 {
		if b&amp;1 != 0 {
			p ^= a
		}
		hi := a &amp; 0x80
		a &lt;&lt;= 1
		if hi != 0 {
			a ^= 0x1B // AES irreducible polynomial
		}
		b &gt;&gt;= 1
	}
	return p
}

// Exemplo de S-Box constante (MD2-like)
func md2SBox() [256]byte {
	return [256]byte{
		0x29, 0x2E, 0x43, 0x32, 0x8B, 0x1C, 0x1A, 0x06, 0x3F, 0x3C, 0x7F, 0x8A, 0x0E, 0x19, 0x4F, 0x43,
		// ... complete até 256 valores reais conforme tabela do MD2
	}
}

func main() {
	sbox := simpleAffineSBox()
	fmt.Printf("Exemplo de S-Box (simplificada):\n")
	for i := 0; i &lt; 16; i++ {
		fmt.Printf("%02x ", sbox[i])
	}
	fmt.Println()
}
</code></pre>
<h2 id="considerações-finais-1"><a class="header" href="#considerações-finais-1">Considerações finais</a></h2>
<p>As S-Boxes são blocos fundamentais na construção de cifras seguras. Sua estrutura influencia diretamente a resistência contra ataques diferenciais, lineares e por análise estatística. S-Boxes bem projetadas devem apresentar não-linearidade elevada e boa dispersão da entrada na saída, contribuindo para o efeito avalanche.</p>
<p>Embora possam ser fixas ou derivadas de chave, é essencial que sejam analisadas formalmente quanto às suas propriedades de segurança — algo que o projeto do AES exemplifica de forma rigorosa. Em contrapartida, designs mais antigos, como MD2, revelam escolhas empíricas, ainda que eficazes em seu tempo.</p>
<h2 id="referências-1"><a class="header" href="#referências-1">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[2] National Institute of Standards and Technology, FIPS-197: Advanced Encryption Standard (AES), 2001.</p>
<p>[3] R. Rivest, The MD2 Message-Digest Algorithm, RFC 1319, 1992.</p>
<p>[4] D. Coppersmith, The Data Encryption Standard (DES) and Its Strength Against Attacks, IBM Journal of Research and Development, 1994.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Vol. 2, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="permutações-e-trocas"><a class="header" href="#permutações-e-trocas">Permutações e Trocas</a></h1>
<p>Em cifras simétricas, a dispersão de dependências locais — fundamental para a difusão — pode ser alcançada por meio de operações lineares, como multiplicações matriciais, ou estruturais, como permutações e trocas de posição. Este tipo de transformação reorganiza os dados sem alterar seu conteúdo individual, mas com profundo impacto estatístico na propagação de alterações pela estrutura do algoritmo.</p>
<h2 id="permutações-como-mecanismo-de-difusão"><a class="header" href="#permutações-como-mecanismo-de-difusão">Permutações como mecanismo de difusão</a></h2>
<p>Uma permutação é uma bijeção sobre o conjunto de posições de bits ou bytes. Aplicada a um vetor de entrada, ela redistribui os elementos segundo uma ordem fixa ou pseudoaleatória. Embora não introduza não-linearidade, a permutação é essencial para ampliar o alcance das alterações provocadas pelas S-Boxes ou outras funções não lineares.</p>
<p>Na arquitetura de cifras modernas, as permutações são utilizadas para:</p>
<ul>
<li>
<p>Propagar a influência de bits da entrada por várias S-Boxes na rodada seguinte.</p>
</li>
<li>
<p>Impedir que padrões locais na entrada gerem padrões locais na saída.</p>
</li>
<li>
<p>Compor difusão com custo computacional baixo.</p>
</li>
</ul>
<h2 id="exemplo-em-spns"><a class="header" href="#exemplo-em-spns">Exemplo em SPNs</a></h2>
<p>No AES (FIPS-197), duas camadas implementam difusão com base em permutação:</p>
<ul>
<li><strong>ShiftRows</strong>: uma permutação de bytes por rotação de linhas.</li>
<li><strong>MixColumns</strong>: uma multiplicação linear que atua em colunas, mas combinada com ShiftRows produz difusão bidimensional.</li>
</ul>
<p>Essas operações não introduzem confusão, mas são vitais para garantir o efeito avalanche ao longo das rodadas.</p>
<h2 id="exemplo-em-feistel"><a class="header" href="#exemplo-em-feistel">Exemplo em Feistel</a></h2>
<p>Na estrutura de Feistel, usada no DES e em muitas cifras derivadas, a difusão é construída ao longo das rodadas, intercalando trocas de metades do bloco com aplicações de funções não lineares (geralmente baseadas em S-Boxes).</p>
<p>Permutações também aparecem de forma explícita:</p>
<ul>
<li>
<p>Initial Permutation (IP) e Final Permutation (FP) no DES são mapeamentos fixos de 64 bits, historicamente motivados por eficiência em hardware, mas com efeito colateral de difusão inicial e final.</p>
</li>
<li>
<p>Permutação P após a aplicação das S-Boxes na função F do DES serve para espalhar os resultados locais das substituições.</p>
</li>
</ul>
<h2 id="implementação-ilustrativa-em-go"><a class="header" href="#implementação-ilustrativa-em-go">Implementação ilustrativa em Go</a></h2>
<p>Abaixo, um exemplo de permutação simples de bytes em um vetor de 16 posições:</p>
<pre><code class="language-go">package main

import "fmt"

// Permutação fixa (exemplo artificial)
var permutation = [16]int{2, 0, 3, 1, 6, 4, 7, 5, 10, 8, 11, 9, 14, 12, 15, 13}

func permute(input []byte, p [16]int) []byte {
	out := make([]byte, len(input))
	for i := range p {
		out[i] = input[p[i]]
	}
	return out
}

func main() {
	entrada := []byte("abcdefghijklmnop")
	saida := permute(entrada, permutation)
	fmt.Printf("Original : %s\n", entrada)
	fmt.Printf("Permutada: %s\n", saida)
}
</code></pre>
<p>Esse tipo de permutação, apesar de simples, é o mecanismo base por trás de transformações como ShiftRows. A escolha da ordem é crítica: ela deve maximizar a dispersão estatística sem introduzir simetrias.</p>
<h2 id="considerações-finais-2"><a class="header" href="#considerações-finais-2">Considerações Finais</a></h2>
<p>Permutações e trocas estruturadas são ferramentas indispensáveis na construção de cifras robustas. Embora não introduzam entropia ou não-linearidade, são essenciais para distribuir os efeitos locais das S-Boxes e garantir que os princípios de difusão definidos por Shannon sejam plenamente realizados.</p>
<p>Além disso, entender como essas operações interagem com as camadas de substituição permite projetar SPNs eficientes e compreender como redes de Feistel obtêm segurança mesmo com funções internas relativamente simples.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  th, td {
    border: 1px solid black;
    text-align: center;
    padding: 8px;
  }
</style>
<p>Como funciona uma codificação? Imagine que você tem uma regra que diz o seguinte: caso a entrada for 'a', então o valor será 97, caso a entrada for 'b', então o valor será 98, caso for 'c', então o valor será 99, e assim em diante. Isso é um de-para e é também conhecido como tabela ASCII e envolve outros caracteres além do alfabeto. Descrevi um tipo de codificação.</p>
<p>Base64 é uma regra de codificação (Encode) que aplicamos na entrada produzindo uma saída. Isso significa que podemos lêr a entrada em base64 e produzir uma saída decodificada ou ler uma entrada decodificada e codificar em base64, respectivamente conhecidos como Encode e Decode.</p>
<p>A diferença em relação a tabela ASCII, é que a entrada pode ser qualquer coisa e não se limita apenas a caracteres individuais. No caso do Base64, a codificação funciona agrupando a entrada em blocos de 3 bytes (24 bits) e dividindo-os em 4 grupos de 6 bits. Cada um desses grupos de 6 bits é então convertido para um caractere correspondente em uma tabela de 64 símbolos. Essa table inclui as letras maiúsculas e minúsculas do alfabeto, seguido pelos números de 0 a 9 e então por dois caracteres especiais (+ e / no Base64 padrão e _ e - no Base64URL). Quando a entrada não é um múltiplo exato de 3 bytes, a codificação adiciona um caractere de preenchimento (=) para manter a consistência.</p>
<p>No Base64, a conversão ocorre em blocos e garante que qualquer sequência de bytes possam ser representadas apenas com caracteres seguros para transporte em protocolos como e-mails (MIME), URLs e JSON. Isso torna o Base64 útil para codificar binários, imagens, chaves criptográficas e outros dados que não são diretamente representáveis como texto legível.</p>
<p>O processo inverso, conhecido como decodificação (Decode), pega uma string codificada em Base64 e reconstrói os bytes originais, revertendo a conversão de 6 bits para 8 bits e removendo qualquer padding (=) que tenha sido adicionado na codificação. Assim como podemos converter a → 97 na tabela ASCII e depois reverter 97 → a, no Base64 podemos pegar "TWFu" e recuperar "Man" ou vice-versa, a partir de "Man" obter "TWFu".</p>
<p>No entanto, é importante lembrar que Base64 não é uma criptografia, pois qualquer pessoa pode decodificá-lo facilmente. Ele é apenas um método de representação de dados que facilita o transporte e armazenamento em sistemas que não suportam caracteres binários diretamente. Nota, o Base64 aumenta o tamanho dos dados em 33% em relação ao original.</p>
<h2 id="como-funciona-na-prática"><a class="header" href="#como-funciona-na-prática">Como funciona na prática?</a></h2>
<p>Vamos supor que a entrada sera a string "Rox". Cada caractere em um computador é representado por um número inteiro conforme a tabela ASCII.</p>
<h3 id="passo-1-obter-os-valores-ascii"><a class="header" href="#passo-1-obter-os-valores-ascii">Passo 1: Obter os valores ASCII</a></h3>
<p>Primeiro, vamos converter os caracteres em seus valores numéricos:</p>
<ul>
<li>R → 82</li>
<li>o → 111</li>
<li>x → 120</li>
</ul>
<p>Agora, precisamos representar esses números em binário (base 2), pois a codificação Base64 trabalha diretamente com bits:</p>
<h3 id="passo-2-converter-os-valores-ascii-para-binário-8-bits-cada"><a class="header" href="#passo-2-converter-os-valores-ascii-para-binário-8-bits-cada">Passo 2: Converter os valores ASCII para binário (8 bits cada)</a></h3>
<ul>
<li>R (82) → 01010010</li>
<li>o (111) → 01101111</li>
<li>x (120) → 01111000</li>
</ul>
<p>Agora temos um total de 3 bytes (24 bits), que são agrupados assim:</p>
<p>01010010 01101111 01111000</p>
<h3 id="passo-3-dividir-em-blocos-de-6-bits"><a class="header" href="#passo-3-dividir-em-blocos-de-6-bits">Passo 3: Dividir em blocos de 6 bits</a></h3>
<p>O Base64 trabalha com grupos de 6 bits, então precisamos separar nossos 24 bits assim:</p>
<p>010100 100110 111101 111000</p>
<p>Agora, cada grupo de 6 bits será convertido em um decimal cujo qual representa um índice na tabela Base64.</p>
<h3 id="passo-4-converter-os-grupos-de-6-bits-para-decimal"><a class="header" href="#passo-4-converter-os-grupos-de-6-bits-para-decimal">Passo 4: Converter os grupos de 6 bits para decimal</a></h3>
<ul>
<li>010100 → 20</li>
<li>100110 → 38</li>
<li>111101 → 61</li>
<li>111000 → 56</li>
</ul>
<p>Agora, usamos a tabela Base64 para converter esses números em caracteres.</p>
<h3 id="passo-5-mapear-os-valores-na-tabela-base64"><a class="header" href="#passo-5-mapear-os-valores-na-tabela-base64">Passo 5: Mapear os valores na tabela Base64</a></h3>
<p>A tabela Base64 contém 64 caracteres indexados de 0 até 63. Essa tabela segue uma ordem específica:</p>
<ol>
<li>Letras maiúsculas (A-Z) → índices 0 a 25</li>
<li>Letras minúsculas (a-z) → índices 26 a 51</li>
<li>Números (0-9) → índices 52 a 61</li>
<li>Caracteres especiais (+ e /) → índices 62 e 63</li>
</ol>
<p>Representação em Go:</p>
<pre><code class="language-go">const base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
</code></pre>
<p>Agora, usamos essa tabela para mapear os valores 20, 38, 61 e 56:</p>
<ul>
<li>base64Table[20] → "U"</li>
<li>base64Table[38] → "m"</li>
<li>base64Table[61] → "9"</li>
<li>base64Table[56] → "4"</li>
</ul>
<p>Com isso, o texto "Rox" foi convertido para Base64 como "Um94"</p>
<h3 id="resumo"><a class="header" href="#resumo">Resumo</a></h3>
<p>1 - Convertemos os caracteres para seus valores ASCII (R = 82, o = 111, x = 120).</p>
<p>2 - Transformamos esses valores em binário (01010010 01101111 01111000).</p>
<p>3 - Dividimos em blocos de 6 bits (010100 100110 111101 111000).</p>
<p>4 - Convertemos cada grupo de 6 bits em um número decimal (20, 38, 61, 56).</p>
<p>5 - Mapeamos esses números na tabela Base64, resultando na string "Um94".</p>
<p>Bem tranquilo, certo?</p>
<h2 id="implementação-em-go-1"><a class="header" href="#implementação-em-go-1">Implementação em Go</a></h2>
<p>O maior desafio que teremos é agrupar os bits em grupos de 6 bits, pois normalmente estamos trabalhando com 8 bits (1 byte). Isso implica que, a cada 3 bytes (24 bits no total), teremos 4 grupos de 6 bits, pois 24 / 6 = 4.</p>
<hr />
<summary>Extra: Entendendo o bitwise AND
<details>
<br>
<p>Se tivermos um valor binário qualquer e aplicarmos uma máscara bit a bit (bitwise AND) com 0b111111 (0x3F em hexadecimal), conseguimos extrair exatamente 6 bits da posição desejada.</p>
<p>Isso funciona porque o operador AND (&), mantém apenas os bits onde há 1 nos dois operadores, então podemos isolar porções específicas de um número maior.</p>
<h4 id="exemplo-prático"><a class="header" href="#exemplo-prático">Exemplo prático:</a></h4>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)
</code></pre>
<p>Note que AND tem o poder de desligar o bit ou mantê-lo sem modificação.</p>
<table border="1">
  <tr>
    <th>A</th>
    <th>AND</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>
<br>
<p>Ou seja:</p>
<ul>
<li>Se você aplicar a máscara b00000000, vai apagar tudo</li>
<li>Se você aplicar a máscara b00000001 vai apagar tudo e, para o primeiro bit, vai depender se o outro valor tem 1 ou 0: se tiver 1, ele será mantido, se tiver 0, ele apaga.</li>
</ul>
<p>Outro exemplo: pegar apenas os bits 3 e 4 de um byte qualquer</p>
<pre>
BYTE qualquer:            <span style="color:#ffcc00;">01010010</span>  (82 em decimal)
Máscara de 6 bits:        <span style="color:#00ccff;">00111111</span>  (0x3F em hexadecimal)
Resultado após AND:       <span style="color:#ff6666;">00010010</span>  (18 em decimal)
</pre>
</details>
</summary>
<hr />
<p>Podemos trabalhar diretamente com 3 bytes em um inteiro e percorrer a mensagem de entrada de 3 em 3 bytes e para cada passagem jogar os 3 bytes no inteiro e extrair os valores usando máscara de bits.</p>
<pre><code class="language-go">for i := 0; i &lt; len(input); i += 6 {
    
    blk := int32(in[i    ]) &lt;&lt; 16 | 
           int32(in[i + 1]) &lt;&lt; 8  | 
           int32(in[i + 2])

    out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)

}
</code></pre>
<hr />
<summary>Extra: Explicação do código
<details>
<br>
<p>O que foi feito?</p>
<br>
<p>Criamos um inteiro de 32 bits (int32) e jogamos os 3 bytes do input em cima dele. Para o primeiro byte (na posição i) jogamos para a esquerda 16 bits, para o segundo byte (na posição i + 1) jogamos para a esquerda 8 bits e para o terceiro byte (na posição i + 2) não precisamos jogar nada para a esquerda.</p>
<p>
Imagine que são caixas que cabem 1 byte, o inteiro possui 4 dessas caixas, então precisamos jogar o primeiro byte para a esquerda 16 bits para que ele ocupe a terceira posição, o segundo byte para a esquerda 8 bits e o terceiro byte não precisamos jogar nada para a esquerda porque vai começar no bit 0. Graficamente temos isso:</p>
<pre>
Byte i + 0 = <span style="color:#ff6666;">01101111</span>  (111 em decimal)
Byte i + 1 = <span style="color:#00ccff;">01111000</span>  (120 em decimal)
Byte i + 2 = <span style="color:#ffcc00;">01010010</span>  (82 em decimal) <br>
blk = <span style="color:lightblue"> 000000000 00000000 00000000 00000000</span><br>
Primeiro byte entra começando no bit 16
blk = <span style="color:lightblue"> 000000000<span style="color:#ffcc00;">01010010</span>00000000 00000000</span><br>
Segundo byte entra começando no bit 8
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span>00000000</span><br>
Terceiro byte entra começando no bit 0
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Vamos em câmera lenta. Suponha que</p>
<pre>
in[i    ] = b10000000
in[i + 1] = b00000001
in[i + 2] = b00010000
</pre>
<pre><code class="language-go">blk := int32(in[i    ]) &lt;&lt; 16  // blk = 00000000_10000000_00000000_00000000
blk  |= int32(in[i + 1]) &lt;&lt; 8  // blk = 00000000_10000000_00000001_00000000
blk |= int32(in[i + 2])        // blk = 00000000_10000000_00000001_00010000
</code></pre>
<p>Ou seja, ligou o bit 32 vindo do primeiro byte (ele já estava na posição 8, deslocou 16), o bit 8 do segundo byte (estava na posição 0 e deslocou 8) e o bit 5 (estava na posição 5 do terceiro byte e não teve deslocamento).</p>
<p>Sei que vocẽ já entendeu, mas cabe lembrar que OR funciona da seguinte forma, você tem um valor qualquer com alguns bits ligados e outros não, quando você aplica o OR com outro valor, o que já existe no seu continua, o que não existe no seu, mas existe no outro cara, ele passa a existir no seu. P.ex.: o seu é b00010000 o outro cara é b00000001 agora o seu será b00010001. Veja a tabela do OR para refrescar a memória:</p>
<table border="1">
  <tr>
  <th>A</th>
  <th>OR</th>
  <th>B</th>
  <th>C</th>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>1</td>
  <td>1</td>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>0</td>
  <td>1</td>
  </tr>
  <tr>
  <td>0</td>
  <td>OR</td>
  <td>0</td>
  <td>0</td>
  </tr>
</table>
<br>
<p>Agora que temos os 3 bytes dentro de um único inteiro de 32 bits (blk), precisamos extrair 4 grupos de 6 bits, pois cada caractere Base64 é representado por exatamente 6 bits.</p>
<p>A extração é feita aplicando deslocamento de bits (>>) e uma máscara (& 0b00111111), que serve para zerar os bits irrelevantes e pegar exatamente os 6 bits desejados.</p>
<p>Graficamente, temos:</p>
<pre>
blk = <span style="color:lightblue">00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Agora, extraímos os grupos de 6 bits um por um:</p>
<ul>
  <li>Primeiros 6 bits: Para extrair os bits mais à esquerda, deslocamos 18 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_1 = (blk >> 18) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000000_00010010 → 000100</span>
b64_1 = <span style="color:#ffcc00;">000100</span>
</pre>
<ul>
  <li>Segundos 6 bits: Deslocamos 12 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_2 = (blk >> 12) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000010_01010010 → 010100</span>
b64_2 = <span style="color:#00ccff;">010100</span>
</pre>
<ul>
  <li>Terceiros 6 bits: Deslocamos 6 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_3 = (blk >> 6) & 0b00111111   <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 011110
b64_3 = <span style="color:#ff6666;">011110</span>
</pre>
<ul>
  <li>Últimos 6 bits: Não há deslocamento, apenas aplicamos a máscara.</li>
</ul>
<pre>
b64_4 = blk & 0b00111111 <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 100010
b64_4 = <span style="color:#ff9999;">100010</span>
</pre>
<p>Agora, temos os 4 índices da tabela Base64 prontos para serem mapeados!</p>
<p>Isso significa que podemos simplesmente usar o array <code>b64</code> para obter os caracteres correspondentes, indexando diretamente com <code>b64_1</code>, <code>b64_2</code>, <code>b64_3</code> e <code>b64_4</code>.</p>
<pre>
b64_1 = <span style="color:#ffcc00;">000100</span>  (4 em decimal)  →  Índice <code>b64[4]</code>  →  <span style="color:#ffcc00;">T</span>
b64_2 = <span style="color:#00ccff;">010100</span>  (20 em decimal) →  Índice <code>b64[20]</code> →  <span style="color:#00ccff;">U</span>
b64_3 = <span style="color:#ff6666;">011110</span>  (30 em decimal) →  Índice <code>b64[30]</code> →  <span style="color:#ff6666;">e</span>
b64_4 = <span style="color:#ff9999;">100010</span>  (34 em decimal) →  Índice <code>b64[34]</code> →  <span style="color:#ff9999;">Y</span>
</pre>
<p>Ou seja, os números binários extraídos representam <strong>índices na tabela Base64</strong>, e ao acessar <code>b64[4]</code>, <code>b64[20]</code>, etc., obtemos os caracteres finais da string codificada.</p>
</details>
</summary>
<hr />
<p>Agora só precisamos lidar com casos onde o input tem menos que 3 bytes ou o input não é múltiplo de 3 bytes</p>
<pre><code class="language-go">if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)

</code></pre>
<p>
Quando a entrada nã é múltiplo de 3 significa que ao sairmos do laço principal restará 1 ou 2 bytes. A especificação do Base64 exige que tenhamos 4 grupos fechados de 6 bits, que resultam 4 caracteres da tabela. 
</p>
<p>
Quando sobrar apenas 1 byte, teremos que agrupar em blocos de 6 bits e ter um total de 4 blocos. Como obter um total de 4 blocos de 6 bits com apenas 8 bits? A especificação diz que temos que pegar os 6 bits e obter qual o valor da tabela, para os 2 bits que sobrarem colocamos zeros **à direita** para completar 6 bits e então obtemos o valor na tabela e para os dois grupos restantes simplesmente consideramos o valor '='.
</p>
<p>
Então temos que: O primeiro grupo de 6 bits do byte pega um valor normalmente da tabela, o outro valor é obtido completando os 2 bits que sobraram com quatro zeros à direita e os outros dois grupos de 6 bits consideramos o '=' para cada um.
</p>
<p>
Quando sobram 2 bytes a regra é a mesma. Isto é, dos 16 bits teremos 2 valores _cheios_ e os 4 bits que sobram recebem dois zeros à direita e, diferente do caso que sobra apenas 1 byte, nesse caso precisamos de apenas um '=' para completar o grupo de 4 valores uma vez que já temos 3 grupos prontos.
</p>
<p>
P.ex.:
</p>
<p>
Se tivermos 1 byte sobrando (A = 01000001 em binário = 65 em decimal), precismos transformar isso em 4 blocos de 6 bits. Então fazemos o seguinte:
</p>
<pre>
<span style="color:yellow">010000</span><span style="color:rebeccapurple">01</span><span style="color:red">0000</span><span style="color:lightblue">=</span><span style="color:lightgreen">=</span>
</pre>
<p>Para os dois primeiros (coincidentemente) teremos o mesmo valor na b64table ('Q') e para os outros dois teremos o '='. Assim, ficamos com</p>
<pre>
<strong>QQ==</strong>
</pre>
<p>Com isso, c código completo fica assim:</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"encoding/base64"
)

const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func Encb64(in []byte) string {
	
    var out []byte
	len := len(in)
	rem := len % 3

    for i := 0; i &lt; len - rem; i += 3 {
    
        blk := int64(in[i    ]) &lt;&lt; 16 | 
               int64(in[i + 1]) &lt;&lt; 8  | 
               int64(in[i + 2])

        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)
	}

	if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)
}

func main() {
    testCases := []string{"Manaed", "1234567890"}
	
    for _, test := range testCases {
		encoded := Encb64([]byte(test))
		encondedGo := base64.StdEncoding.EncodeToString([]byte(test))
		fmt.Println("Base64 de ", test, ": ", encoded)
		fmt.Println("Base64 Go : ", test, ": ", encondedGo)
		
	}
}
</code></pre>
<p>Curiosidade: nossa versão fica alguns ms mais lenta que a versão do Go, sintam-se à vontade para estudar a versão em Go, agora poderão entender todo o código!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="checksum-e-crc---verificação-de-integridade"><a class="header" href="#checksum-e-crc---verificação-de-integridade">Checksum e CRC - Verificação de Integridade</a></h1>
<p><img src="conceitos/checksum-crc/images/image.png" alt="Checksum" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-3"><a class="header" href="#introdução-3">Introdução</a></h1>
<p>Na seção anterior, discutimos a codificação e o transporte de dados. Agora, avançamos para um aspecto essencial da transmissão e armazenamento de informações: a verificação de integridade. Esse processo garante que os dados recebidos são os mesmos que foram enviados, sem terem sido alterados ou corrompidos durante a transmissão ou armazenamento.</p>
<p>A integridade dos dados pode ser comprometida por diversos fatores, como erros humanos, falhas sistêmicas (por exemplo, setores defeituosos em discos rígidos) ou perdas de pacotes em redes devido a interferências ou congestionamento.</p>
<p>Para detectar essas falhas, foram desenvolvidos mecanismos como os checksums e os CRC (Cyclic Redundancy Check), que permitem identificar se os dados foram alterados de forma acidental.</p>
<p>É importante diferenciar esses métodos das funções hash criptográficas, como MD5 e SHA-256, que abordaremos mais adiante neste livro. Enquanto checksums e CRCs são projetados para detectar erros acidentais, funções hash criptográficas garantem a integridade contra modificações intencionais, oferecendo resistência a ataques e manipulação maliciosa.</p>
<p>Nesta seção, exploraremos como checksums simples podem ser utilizados para verificar integridade e, em seguida, como os CRC oferecem um método mais robusto para detectar erros em sistemas computacionais.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="parity-bit"><a class="header" href="#parity-bit">Parity Bit</a></h1>
<p>Parity bit é um código de detecção de erros em que um bit extra é adicionado ao final da mensagem para garantir que o número total de bits "1" seja par (paridade par) ou ímpar (paridade ímpar). Se um único bit for invertido durante a transmissão, o receptor perceberá a inconsistência e poderá solicitar o reenvio.</p>
<p>Exemplo de paridade par:</p>
<pre><code>Mensagem original: 10101110 (8 bits)
Número de bits "1": 5
Bit de paridade: 1 (para tornar o total par)
Mensagem transmitida: 101011101
</code></pre>
<p>Se um erro ocorrer e inverter um bit:</p>
<pre><code>Recebido: 101001101 (erro no terceiro bit)
Número de bits "1": 4 → Inconsistência detectada.
</code></pre>
<p>Embora simples, a paridade tem limitações: não detecta erros em um número par de bits invertidos, tornando-a inadequada para muitas aplicações.</p>
<p>Como alternativa, poderíamos enviar a mensagem duas vezes e comparar ambas as cópias. No entanto, isso dobra o consumo de banda e não garante detecção total de erros se ambas as cópias forem corrompidas de forma idêntica.</p>
<p>O ideal é encontrar um código de verificação que minimize o custo de transmissão e maximize a capacidade de detecção de erros. Os dois métodos mais utilizados são:</p>
<ul>
<li>Checksums – Somam os valores dos bytes da mensagem e armazenam o resultado junto com os dados.</li>
<li>Cyclic Redundancy Check (CRC) – Usa operações matemáticas sobre polinômios para gerar um código de verificação mais robusto.</li>
</ul>
<p>Nos próximos tópicos, exploraremos esses métodos em detalhes, mostrando suas implementações e aplicações.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="checksum"><a class="header" href="#checksum">Checksum</a></h1>
<p>O checksum é a forma mais simples de verificação de integridade, sendo calculado somando os valores dos bytes ou palavras de um dado e armazenando essa soma junto com os dados. Ao receber ou ler os dados, a soma é recalculada e comparada com o checksum armazenado. Se os valores diferirem, isso indica um erro na transmissão ou no armazenamento.</p>
<h3 id="exemplo-de-checksum-simples-soma-de-bytes"><a class="header" href="#exemplo-de-checksum-simples-soma-de-bytes">Exemplo de Checksum Simples (Soma de Bytes)</a></h3>
<p>Vamos criar uma implementação básica de checksum em Go, somando os valores dos bytes da mensagem e calculando o módulo 256 para manter um valor fixo de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Função de checksum simples (soma dos bytes módulo 256)
func SimpleChecksum(data []byte) byte {
	var checksum byte = 0
	for _, b := range data {
		checksum += b
	}
	return checksum
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("Checksum de 'HELLO': 0x%X\n", SimpleChecksum(data))
}
</code></pre>
<p>Um algorítmo simples como o demonstrado acima possui algumas limitações importantes:</p>
<ul>
<li>Não detecta trocas na ordem dos bytes (ABC e CBA geram o mesmo checksum)</li>
<li>Colisões serão frequentes (diferentes mensagens podem gerar o mesmo valor de checksum)</li>
<li>Não detecta alguns tiopos de erro bit a bit</li>
</ul>
<p>Para resolver esses problemas, foram criadas versões mais sofisticadas, como o CRC.</p>
<h2 id="checksum-no-udpip"><a class="header" href="#checksum-no-udpip">Checksum no UDP/IP</a></h2>
<p>O protocolo UDP (User Datagram Protocol) e o cabeçalho IP (Internet Protocol) utilizam um checksum baseado em complemento de um, que é uma técnica mais avançada do que a simples soma de bytes. Esse método melhora a detecção de erros, sendo amplamente usado na transmissão de pacotes de rede.</p>
<p>Como o checksum do UDP/IP funciona?</p>
<ul>
<li>A mensagem (ou cabeçalho IP) é dividida em blocos de 16 bits.</li>
<li>Os blocos são somados usando aritmética de complemento de um.</li>
<li>O complemento de um do resultado final é armazenado como o checksum.</li>
<li>No destino, o receptor soma todos os blocos novamente, incluindo o checksum recebido.</li>
<li>Se o resultado for 0xFFFF, os dados são considerados íntegros; caso contrário, há erro na transmissão.</li>
</ul>
<p>Isso permite detectar a maioria dos erros comuns em transmissões de rede.</p>
<h3 id="implementação-do-checksum-udpip-em-go"><a class="header" href="#implementação-do-checksum-udpip-em-go">Implementação do Checksum UDP/IP em Go</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
)

// Função para calcular o checksum do UDP/IP usando complemento de um
func UDPChecksum(data []byte) uint16 {
	var sum uint32

	// Processa os dados em blocos de 16 bits
	for i := 0; i &lt; len(data)-1; i += 2 {
		word := binary.BigEndian.Uint16(data[i : i+2]) // Converte dois bytes em um uint16
		sum += uint32(word)
	}

	// Se o número de bytes for ímpar, adiciona o último byte com padding
	if len(data)%2 != 0 {
		sum += uint32(data[len(data)-1]) &lt;&lt; 8
	}

	// Adiciona os "overflows" da soma (carry bits)
	for (sum &gt;&gt; 16) &gt; 0 {
		sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16)
	}

	// Retorna o complemento de um do resultado final
	return uint16(^sum)
}

func main() {
	data := []byte("HELLOUDP")
	checksum := UDPChecksum(data)
	fmt.Printf("Checksum UDP de 'HELLOUDP': 0x%X\n", checksum)
}

</code></pre>
<p>Essa implementação reflete como os protocolos UDP e IP realizam a verificação de integridade, garantindo que os pacotes de rede cheguem corretamente ao destino.</p>
<h3 id="implementação-do-crc-8-em-go"><a class="header" href="#implementação-do-crc-8-em-go">Implementação do CRC-8 em Go</a></h3>
<p>O CRC-8 é uma das versões mais simples, usando um polinômio de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela CRC-8 para polinômio 0x07 (x^8 + x^2 + x + 1)
var crc8Table [256]byte

// Inicializa a tabela CRC-8
func init() {
	const poly = byte(0x07)
	for i := 0; i &lt; 256; i++ {
		crc := byte(i)
		for j := 0; j &lt; 8; j++ {
			if (crc &amp; 0x80) != 0 {
				crc = (crc &lt;&lt; 1) ^ poly
			} else {
				crc &lt;&lt;= 1
			}
		}
		crc8Table[i] = crc
	}
}

// Calcula CRC-8 para um conjunto de dados
func CRC8(data []byte) byte {
	crc := byte(0)
	for _, b := range data {
		crc = crc8Table[crc^b]
	}
	return crc
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("CRC-8 de 'HELLO': 0x%X\n", CRC8(data))
}
</code></pre>
<p>O CRC, diferente do checksum, detecta trocas na ordem dos bytes, detecta erros simples de mútiplos bits errados e possui menor taxa de colisões. Mas o CRC-8 não é reistente a ataques maliciosos (não deve ser usado para segurança) e pode falhar na detecção de alguns padrões específicos de erro se o polinômio não for bem escolhido.</p>
<h2 id="variações-do-crc"><a class="header" href="#variações-do-crc">Variações do CRC</a></h2>
<p>CRC-16
CRC-32
CRC-64
Adler-32
Fletcher-16/32</p>
<p>Cada algoritmo tem um nível diferente de eficiência e resistência a erros. CRC-32, por exemplo, é usado no ZIP e no protocolo de rede Ethernet devido à sua confiabilidade e baixo custo computacional.</p>
<h2 id="diferença-entre-checksum-crc-e-funções-hash"><a class="header" href="#diferença-entre-checksum-crc-e-funções-hash">Diferença entre Checksum, CRC e Funções Hash</a></h2>
<h3 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h3>
<p>O checksum é uma técnica básica e eficiente para detecção de erros simples, mas tem falhas para detecção de padrões mais complexos. O CRC usa divisão polinomial para criar uma verificação mais robusta contra corrupção de dados, sendo amplamente utilizado em redes e armazenamento. Nenhum desses métodos deve ser confundido com funções hash criptográficas, que garantem segurança contra alterações intencionais nos dados.</p>
<p>Se queremos segurança contra modificações maliciosas, devemos usar HMAC, SHA-256 ou outras funções hash seguras.</p>
<p>Agora que entendemos essas formas de verificação de integridade fraca, podemos avançar para a família MD (Message Digest), que evolui de checksums simples para funções hash mais sofisticadas.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="crc---cyclic-redundandy-check"><a class="header" href="#crc---cyclic-redundandy-check">CRC - Cyclic Redundandy Check</a></h1>
<p>O CRC (Cyclic Redundancy Check) é um método de detecção de erros baseado em operações matemáticas sobre polinômios binários. Em vez de apenas somar valores, o CRC trata os dados como um número binário e divide esse número por um polinômio pré-determinado, registrando o resto da divisão como código de verificação.</p>
<p>O CRC é amplamente usado em:</p>
<ul>
<li>Transmissões de rede (Ethernet, Wi-Fi)</li>
<li>Armazenamento de arquivos (ZIP, RAR)</li>
<li>Sistemas embarcados (CD-ROM, comunicações seriais)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hashing-e-sha-256"><a class="header" href="#hashing-e-sha-256">Hashing e SHA-256</a></h1>
<h2 id="introdução-4"><a class="header" href="#introdução-4">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/hash/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hashing-e-sha-256-1"><a class="header" href="#hashing-e-sha-256-1">Hashing e SHA-256</a></h1>
<h2 id="introdução-5"><a class="header" href="#introdução-5">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/hash/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-md---message-digest"><a class="header" href="#família-de-algoritmos-md---message-digest">Família de Algoritmos MD - Message Digest</a></h1>
<h2 id="md2"><a class="header" href="#md2">MD2</a></h2>
<p>O primeiro algoritmo amplamente publicado da família MD (Message Digest) foi o MD2 e foi desenvolvido por Ronald Rivest em 1989 (não achei nenhuma publicação do MD1 nem do MD3). Ele foi projetado especificamente para computadores de 8 bits. Apesar de ter sido uma inovação importante, o MD2 se tornou obsoleto com o tempo devido a ataques criptográficos bem-sucedidos. Suas principais características eram:</p>
<ul>
<li>Tamanho da saída: 128 bits (16 bytes)</li>
<li>Entrada de tamanho variável</li>
<li>Projetado para máquinas de 8 bits</li>
<li>Inseguro desde 2004 devido a ataques práticos</li>
<li>Lento em hardware moderno devido à otimização para 8 bits</li>
</ul>
<h3 id="como-o-md2-funciona"><a class="header" href="#como-o-md2-funciona">Como o MD2 Funciona?</a></h3>
<p>A especificação do MD2 pode ser encontrada na RFC 1319. Esse algorítmo transforma qualquer entrada em um hash de 128bits. Ele faz isso seguindo 3 etapas principais:</p>
<h4 id="1---padding"><a class="header" href="#1---padding">1 - Padding</a></h4>
<p>Para garantir que o tamanho da entrada seja um múltiplo de 16 bytes, adicionamos bytes de padding no final. A regra é a seguinte:</p>
<ul>
<li>se o tamanho da mensagem já for múltiplo de 16, adicionamos 16 bytes com o valor 0x10 (16 em decimal).</li>
<li>se faltar N bytes para completar 16, adicionamos N bytes com o valor de N.</li>
</ul>
<p>Exemplo:</p>
<p><img src="conceitos/hash/images/padding-md2.png" alt="Padding MD2" /></p>
<p>Ou seja:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Etapa</strong></th><th><strong>Dados</strong></th></tr></thead><tbody>
<tr><td><strong>Entrada original</strong></td><td>Hexa: <code>[41 42 43]</code> = <code>"ABC"</code></td></tr>
<tr><td><strong>Tamanho</strong></td><td><strong>3 bytes</strong></td></tr>
<tr><td><strong>Padding necessário</strong></td><td><code>16 - 3 = 13</code> bytes</td></tr>
<tr><td><strong>Preenchimento</strong></td><td><strong>Faltam 13 bytes</strong>, então usamos <code>0x0D</code> (13)</td></tr>
<tr><td><strong>Resultado final</strong></td><td><code>[41 42 43 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D]</code></td></tr>
</tbody></table>
</div>
<p>Se a entrada tivesse 15 bytes, haveria um padding de 1 byte com o valor 0x01, se tivesse exatamente 16 bytes, faríamos um padding de mais 16 bytes com o valor 0x10 (16 em decimal), e assim por diante.</p>
<h4 id="2---checksum"><a class="header" href="#2---checksum">2 - Checksum</a></h4>
<p>O MD2 adiciona um checksum de 16 bytes, que é computado iterando sobre a mensagem e aplicando XOR com uma tabela de permutação.</p>
<p>Essa tabela de permutação S-box (256 valores) foi escolhida manualmente por Rivest e é baseada em uma permutação "aleatória" dos dígitos de Pi.</p>
<p>Uma S-box (Substitution Box) é uma tabela de substituição não linear usada em criptografia para aumentar a confusão, um conceito fundamental introduzido por Claude Shannon em seu estudo seminal sobre teoria da criptografia (Shannon, 1949)[1].</p>
<p>O objetivo do checksum no MD2 é adicionar redundância e garantir que qualquer alteração na mensagem original impacte significativamente o resultado final. O checksum não serve como verificação de integridade tradicional (como em CRCs), mas sim para aumentar a resistência do algoritmo contra colisões.</p>
<h5 id="como-o-checksum-é-calculado"><a class="header" href="#como-o-checksum-é-calculado">Como o Checksum é Calculado?</a></h5>
<p>A cada bloco de 16 bytes da mensagem (com padding já aplicado), percorremos byte a byte e atualizamos o checksum usando a tabela S-Box.</p>
<p>O cálculo segue a seguinte fórmula:</p>
<pre><code>C[j] = C[j] XOR S[M[i * 16 + j] XOR L]
L = C[j]
</code></pre>
<p>Onde:</p>
<ul>
<li>C[j] -&gt; byte j do checksum</li>
<li>M[i * 16 + j] -&gt; byte j do bloco i da mensagem</li>
<li>S[x] -&gt; S-Box, uma tabela de substituição com 256 valores, indexada pelo resultado do XOR</li>
<li>L -&gt; Último valor atualizado do checksum, começando com 0.</li>
</ul>
<p>Veja um passo a passo com valores reais:</p>
<p>Suponha que:</p>
<ul>
<li>C[3] = 0xA5</li>
<li>M[3] = 0x7F</li>
<li>L = 0x2C</li>
<li>S[0x53] = 0xD4 (porque 0x7F XOR 0x2C = 0x53)</li>
</ul>
<p>Agora, aplicamos:</p>
<pre><code>C[3] = C[3] XOR S[ M[3] XOR L ]
     = 0xA5 XOR S[0x53]
     = 0xA5 XOR 0xD4
     = 0x71

L = C[3] = 0x71

</code></pre>
<p>Essa fase adiciona o efeito de difusão na mensagem antes da fase final.</p>
<p>A difusão é um conceito introduzido por Claude Shannon [Shannon, 1949] [1], onde pequenas mudanças na entrada devem se espalhar por toda a saída, dificultando a recuperação do texto original a partir do hash ou da cifra</p>
<p>Após processar todos os blocos, os 16 bytes do checksum são anexados à mensagem.</p>
<h5 id="implementação-em-go-2"><a class="header" href="#implementação-em-go-2">Implementação em Go</a></h5>
<pre><code class="language-go">var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
	251, 140, 206, 36, 255, 96, 147, 158, 69, 48, 36, 136, 74, 95, 35, 94,
	191, 249, 189, 14, 125, 77, 135, 55, 146, 147, 238, 93, 139, 140, 74, 38,
	192, 89, 246, 116, 40, 158, 136, 171, 166, 123, 101, 26, 52, 36, 252, 176,
	191, 226, 174, 121, 38, 160, 202, 64, 141, 197, 210, 251, 144, 45, 47, 157,
	202, 121, 128, 192, 105, 111, 94, 108, 218, 158, 71, 89, 152, 76, 108, 188,
	50, 203, 61, 117, 158, 140, 76, 144, 55, 199, 24, 97, 46, 24, 94, 82,
	113, 72, 54, 86, 109, 98, 125, 204, 159, 107, 38, 249, 72, 36, 84, 113,
	194, 250, 70, 161, 78, 245, 121, 158, 239, 190, 42, 222, 104, 63, 93, 106,
	242, 216, 64, 122, 174, 210, 194, 79, 124, 55, 198, 156, 168, 40, 56, 156,
	64, 54, 73, 87, 179, 51, 173, 40, 180, 199, 47, 105, 26, 43, 76, 174,
	45, 195, 89, 147, 67, 252, 184, 248, 128, 137, 223, 62, 142, 119, 196, 32,
	32, 129, 107, 244, 153, 178, 61, 134, 240, 144, 47, 226, 121, 69, 116, 48,
	155, 158, 112, 164, 109, 140, 167, 220, 111, 115, 137, 187, 61, 122, 82, 194,
	218, 102, 243, 99, 208, 172, 193, 141, 145, 226, 218, 162, 232, 64, 202, 47,
	118, 164, 108, 173, 98, 217, 187, 178, 244, 130, 108, 78, 122, 84, 133, 150,
}

func computeChecksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0 // Inicializa L com 0

	// Percorre a mensagem em blocos de 16 bytes
	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			c := message[i+j]
			checksum[j] ^= SBox[c^L] // Calcula o novo valor do checksum
			L = checksum[j]           // Atualiza L para o próximo passo
		}
	}
	return checksum
}
</code></pre>
<h4 id="3---processamento-principal"><a class="header" href="#3---processamento-principal">3 - Processamento Principal</a></h4>
<p>Agora pegamos a <strong>mensagem com padding</strong> e <strong>checksum</strong> e a processamos utilizando um buffer intermediário de <strong>48 bytes</strong>. O objetivo desta fase é misturar os dados de forma não linear para aumentar a resistência a colisões.</p>
<p>Diferente de outros algoritmos como o MD4 e MD5, que usam operações de <strong>rotação bitwise</strong> para aumentar a difusão dos bits, o MD2 utiliza <strong>apenas operações XOR e tabelas de substituição</strong> (S-Box). Isso se deve ao fato de que ele foi projetado para <strong>arquiteturas de 8 bits</strong>, onde operações bitwise mais complexas poderiam ser ineficientes.</p>
<h5 id="estrutura-do-buffer-de-48-bytes"><a class="header" href="#estrutura-do-buffer-de-48-bytes">Estrutura do Buffer de 48 Bytes</a></h5>
<p>O <strong>buffer de processamento</strong> (<code>X</code>) é um array de <strong>48 bytes</strong>, onde os primeiros <strong>16 bytes</strong> armazenam o hash intermediário, os <strong>segundos 16 bytes</strong> armazenam um bloco da mensagem e os <strong>últimos 16 bytes</strong> contêm a mistura do bloco da mensagem com os primeiros 16 bytes.</p>
<pre><code>X = [H(0) H(1) .. H(15) | M(0) M(1)... M(15) | H(0) XOR M(0), ... , H(15) XOR M(15)]
</code></pre>
<p>Onde:</p>
<ul>
<li><code>H</code> representa os primeiros 16 bytes do buffer, que armazenam o estado atual do hash.</li>
<li><code>M</code> representa os 16 bytes do bloco da mensagem sendo processado.</li>
</ul>
<h5 id="etapas-do-processamento"><a class="header" href="#etapas-do-processamento">Etapas do Processamento</a></h5>
<p>A cada <strong>bloco de 16 bytes</strong>, fazemos o seguinte:</p>
<ol>
<li><strong>Copiamos o bloco da mensagem (<code>M</code>) para os bytes 16 a 31</strong> do buffer.</li>
<li><strong>Criamos a mistura dos primeiros 16 bytes (<code>H</code>) com o bloco <code>M</code></strong>, armazenando nos bytes 32 a 47.</li>
<li>Executamos 18 rodadas de processamento, onde aplicamos XOR sequencialmente nos 48 bytes do buffer usando a tabela S-Box. O número 18 não foi escolhido arbitrariamente: ele está relacionado ao fato de que o MD2 foi projetado para rodar eficientemente em arquiteturas de 8 bits. Como a S-Box tem 256 valores possíveis (8 bits), e um bloco do MD2 possui 16 bytes, Rivest determinou que 18 rodadas forneciam difusão suficiente sem comprometer o desempenho em hardware de baixa capacidade. Esse valor foi escolhido de forma empírica para equilibrar segurança e eficiência computacional.</li>
</ol>
<p>Cada rodada segue esta fórmula:</p>
<pre><code>X[j] = X[j] XOR SBox[T]
T = X[j]
</code></pre>
<p>Sendo que <code>T</code> é um acumulador que começa em zero e é atualizado ao longo da iteração.</p>
<p>Isso garante que o hash seja alterado a cada rodada, propagando as mudanças nos bytes de maneira não linear.</p>
<h5 id="exemplo-de-transformação"><a class="header" href="#exemplo-de-transformação">Exemplo de Transformação</a></h5>
<p>Suponha que o buffer <code>X</code> comece com:</p>
<pre><code>X = [ A1 A2 ... A16 | B1 B2 ... B16 | C1 C2 ... C16 ]
</code></pre>
<p>Após aplicar a <strong>permutação com a S-Box</strong>, obtemos:</p>
<pre><code>X' = [ P1 P2 ... P16 | Q1 Q2 ... Q16 | R1 R2 ... R16 ]
</code></pre>
<p>Essa transformação acontece <strong>18 vezes</strong>, garantindo uma alta difusão dos bits.</p>
<p>A implementação do <strong>processamento principal</strong> segue abaixo:</p>
<pre><code class="language-go">func processMD2Blocks(message []byte) [16]byte {
	var X [48]byte // Buffer intermediário de 48 bytes

	for i := 0; i &lt; len(message); i += 16 {
		// Copia o bloco da mensagem para os bytes 16 a 31 do buffer
		copy(X[16:32], message[i:i+16])

		// Preenche os últimos 16 bytes com H ⊕ M
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0

		// 18 rodadas de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T] // Permutação não linear usando a S-Box
				T = X[j]        // Atualiza T
			}
			T += byte(round) // Incrementa T a cada rodada
		}
	}

	// O hash final é extraído dos primeiros 16 bytes do buffer X
	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}
</code></pre>
<h5 id="conceitos-aplicados"><a class="header" href="#conceitos-aplicados">Conceitos Aplicados</a></h5>
<p>Este processamento principal do MD2 explora três princípios fundamentais da criptografia:</p>
<p>Confusão ([Shannon, 1949][1])
A permutação S-Box adiciona um grau de não linearidade ao algoritmo, tornando difícil estabelecer relações diretas entre a entrada e a saída.</p>
<p>Difusão ([Shannon, 1949][1])
Cada byte do hash final depende de todos os bytes da mensagem de entrada, devido à aplicação iterativa da S-Box e do XOR.</p>
<p>Avalanche Effect
Pequenas mudanças na entrada resultam em grandes mudanças no hash, pois cada rodada mistura bits de diferentes partes da mensagem.</p>
<p>Após esse processo, os primeiros 16 bytes do buffer X formam o hash MD2 final.</p>
<h3 id="implementação-completa-do-algoritmo-md2-em-go"><a class="header" href="#implementação-completa-do-algoritmo-md2-em-go">Implementação Completa do Algoritmo MD2 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela de permutação S-box
var S = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	// (o restante foi omitido por brevidade, consulte a RFC 1319)
}

func MD2(input []byte) [16]byte {
	// Parte 1: Padding
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	input = append(input, padding...)

	// Parte 2: Checksum
	var checksum [16]byte
	var L byte = 0
	for i := 0; i &lt; len(input); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= S[input[i+j]^L]
			L = checksum[j]
		}
	}
	input = append(input, checksum[:]...)

	// Parte 3: Transformação Principal
	var X [48]byte
	
    for i := 0; i &lt; len(input); i += 16 {
		
        // Copia bloco para X
		copy(X[16:32], input[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[16+j] ^ X[j]
		}
		var t byte = 0

		// 18 rounds de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= S[t]
				t = X[j]
			}
			t += byte(round)
		}
	}

	// O hash final está nos primeiros 16 bytes de X
	var hash [16]byte
	
    copy(hash[:], X[:16])
	
    return hash
}

func main() {
	data := []byte("Mensagem de teste")
	hash := MD2(data)
	fmt.Printf("MD2 Hash: %x\n", hash)
}
</code></pre>
<h2 id="md4---a-evolução-do-message-digest"><a class="header" href="#md4---a-evolução-do-message-digest">MD4 - A Evolução do Message Digest</a></h2>
<p>O MD4 (Message Digest 4) foi desenvolvido por Ronald Rivest em 1990 como uma melhoria do MD2, projetado especificamente para processadores de 32 bits. Ele introduziu um novo modelo de operação baseado em três rodadas de funções não lineares, tornando-o muito mais rápido que o MD2.</p>
<p>No entanto, o MD4 é extremamente fraco e foi quebrado rapidamente. Mesmo assim, sua estrutura inspirou diretamente o MD5 e SHA-1, servindo de base para os algoritmos de hash modernos e que veremos logo mais.</p>
<h3 id="como-o-md4-funciona"><a class="header" href="#como-o-md4-funciona">Como o MD4 Funciona?</a></h3>
<p>A especificação do MD4 pode ser encontrada na RFC 1320. O algoritmo transforma qualquer entrada em um hash de 128 bits usando 3 rodadas de operações baseadas em soma modular e funções booleanas.</p>
<p>O MD4 segue 4 etapas principais:</p>
<p>1 - Padding</p>
<ul>
<li>O comprimento da mensagem é ajustado para que seja múltiplo de 512 bits (64 bytes).</li>
<li>Um bit 1 é adicionado, seguido de zeros até que faltem 64 bits para completar um bloco.</li>
<li>Os últimos 64 bits armazenam o tamanho original da mensagem (antes do padding)</li>
</ul>
<p>Exemplo:</p>
<p>Se tivermos a mensagem "abc", que tem 24 bits (3 bytes), adicionamos:</p>
<pre><code>01100001 01100010 01100011 10000000 00000000 ... (até completar 448 bits)

</code></pre>
<p>E então adicionamos os 64 bits finais contendo o tamanho da mensagem.</p>
<p>2 - Inicialização dos Registradores</p>
<p>MD4 usa quatro registradores de 32 bits, inicializados com valores fixos:</p>
<pre><code>A = 0x67452301
B = 0xEFCDAB89
C = 0x98BADCFE
D = 0x10325476

</code></pre>
<p>Esses valores são inspirados na constante da raiz quadrada de números primos.</p>
<p>3 - Processamento em 3 Rodadas</p>
<p>A mensagem é dividida em blocos de 512 bits (64 bytes), e cada bloco passa por três rodadas de operações matemáticas:</p>
<p>3.1 - Função F (AND, OR, NOT)</p>
<pre><code>F(X, Y, Z) = (X AND Y) OR (NOT X AND Z)

</code></pre>
<p>Essa função favore um dos valores (X) e ajuda na difusão.</p>
<p>3.2 - Função G (Majority Vote)</p>
<pre><code>G(X, Y, Z) = (X AND Y) OR (X AND Z) OR (Y AND Z)

</code></pre>
<p>Utiliza uma "votação" entre os três valores.</p>
<p>3.3 - Função H (XOR)</p>
<pre><code>H(X, Y, Z) = X XOR Y XOR Z

</code></pre>
<p>Mistura os bits de forma caótica.</p>
<p>Cada uma dessas funções é aplicada a cada bloco de 512 bits da mensagem, alterando os registradores A, B, C e D.</p>
<p>4 - Hash Final</p>
<p>Após todas as rodadas, os valores finais dos registradores A, B, C e D são concatenados para formar um hash de 128 bits (16 bytes).</p>
<h3 id="implementação-do-md4-em-go"><a class="header" href="#implementação-do-md4-em-go">Implementação do MD4 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"crypto/md2"
	"encoding/hex"
	"fmt"
	"golang.org/x/crypto/md2" // Biblioteca oficial do Go para MD2
)

// Tabela de permutação S-box (definida na RFC 1319)
var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
}

// Aplicar Padding conforme RFC 1319
func md2Padding(input []byte) []byte {
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	return append(input, padding...)
}

// Calcular Checksum
func md2Checksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0

	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= SBox[message[i+j]^L]
			L = checksum[j]
		}
	}

	return checksum
}

// Aplicar Transformação Principal
func md2Transform(message []byte) [16]byte {
	var X [48]byte

	for i := 0; i &lt; len(message); i += 16 {
		copy(X[16:32], message[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T]
				T = X[j]
			}
			T += byte(round)
		}
	}

	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}

// Função principal MD2
func MD2(input []byte) [16]byte {
	padded := md2Padding(input)
	checksum := md2Checksum(padded)
	message := append(padded, checksum[:]...)
	return md2Transform(message)
}

// Função para comparar com a implementação oficial
func compareWithLibrary(input string) {
	hash := MD2([]byte(input))
	fmt.Printf("Nosso MD2: %x\n", hash)

	libHash := md2.New()
	libHash.Write([]byte(input))
	fmt.Printf("MD2 OpenSSL: %x\n", libHash.Sum(nil))
}

func main() {
	testInput := "Mensagem de teste"
	compareWithLibrary(testInput)
}

</code></pre>
<p>Podemos comparar também com o openssl para ver se a mensagem bate:</p>
<pre><code class="language-bash">echo -n "Mensagem de teste" | openssl md2
</code></pre>
<h4 id="ataques-contra-o-md4"><a class="header" href="#ataques-contra-o-md4">Ataques Contra o MD4</a></h4>
<p>O MD4 foi um grande avanço na época, mas também teve falhas graves de segurança. Aqui, exploramos os ataques mais relevantes que levaram à sua obsolescência.</p>
<p>1 - Ataque de Colisão (1995) - Hans Dobbertin</p>
<p>Em 1995, o criptógrafo Hans Dobbertin publicou um ataque prático contra o MD4, demonstrando que era possível encontrar colisões em alguns segundos.</p>
<p>Isso quebra a confiabilidade do algoritmo, pois qualquer atacante pode substituir um documento sem alterar seu hash.</p>
<p>Como Dobbertin quebrou o MD4?
Ele explorou fraquezas estruturais nas três rodadas do MD4, usando um método conhecido como differential cryptanalysis.</p>
<p>Ele encontrou colisões em menos de 1 minuto usando um computador comum da época!</p>
<p>2 - Ataque de Colisão Rápido (2007) - Wang et al.</p>
<p>Em 2007, Xiaoyun Wang, Hongbo Yu e Yiqun Lisa Yin aprimoraram os ataques de Dobbertin e conseguiram gerar colisões em tempo real.</p>
<p>3 - Ataque de Pré-imagem (2009)</p>
<p>Em 2009, pesquisadores mostraram que dado um hash MD4, era possível reconstruir uma entrada que produzia o mesmo valor.</p>
<p>Esse ataque é catastrófico para aplicações que dependem de integridade, como assinaturas digitais.</p>
<p>4 - Ataque a Senhas no NTLM (Windows)</p>
<p>O MD4 foi usado no NTLM (Microsoft Windows Authentication). Como os ataques de colisão e pré-imagem são rápidos, foi possível quebrar senhas NTLM em milissegundos.</p>
<h3 id="implementando-um-ataque-de-colisão-contra-md4-em-go"><a class="header" href="#implementando-um-ataque-de-colisão-contra-md4-em-go">Implementando um Ataque de Colisão Contra MD4 em Go</a></h3>
<p>Vamos gerar duas mensagens diferentes com o mesmo hash.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Simulação de colisão no MD4
func findCollision() {
	msg1 := []byte("Ataque123")
	msg2 := []byte("At4que123") // Alteração mínima

	hash1 := md4(msg1)
	hash2 := md4(msg2)

	fmt.Printf("Mensagem 1: %s\nHash 1: %x\n", msg1, hash1)
	fmt.Printf("Mensagem 2: %s\nHash 2: %x\n", msg2, hash2)

	if hash1 == hash2 {
		fmt.Println("Colisão encontrada!")
	} else {
		fmt.Println("Nenhuma colisão encontrada.")
	}
}

func main() {
	findCollision()
}

</code></pre>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-des---data-encryption-standard"><a class="header" href="#família-de-algoritmos-des---data-encryption-standard">Família de Algoritmos DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-sha---secure-hash-algorithms"><a class="header" href="#família-de-algoritmos-sha---secure-hash-algorithms">Família de Algoritmos SHA - Secure Hash Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="pbkdf2-argon2-e-scrypt---hash-para-senhas"><a class="header" href="#pbkdf2-argon2-e-scrypt---hash-para-senhas">PBKDF2, Argon2 e Scrypt - Hash para Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="algorítmos-de-criptografia"><a class="header" href="#algorítmos-de-criptografia">Algorítmos de Criptografia</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="des---data-encryption-standard"><a class="header" href="#des---data-encryption-standard">DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="3des---triple-des"><a class="header" href="#3des---triple-des">3DES - Triple DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes---advanced-encryption-standard"><a class="header" href="#aes---advanced-encryption-standard">AES - Advanced Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rsa---rivest-shamir-e-adleman"><a class="header" href="#rsa---rivest-shamir-e-adleman">RSA - Rivest, Shamir e Adleman</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="ecdsa---elliptic-curve-digital-signature-algorithm"><a class="header" href="#ecdsa---elliptic-curve-digital-signature-algorithm">ECDSA - Elliptic Curve Digital Signature Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hmac---assinaturas-seguras"><a class="header" href="#hmac---assinaturas-seguras">HMAC - Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="criptografia-simétrica-vs-assimétrica"><a class="header" href="#criptografia-simétrica-vs-assimétrica">Criptografia Simétrica vs Assimétrica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miscelânea"><a class="header" href="#miscelânea">Miscelânea</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="confusão-e-difusão-1"><a class="header" href="#confusão-e-difusão-1">Confusão e Difusão</a></h1>
<p>As propriedades de <strong>confusão</strong> e <strong>difusão</strong> são dois princípios fundamentais estabelecidos por Shannon [1], constituindo pilares da segurança em sistemas criptográficos modernos. Esses conceitos têm como objetivo maximizar a incerteza e a dispersão das relações estatísticas entre a mensagem não cifrada e a mensagem cifrada, dificultando ataques baseados em análise de frequência ou estrutura.</p>
<h2 id="definições-formais-1"><a class="header" href="#definições-formais-1">Definições formais</a></h2>
<p><strong>Confusão</strong>: o objetivo é tornar complexa a relação entre a chave de encriptação e o texto cifrado. De acordo com Shannon, "o sistema deve ser projetado de modo que cada bit da chave afete, de forma imprevisível, muitos bits da saída". Confusão impede que um atacante deduza partes da chave mesmo conhecendo partes do texto cifrado.</p>
<p><strong>Difusão</strong>: refere-se à dispersão estatística do conteúdo da mensagem não cifrada ao longo da mensagem cifrada. Ou seja, um pequeno número de bits alterados na entrada deve afetar um grande número de bits na saída. A difusão elimina padrões e distribui redundâncias da mensagem original.</p>
<p>Esse comportamento, em que pequenas alterações na entrada produzem grandes alterações na saída, é conhecido como <strong>efeito avalanche</strong>, e é resultado da aplicação combinada de confusão e difusão.</p>
<p>Essas duas propriedades são frequentemente implementadas em cifras modernas por meio de redes de substituição e permutação redes de substituição e permutação (Substitution-Permutation Networks), conforme discutido por Donald Knuth em <em>The Art of Computer Programming</em> [5], onde destaca a importância da aleatoriedade controlada na construção de algoritmos seguros.</p>
<h2 id="exemplo-prático-simulações-de-confusão-e-difusão-em-go-1"><a class="header" href="#exemplo-prático-simulações-de-confusão-e-difusão-em-go-1">Exemplo Prático: Simulações de Confusão e Difusão em Go</a></h2>
<p>Para isolar os conceitos, não implementamos uma cifra completa, mas sim funções que exemplificam mecanicamente confusão (via substituições não lineares com chave) e difusão (via permutações e operações de dispersão simples).</p>
<p>A estrutura será:</p>
<ul>
<li>
<p>Confusão: uso de uma substituição baseada em chave (S-Box parametrizada).</p>
</li>
<li>
<p>Difusão: uso de permutação fixa e dispersão via operações XOR.</p>
</li>
</ul>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"fmt"
)

// Gera uma S-Box pseudoaleatória baseada em uma chave
func generateSBox(key []byte) [256]byte {
	var sbox [256]byte
	hash := sha256.Sum256(key)
	seed := uint32(0)
	for i := 0; i &lt; 4; i++ {
		seed ^= uint32(hash[i]) &lt;&lt; (8 * i)
	}
	for i := range sbox {
		sbox[i] = byte((i*int(seed) + 31) % 256)
	}
	return sbox
}

// Confusão: aplica substituição não linear via S-Box
func confusion(input []byte, sbox [256]byte) []byte {
	out := make([]byte, len(input))
	for i, b := range input {
		out[i] = sbox[b]
	}
	return out
}

// Difusão: permutação e dispersão via XOR entre posições
func diffusion(input []byte) []byte {
	out := make([]byte, len(input))
	for i := range input {
		out[i] = input[i]
		if i &gt; 0 {
			out[i] ^= input[i-1]
		}
	}
	return out
}

func main() {
	key := []byte("chave-secreta")
	entrada := []byte("mensagem123456")

	sbox := generateSBox(key)
	c := confusion(entrada, sbox)
	d := diffusion(c)

	fmt.Printf("Original : %x\n", entrada)
	fmt.Printf("Confusão : %x\n", c)
	fmt.Printf("Difusão  : %x\n", d)
}

</code></pre>
<p>Análise do código:</p>
<p>Observe que:</p>
<ul>
<li>
<p>A função generateSBox cria uma tabela de substituição (S-Box) que introduz confusão, pois depende da chave de entrada.</p>
</li>
<li>
<p>A função diffusion implementa uma difusão simples, propagando a influência de cada byte anterior sobre o próximo com XOR.</p>
</li>
</ul>
<h2 id="considerações-finais-3"><a class="header" href="#considerações-finais-3">Considerações Finais</a></h2>
<p>A aplicação isolada de confusão e difusão permite o estudo modular de suas propriedades, sem a complexidade adicional de um esquema criptográfico completo. Shannon já antecipava que a combinação adequada dessas técnicas seria suficiente para criar sistemas resistentes à análise estatística.</p>
<p>Knuth, por sua vez, destacou que a boa aleatorização estruturada é o centro da segurança criptográfica — e que difusão e confusão são ferramentas matemáticas precisamente voltadas a esse objetivo.</p>
<p>O leitor é convidado a explorar esses conceitos com maior profundidade consultando a referência [1] e [5].</p>
<h2 id="referências-2"><a class="header" href="#referências-2">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-boxes-substituições-não-lineares-1"><a class="header" href="#s-boxes-substituições-não-lineares-1">S-Boxes: Substituições Não Lineares</a></h1>
<p>As S-Boxes (Substitution Boxes) são funções fundamentais em cifras simétricas modernas. Elas realizam substituições não lineares, introduzindo confusão no sistema criptográfico, conforme definido por Shannon [1]. Em redes de substituição-permutação (SPN) e cifras de Feistel, as S-Boxes são os principais elementos responsáveis por tornar complexa a relação entre a chave e o texto cifrado.</p>
<h2 id="definição-formal-1"><a class="header" href="#definição-formal-1">Definição Formal</a></h2>
<p>Uma S-Box é uma função</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></p>
<p>que mapeia uma entrada binária de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits para uma saída de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> bits. Quando <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, a S-Box é dita bijetiva (ou uma permutação) se cada saída for única.</p>
<p>Exemplo típico:</p>
<ul>
<li>No AES, a S-Box é uma permutação de 8 bits para 8 bits, isto é, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<p>Propriedades desejáveis:</p>
<ul>
<li>
<p>Não-linearidade alta (distância de Hamming em relação a todas funções lineares).</p>
</li>
<li>
<p>Avalanche: uma mudança de 1 bit na entrada afeta múltiplos bits da saída.</p>
</li>
<li>
<p>Resistência a diferenciais e lineares: saída deve ser estatisticamente imprevisível sob diferenças ou aproximações lineares na entrada.</p>
</li>
</ul>
<p>Métodos de construção:</p>
<p>A criação de S-Boxes pode ser feita de diferenes maneiras, dependendo do contexto e objetivos de segurança:</p>
<ol>
<li>Baseadas em estruturas algébricas</li>
</ol>
<ul>
<li>AES (Rijndael) utiliza a inversa multiplicativa no corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8665em;vertical-align:-0.1776em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5224em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1776em;"><span></span></span></span></span></span></span></span></span></span>, seguida de uma transformação afim:
<ul>
<li>Inverso: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> (com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6554em;vertical-align:-0.011em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</li>
<li>Transformação afim: multiplicação e soma sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p>Essa construção é baseada no padrão FIPS 197 [2]. e foi escolhida por sua alta não-linearidade e resistência a ataques diferenciais.</p>
<ol start="2">
<li>Baseadas em constantes (look-up fixo)</li>
</ol>
<ul>
<li>
<p>MD2 define uma S-Box de 256 bytes fixos, supostamente derivada dos dígitos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. A origem exata nunca foi publicada por Rivest, mas acredita-se que a sequência tenha sido escolhida de forma a evitar padrões evidentes [3].</p>
</li>
<li>
<p>DES usa oito S-Boxes diferentes com mapeamentos de 6 bits para 4 bits, cuidadosamente projetadas para resistir a criptoanálise diferencial (ver Coppersmith [4]).</p>
</li>
</ul>
<ol start="3">
<li>Pseudoaleatórias derivadas de chave</li>
</ol>
<ul>
<li>Em cifras modernas como Blowfish, a S-Box é preenchida dinamicamente durante a expansão da chave. Isso dificulta análise e torna a estrutura dependente da chave secreta.</li>
</ul>
<h2 id="exemplo-prático-em-go-construindo-uma-s-box-simples-1"><a class="header" href="#exemplo-prático-em-go-construindo-uma-s-box-simples-1">Exemplo prático em Go: Construindo uma S-Box simples</a></h2>
<p>Aqui, mostramos duas formas distintas de definir S-Boxes em Go:</p>
<ol>
<li>AES-like (algébrica) - inverso multiplicativo seguido de transformação afim (simplificada).</li>
<li>MD2-like (constante fixa) - look-up fixo.</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"math/bits"
)

// Exemplo simplificado de S-Box: inverso em GF(2^8) + afim (AES-like simplificada)
func simpleAffineSBox() [256]byte {
	var sbox [256]byte
	for i := 0; i &lt; 256; i++ {
		inv := inverseByte(byte(i))
		sbox[i] = inv ^ bits.RotateLeft8(inv, 1) ^ 0x63 // afim simplificada
	}
	return sbox
}

// Inverso multiplicativo em GF(2^8) com polinômio redutor x^8 + x^4 + x^3 + x + 1
func inverseByte(x byte) byte {
	if x == 0 {
		return 0
	}
	var inv byte = 1
	for i := 1; i &lt; 256; i++ {
		if byteMultiply(x, inv) == 1 {
			return inv
		}
		inv++
	}
	return 0
}

// Multiplicação em GF(2^8)
func byteMultiply(a, b byte) byte {
	var p byte = 0
	for b != 0 {
		if b&amp;1 != 0 {
			p ^= a
		}
		hi := a &amp; 0x80
		a &lt;&lt;= 1
		if hi != 0 {
			a ^= 0x1B // AES irreducible polynomial
		}
		b &gt;&gt;= 1
	}
	return p
}

// Exemplo de S-Box constante (MD2-like)
func md2SBox() [256]byte {
	return [256]byte{
		0x29, 0x2E, 0x43, 0x32, 0x8B, 0x1C, 0x1A, 0x06, 0x3F, 0x3C, 0x7F, 0x8A, 0x0E, 0x19, 0x4F, 0x43,
		// ... complete até 256 valores reais conforme tabela do MD2
	}
}

func main() {
	sbox := simpleAffineSBox()
	fmt.Printf("Exemplo de S-Box (simplificada):\n")
	for i := 0; i &lt; 16; i++ {
		fmt.Printf("%02x ", sbox[i])
	}
	fmt.Println()
}
</code></pre>
<h2 id="considerações-finais-4"><a class="header" href="#considerações-finais-4">Considerações finais</a></h2>
<p>As S-Boxes são blocos fundamentais na construção de cifras seguras. Sua estrutura influencia diretamente a resistência contra ataques diferenciais, lineares e por análise estatística. S-Boxes bem projetadas devem apresentar não-linearidade elevada e boa dispersão da entrada na saída, contribuindo para o efeito avalanche.</p>
<p>Embora possam ser fixas ou derivadas de chave, é essencial que sejam analisadas formalmente quanto às suas propriedades de segurança — algo que o projeto do AES exemplifica de forma rigorosa. Em contrapartida, designs mais antigos, como MD2, revelam escolhas empíricas, ainda que eficazes em seu tempo.</p>
<h2 id="referências-3"><a class="header" href="#referências-3">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[2] National Institute of Standards and Technology, FIPS-197: Advanced Encryption Standard (AES), 2001.</p>
<p>[3] R. Rivest, The MD2 Message-Digest Algorithm, RFC 1319, 1992.</p>
<p>[4] D. Coppersmith, The Data Encryption Standard (DES) and Its Strength Against Attacks, IBM Journal of Research and Development, 1994.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Vol. 2, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="permutações-e-trocas-1"><a class="header" href="#permutações-e-trocas-1">Permutações e Trocas</a></h1>
<p>Em cifras simétricas, a dispersão de dependências locais — fundamental para a difusão — pode ser alcançada por meio de operações lineares, como multiplicações matriciais, ou estruturais, como permutações e trocas de posição. Este tipo de transformação reorganiza os dados sem alterar seu conteúdo individual, mas com profundo impacto estatístico na propagação de alterações pela estrutura do algoritmo.</p>
<h2 id="permutações-como-mecanismo-de-difusão-1"><a class="header" href="#permutações-como-mecanismo-de-difusão-1">Permutações como mecanismo de difusão</a></h2>
<p>Uma permutação é uma bijeção sobre o conjunto de posições de bits ou bytes. Aplicada a um vetor de entrada, ela redistribui os elementos segundo uma ordem fixa ou pseudoaleatória. Embora não introduza não-linearidade, a permutação é essencial para ampliar o alcance das alterações provocadas pelas S-Boxes ou outras funções não lineares.</p>
<p>Na arquitetura de cifras modernas, as permutações são utilizadas para:</p>
<ul>
<li>
<p>Propagar a influência de bits da entrada por várias S-Boxes na rodada seguinte.</p>
</li>
<li>
<p>Impedir que padrões locais na entrada gerem padrões locais na saída.</p>
</li>
<li>
<p>Compor difusão com custo computacional baixo.</p>
</li>
</ul>
<h2 id="exemplo-em-spns-1"><a class="header" href="#exemplo-em-spns-1">Exemplo em SPNs</a></h2>
<p>No AES (FIPS-197), duas camadas implementam difusão com base em permutação:</p>
<ul>
<li><strong>ShiftRows</strong>: uma permutação de bytes por rotação de linhas.</li>
<li><strong>MixColumns</strong>: uma multiplicação linear que atua em colunas, mas combinada com ShiftRows produz difusão bidimensional.</li>
</ul>
<p>Essas operações não introduzem confusão, mas são vitais para garantir o efeito avalanche ao longo das rodadas.</p>
<h2 id="exemplo-em-feistel-1"><a class="header" href="#exemplo-em-feistel-1">Exemplo em Feistel</a></h2>
<p>Na estrutura de Feistel, usada no DES e em muitas cifras derivadas, a difusão é construída ao longo das rodadas, intercalando trocas de metades do bloco com aplicações de funções não lineares (geralmente baseadas em S-Boxes).</p>
<p>Permutações também aparecem de forma explícita:</p>
<ul>
<li>
<p>Initial Permutation (IP) e Final Permutation (FP) no DES são mapeamentos fixos de 64 bits, historicamente motivados por eficiência em hardware, mas com efeito colateral de difusão inicial e final.</p>
</li>
<li>
<p>Permutação P após a aplicação das S-Boxes na função F do DES serve para espalhar os resultados locais das substituições.</p>
</li>
</ul>
<h2 id="implementação-ilustrativa-em-go-1"><a class="header" href="#implementação-ilustrativa-em-go-1">Implementação ilustrativa em Go</a></h2>
<p>Abaixo, um exemplo de permutação simples de bytes em um vetor de 16 posições:</p>
<pre><code class="language-go">package main

import "fmt"

// Permutação fixa (exemplo artificial)
var permutation = [16]int{2, 0, 3, 1, 6, 4, 7, 5, 10, 8, 11, 9, 14, 12, 15, 13}

func permute(input []byte, p [16]int) []byte {
	out := make([]byte, len(input))
	for i := range p {
		out[i] = input[p[i]]
	}
	return out
}

func main() {
	entrada := []byte("abcdefghijklmnop")
	saida := permute(entrada, permutation)
	fmt.Printf("Original : %s\n", entrada)
	fmt.Printf("Permutada: %s\n", saida)
}
</code></pre>
<p>Esse tipo de permutação, apesar de simples, é o mecanismo base por trás de transformações como ShiftRows. A escolha da ordem é crítica: ela deve maximizar a dispersão estatística sem introduzir simetrias.</p>
<h2 id="considerações-finais-5"><a class="header" href="#considerações-finais-5">Considerações Finais</a></h2>
<p>Permutações e trocas estruturadas são ferramentas indispensáveis na construção de cifras robustas. Embora não introduzam entropia ou não-linearidade, são essenciais para distribuir os efeitos locais das S-Boxes e garantir que os princípios de difusão definidos por Shannon sejam plenamente realizados.</p>
<p>Além disso, entender como essas operações interagem com as camadas de substituição permite projetar SPNs eficientes e compreender como redes de Feistel obtêm segurança mesmo com funções internas relativamente simples.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="geradores-de-números-pseudoaleatórios-prng"><a class="header" href="#geradores-de-números-pseudoaleatórios-prng">Geradores de Números Pseudoaleatórios (PRNG)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="lfsr--linear-feedback-shift-register"><a class="header" href="#lfsr--linear-feedback-shift-register">LFSR – Linear Feedback Shift Register</a></h1>
<p>O LFSR (Registrador de Deslocamento com Realimentação Linear em português) é uma estrutura fundamental na geração de números pseudoaleatórios (PRNGs) e desempenha papel central em técnicas de criptografia de fluxo. Nesta seção vamos entender como o LFSR funciona e como ele é usado para gerar números aleatórios.</p>
<p>Ao final, implementaremos um LFSR em Go para ilustrar seu funcionamento simulando as funções srand e rand tais como as encontradas na biblioteca padrão de C. O LFSR sozinho não é um algorítmo seguro, mas é uma ferramenta útil para entender como os PRNGs funcionam.</p>
<h2 id="funcionamento-4"><a class="header" href="#funcionamento-4">Funcionamento</a></h2>
<p>Um LFSR é composto por um vetor de bits que representa o estado interno. A cada iteração, os bits do registrador são deslocados à direita, e um novo bit entra pela extremidade esquerda. Esse novo bit, chamado de feedback, é calculado usando XOR com certos bits do estado atual que chamamos de taps.</p>
<p>A escolha dos taps não é arbitrária. Eles devem corresponder a um polinômio primitivo sobre o corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, garantindo que o LFSR atinja seu período máximo, ou seja, percorra todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis (exceto o estado nulo).</p>
<h2 id="taps-e-polinômios"><a class="header" href="#taps-e-polinômios">Taps e Polinômios</a></h2>
<p>Para um LFSR de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits, os taps definem um <strong>polinômio binário</strong> na forma:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7977em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0724em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>Por exemplo, o polinômio:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>representa um LFSR de 4 bits com taps nas posições 4 e 1 (i.e. índices 3 e 0, respectivamente).</p>
<p>Se esse polinômio for <strong>primitivo</strong>, o LFSR terá <strong>período máximo</strong>, ou seja, irá percorrer todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis distintos (exceto o estado 0).</p>
<h2 id="operação-passo-a-passo"><a class="header" href="#operação-passo-a-passo">Operação Passo a Passo</a></h2>
<p>A seguir, demonstramos o funcionamento de um LFSR de 4 bits com estado inicial <code>1001</code> e taps nas posições <code>4</code> e <code>1</code> (índices 3 e 0):</p>
<ul>
<li>
<p>Passo 1</p>
<p>Estado: <code>1001</code>.</p>
<p>Feedback: <code>1 ⊕ 1 = 0</code>.</p>
<p>Novo estado: <code>0100</code>.</p>
</li>
<li>
<p>Passo 2</p>
<p>Estado: <code>0100</code>.</p>
<p>Feedback: <code>0 ⊕ 0 = 0</code>.</p>
<p>Novo estado: <code>0010</code>.</p>
</li>
<li>
<p>Passo 3</p>
<p>Estado: <code>0010</code>.</p>
<p>Feedback: <code>0 ⊕ 0 = 0</code>.</p>
<p>Novo estado: <code>0001</code>.</p>
</li>
<li>
<p>Passo 4</p>
<p>Estado: <code>0001</code>.</p>
<p>Feedback: <code>0 ⊕ 1 = 1</code>.</p>
<p>Novo estado: <code>1000</code>.</p>
</li>
<li>
<p>Passo 5</p>
<p>Estado: <code>1000</code>.</p>
<p>Feedback: <code>1 ⊕ 0 = 1</code>.</p>
<p>Novo estado: <code>1100</code>.</p>
</li>
</ul>
<p>E assim por diante.</p>
<h3 id="tabela-de-transiçãoo-de-estados"><a class="header" href="#tabela-de-transiçãoo-de-estados">Tabela de Transiçãoo de Estados</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Passo</th><th>Estado</th><th>Feedback</th><th>Novo Estado</th></tr></thead><tbody>
<tr><td>1</td><td>1001</td><td>1 ⊕ 1 = 0</td><td>0100</td></tr>
<tr><td>2</td><td>0100</td><td>0 ⊕ 0 = 0</td><td>0010</td></tr>
<tr><td>3</td><td>0010</td><td>0 ⊕ 0 = 0</td><td>0001</td></tr>
<tr><td>4</td><td>0001</td><td>0 ⊕ 1 = 1</td><td>1000</td></tr>
<tr><td>5</td><td>1000</td><td>1 ⊕ 0 = 1</td><td>1100</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<p>A operação em cada passo pode ser descrita da seguinte forma:</p>
<ol>
<li>
<p>O feedback é calculado aplicando <code>XOR</code> entre os bits nas posições definidas pelos taps. (e.g. <code>1001</code> os taps serão os bits <code>3</code> e <code>0</code>, então <code>1 XOR 1 = 0</code>)</p>
</li>
<li>
<p>O estado é deslocado uma posição à direita. (e.g. o estado <code>1001</code> ao descolar para direita se torna <code>0100</code>)</p>
</li>
<li>
<p>O <code>feedback</code> é inserido como o <strong>novo bit</strong> mais à esquerda. (e.g. o estado <code>0100</code>, já deslocado à direita, vai receber o feedback <code>0</code>)</p>
</li>
</ol>
<p>Esse processo é iterado indefinidamente, e a sequência de estados dependerá da escolha inicial da semente (estado) e dos taps. Quando os taps não forem escolhidos adequadamente, o LFSR pode entrar em ciclos curtos, ou até mesmo repetir rapidamente os estados, falhando em percorrer todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis.</p>
<h2 id="taps-que-geram-períodos-máximos"><a class="header" href="#taps-que-geram-períodos-máximos">Taps que geram períodos máximos</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Tamanho</th><th>Taps</th><th>Polinômio</th><th>Período máximo</th></tr></thead><tbody>
<tr><td>4 bits</td><td>[3, 0]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span></td></tr>
<tr><td>8 bits</td><td>[7, 5]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">255</span></span></span></span></td></tr>
<tr><td>16 bits</td><td>[15, 13]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr>
<tr><td>32 bits</td><td>[31, 21]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr>
</tbody></table>
</div>
<p>Dessa forma taps mal escolhidos podem resultar em:</p>
<ul>
<li>Períodos muito curtos</li>
<li>Ciclos triviais (repetição precoce)</li>
<li>Saídas estatisticamente fracas</li>
</ul>
<p>Por isso, os taps devem ser derivados de polinômios <strong>primitivos</strong> cuidadosamente estudados. Um polinômio primitivo é um polinômio irredutível sobre o corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, o que significa que não pode ser fatorado em polinômios de menor grau sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. [5]</p>
<h2 id="fórmula-geral"><a class="header" href="#fórmula-geral">Fórmula Geral</a></h2>
<br>
<style>
/* Estilo base para caixas */
.box {
  border: 1px solid var(--fg);
  border-left: 6px solid var(--fg);
  padding: 1rem;
  margin: 1.5rem 0;
  background-color: var(--bg);
  box-shadow: 2px 2px 6px var(--shadow);
  border-radius: 6px;
  font-size: 1.5rem;
}

/* Definição (azul adaptado) */
.box.definition {
  border-left-color: var(--primary);
}

.box.definition::before {
  content: "Definição";
  font-weight: bold;
  display: block;
  margin-bottom: 0.5rem;
  color: var(--primary);
  font-size: 1.5rem;
}

  
  </style>
<div class="box definition">
<p>O texto puro, o texto cifrado e o key stream consiste de bits individuais:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p>
<p><strong>Cifragem:</strong>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span></span></p>
<p><strong>Decifragem:</strong>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span></span></p>
</div>
<h2 id="implementações"><a class="header" href="#implementações">Implementações</a></h2>
<h3 id="gerador-de-números-pseudo-aleatórios-srand-e-rand"><a class="header" href="#gerador-de-números-pseudo-aleatórios-srand-e-rand">Gerador de números pseudo-aleatórios (srand e rand)</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
)

type PRNG struct {
	state uint8
	taps  []int
}

// inicializa com uma semente
func srand(seed uint8) *PRNG {
	return &amp;PRNG{state: seed, taps: []int{7, 5}}
}

// gera um único bit pseudo-aleatório
// é como jogar uma moeda para escolher 0 ou 1, só que deterrminístico
func (p *PRNG) nextBit() uint8 {
	var feedback uint8
	
	for _, tap := range p.taps {
		feedback ^= (p.state &gt;&gt; tap) &amp; 1
	}

	out := p.state &amp; 1

	p.state = (p.state &gt;&gt; 1) | (feedback &lt;&lt; 7)
	return out
}

// gera um número pseudo-aleatório de 8 bits
// obtido a partir de 8 chamadas de nextBit()
func (p *PRNG) rand() uint8 {
	var b uint8
	
	for i := 0; i &lt; 8; i++ {
		b |= p.nextBit() &lt;&lt; i
	}
	return b
}

func main() {

   // inicializa o gerador com uma semente
	prng := srand(0b11001010)

	fmt.Println("Gerando 10 números pseudo-aleatórios com LFSR:")
	for i := 0; i &lt; 10; i++ {
		fmt.Printf("rand() = %3d (0b%08b)\n", prng.rand(), prng.rand())
	}
}

</code></pre>
<h3 id="explicação"><a class="header" href="#explicação">Explicação</a></h3>
<p>No loop onde percorrremos os taps, o feedback é calculado aplicando XOR entre os bits nas posições definidas pelos taps. É equivalente a:</p>
<p>feedback = 0 XOR bit5 (pega o primeito tap, que sabemos que é 5)</p>
<p>feedback = bit5 XOR bit7 (pega o segundo tap, que sabemos que é 7, e faz XOR com o resultado anterior, que sabemos que é bit5)</p>
<p>O estado é atualizando da seguinte forma:</p>
<p>Desloca o estado para a direita e insere o feedback no bit mais significativo. P.ex.:</p>
<p>10000001 &gt;&gt; 1 = 01000000 (desloca o estado para a direita, perdendo o bit menos significativo e ganhando um 0 no bit mais significativo)</p>
<p>00000001 &lt;&lt; 7 = 10000000 (o feedback é sempre apenas 0 ou 1 e não precisamos fazer AND com 1, o deslocamento joga esse bit para o bit mais significativo)</p>
<p>01000000 | 10000000 = 11000000 (faz um OR bit a bit entre o estado deslocado e o feedback deslocado, e obtém o novo estado)</p>
<p>Na função rand(), o loop percorre os 8 bits do número pseudo-aleatório e obtém cada bit usando a função nextBit().</p>
<p>O OR é feito sempre entre os bits obtidos e o valor de b, que é inicializado com 0 e cada bit é deslocado para sua posição correta (0 a 7)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="lcg---linear-congruential-generator"><a class="header" href="#lcg---linear-congruential-generator">LCG - Linear Congruential Generator</a></h1>
<p>O gerador congruencial linear (LCG) é um Pseudo-Random Number Generator (PRNG) que produz uma sequência de números inteiros por meio de uma <strong>fórmula de recorrência</strong>, que define cada novo número com base no anterior.</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<p>Esta fórmula diz que, para obter o próximo valor da sequência <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, pegamos o valor atual <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, multiplicamos por um número fixo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, somamos um descolamento <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, e aplicamos o módulo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> para que o resultado fique dentro de um intervalo limitado.</p>
<p>O que significa recorrência? <strong>Recorrência</strong> é um termo matemático para uma definição que depende do próprio valor anterior. É como uma função que chamamos com os resultados anteriores, p.ex.:</p>
<pre><code class="language-go">S0 := 123456  // semente inicial
S1 := (A * S0 + B) % m
S2 := (A * S1 + B) % m
S3 := (A * S2 + B) % m
// ...
</code></pre>
<p>A sequência inteira <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span> é construída recursivamente a partir da semente inicial <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>Esse tipo de estrutura é comum em geradores determinísticos, pois com os mesmos parâmetros iniciais e a mesma semente, a sequência será sempre igual.</p>
<p>Os valores <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> são números inteiros, mas o tamanho pode variar dependendo da aplicação. Em teoria, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ou seja, um número de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> até <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. Em código, os valores são frequentemente armazenados em um tipo de dado inteiro de 32 ou 64 bits para casos simples ou em um <code>big.Int</code> para suportar números maiores (e.g. um valor com 100 bits). Às vezes, o número inteiro é dividido em bits, caso a aplicação exigir uma saída bit a bit (como no caso de construir uma key stream para cifra de fluxo).</p>
<p>Os parâmetros fixos: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> é chamado de multiplicador e controla o "rítmo" de variação da sequência.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> é chamado de incremento e adiciona uma constante a cada passo.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é chamado de módulo e define o tamanho do espaço onde os valores vivem (e.g.: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> ou <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span></span> ou <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span></span></span></span>).</li>
</ul>
<p>O módulo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, além de manter os valores dentro de um intervalo finito (e.g. entre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>) também permite operar em espaços cíclicos, como nos corpos finitos em criptografia.</p>
<p>No código, podemos implementar uma função, convenientemente chamada rand, da seguinte forma:</p>
<pre><code class="language-go">package main

type PRNG struct {
    state *big.Int // Estado atual S_i
    A     *big.Int // Multiplicador
    B     *big.Int // Incremento
    M     *big.Int // Módulo
}

func (p *PRNG) rand() *big.Int {
    p.state.Mul(p.A, p.state)      // A * S_i
    p.state.Add(p.state, p.B)      // A * S_i + B
    p.state.Mod(p.state, p.M)      // (A * S_i + B) mod m
    return new(big.Int).Set(p.state)
}

func main() {
    // Inicialização do PRNG
    A := big.NewInt(1103515245)
    B := big.NewInt(12345)
    M := big.NewInt(1 &lt;&lt; 32)

    state := big.NewInt(123456)
    prng := PRNG{state, A, B, M}

    for i := 0; i &lt; 10; i++ {
        fmt.Println(prng.rand())
    }
}
</code></pre>
<h3 id="teorema-de-hull-dobell-para-lcgs-modulares"><a class="header" href="#teorema-de-hull-dobell-para-lcgs-modulares">Teorema de Hull-Dobell (para LCGs modulares)</a></h3>
<p>Como veremos também em LFSR, é importante que um PRNG tenha um período máximo. Ou seja, depois de um certo número de iterações, a sequência deve começar a se repetir e o número de iterações deve ser o maior possível, nesse caso <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>. O <strong>Teorema de Hull-Dobell</strong> estabelece as condições necessárias e suficientes para um LCG modular ter um período máximo. Assim, para um LCG modular ter um período máximo, é necessário que:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> são coprimos (i.e. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">d</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> é divisível por todos os fatores primos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li>
<li>se <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é múltiplo de 4, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> também deve ser múltiplo de 4</li>
</ul>
<p>A seguinte, os valores clássicos em C (glibc):</p>
<pre><code class="language-c">A = 1103515245
B = 12345
M = 1 &lt;&lt; 32
</code></pre>
<p>Para criptografia, esses critérios são insuficientes, porque o LCG é linear e, como veremos, pode ser atacado mesmo que atacante conheça apenas algumas poucas saídas. Para maior segurança precisamos de:</p>
<ul>
<li>Tornar a função não linear</li>
<li>Ou esconder a saída (i.e. aplicar uma função hash sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
<li>Ou usar um gerador de números aleatórios criptograficamente seguro (CSPRNG)</li>
</ul>
<h2 id="variações-e-referências-clássicas-knuth-e-outros"><a class="header" href="#variações-e-referências-clássicas-knuth-e-outros">Variações e Referências Clássicas (Knuth e outros)</a></h2>
<p>O Gerador Congruencial Linear foi extensivamente estudado e documentado por Donald Knuth em sua obra fundamental The Art of Computer Programming, Volume 2: Seminumerical Algorithms [5]. Knuth fornece uma análise detalhada dos critérios estatísticos e estruturais que um bom gerador deve seguir, além de discutir limitações importantes como o ciclo curto, a baixa entropia de bits menos significativos e o comportamento previsível.</p>
<p>Ao longo dos anos, várias variações do LCG foram propostas para mitigar alguns desses problemas ou adaptar o algoritmo a restrições computacionais específicas. Algumas dessas variações incluem:</p>
<p>Gerador de Lehmer: também chamado de Multiplicative Congruential Generator, onde <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, ou seja, sem incremento. O foco é na escolha precisa de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>.</p>
<p>Método de Park-Miller: um caso específico do gerador de Lehmer com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16807</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. Bastante usado historicamente por seu bom desempenho e simplicidade.</p>
<p>Algoritmo de Schrage: técnica usada para evitar overflow em implementações do método de Park-Miller usando aritmética inteira. Divide o cálculo de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span> em partes menores.</p>
<p>LCGs combinados (ex: Wichmann-Hill): combinam múltiplos LCGs com diferentes parâmetros e somam as saídas para aumentar o período e melhorar propriedades estatísticas.</p>
<p>Miller’s LCG: variante pouco comum, mas citada por Knuth, com foco em evitar correlações entre bits.</p>
<p>Apesar das melhorias, todos esses métodos compartilham a característica de linearidade sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, o que os torna inadequados para aplicações criptográficas. Essa linearidade permite a reconstrução de parâmetros internos ou do estado com relativamente pouca informação (ex: alguns termos consecutivos da sequência). Por esse motivo, LCGs são aceitáveis apenas em contextos não criptográficos, como simulações estatísticas ou algoritmos probabilísticos onde segurança não é uma exigência.</p>
<h3 id="caso-de-uso-clássico-em-assembly"><a class="header" href="#caso-de-uso-clássico-em-assembly">Caso de uso clássico em Assembly</a></h3>
<pre><code class="language-asm">Obs.: Essa implementação foi usada em um jogo 
escrito em assembly é uma variação do método de
Park-Miller (LCG multiplicativo), com constantes
específicas (16807 e 2836) e otimização inspirada 
no algoritmo de Schrage para evitar overflow.                                        
                                                                                                
Esteja à vontade para converter para Go
ou outra linguagem de alto nível. 


;---------------------------------------------------------;
; Função Random.                                          ;
; Parâmetros: DWORD teto.                                 ;
; Retorno:    Retorna o némero aleatério em EAX.          ;
; Descrição:  Gera um némero aleatério.                   ;
;---------------------------------------------------------;
Random:
    PUSH EBP
    MOV EBP, ESP
    SUB ESP, 4
	
    PUSH EDX
	
    CALL [GetTickCount]
    MOV DWORD [EBP - 4], EAX
	
    XOR EDX, EDX        
    PUSH 127773
    DIV DWORD [ESP]
    PUSH EAX
    MOV EAX, 16807    
    MUL EDX
    POP EDX
    PUSH EAX        
    MOV EAX, 2836              
    MUL EDX
    POP EDX                
    SUB EDX, EAX
    MOV EAX, EDX
    MOV DWORD [EBP - 4], EDX
    PUSH DWORD [EBP + 8]
    MOV EDX, 0
    DIV DWORD [ESP]
    ADD ESP, 8
    MOV EAX, EDX
	
    POP EDX
	
    MOV ESP, EBP
    POP EBP
    RET	4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-des---simplified-des"><a class="header" href="#s-des---simplified-des">S-DES - Simplified DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-aes---simplified-aes"><a class="header" href="#s-aes---simplified-aes">S-AES - Simplified AES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minides---mini-data-encryption-standard"><a class="header" href="#minides---mini-data-encryption-standard">MiniDES - Mini Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miniaes---mini-advanced-encryption-standard"><a class="header" href="#miniaes---mini-advanced-encryption-standard">MiniAES - Mini Advanced Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minirsa---mini-rivest-shamir-e-adleman"><a class="header" href="#minirsa---mini-rivest-shamir-e-adleman">MiniRSA - Mini Rivest, Shamir e Adleman</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miniecdsa---mini-elliptic-curve-digital-signature-algorithm"><a class="header" href="#miniecdsa---mini-elliptic-curve-digital-signature-algorithm">MiniECDSA - Mini Elliptic Curve Digital Signature Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minihmac---mini-assinaturas-seguras"><a class="header" href="#minihmac---mini-assinaturas-seguras">MiniHMAC - Mini Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="bibliotecas-recomendadas"><a class="header" href="#bibliotecas-recomendadas">Bibliotecas Recomendadas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="links-e-leituras-adicionais"><a class="header" href="#links-e-leituras-adicionais">Links e Leituras Adicionais</a></h1>
<p>[1] C. E. Shannon, <em>Communication Theory of Secrecy Systems</em>, Bell System Technical Journal, 1949.</p>
<p>[2] R. L. Rivest, "The MD5 Message-Digest Algorithm," RFC 1321, Apr. 1992. [Online]. Available: https://www.rfc-editor.org/rfc/rfc1321</p>
<p>[3] National Institute of Standards and Technology (NIST), "Advanced Encryption Standard (AES)," <em>FIPS PUB 197</em>, Nov. 2001. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/197/final</p>
<p>[4] National Institute of Standards and Technology (NIST), "Data Encryption Standard (DES)," <em>FIPS PUB 46-3</em>, Oct. 1999. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/46/3/final</p>
<p>[5] D. E. Knuth, <em>The Art of Computer Programming: Volume 2, Seminumerical Algorithms</em>, 3rd ed. Boston, MA, USA: Addison-Wesley, 1997.</p>
<p>[6] C. Paar and J. Pelzl, <em>Understanding Cryptography: A Textbook for Students and Practitioners</em>, Berlin, Germany: Springer, 2010.</p>
<p>[7] R. Lidl and H. Niederreiter, <em>Introduction to Finite Fields and Their Applications</em>, Cambridge, U.K.: Cambridge University Press, 1994.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
