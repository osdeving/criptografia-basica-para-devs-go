<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jwt Go Demo</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jwt Go Demo</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64-e-codificação"><a class="header" href="#base64-e-codificação">Base64 e Codificação</a></h1>
<style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  th, td {
    border: 1px solid black;
    text-align: center;
    padding: 8px;
  }
</style>
<p>Como funciona uma codificação? Imagine que você tem uma regra que diz o seguinte: caso a entrada for 'a', então o valor será 97, caso a entrada for 'b', então o valor será 98, caso for 'c', então o valor será 99, e assim em diante. Isso é um de-para e é também conhecido como tabela ASCII e envolve outros caracteres além do alfabeto. Descrevi um tipo de codificação.</p>
<p>Base64 é uma regra de codificação (Encode) que aplicamos na entrada produzindo uma saída. Isso significa que podemos lêr a entrada em base64 e produzir uma saída decodificada ou ler uma entrada decodificada e codificar em base64, respectivamente conhecidos como Encode e Decode.</p>
<p>A diferença em relação a tabela ASCII, é que a entrada pode ser qualquer coisa e não se limita apenas a caracteres individuais. No caso do Base64, a codificação funciona agrupando a entrada em blocos de 3 bytes (24 bits) e dividindo-os em 4 grupos de 6 bits. Cada um desses grupos de 6 bits é então convertido para um caractere correspondente em uma tabela de 64 símbolos. Essa table inclui as letras maiúsculas e minúsculas do alfabeto, seguido pelos números de 0 a 9 e então por dois caracteres especiais (+ e / no Base64 padrão e _ e - no Base64URL). Quando a entrada não é um múltiplo exato de 3 bytes, a codificação adiciona um caractere de preenchimento (=) para manter a consistência.</p>
<p>No Base64, a conversão ocorre em blocos e garante que qualquer sequência de bytes possam ser representadas apenas com caracteres seguros para transporte em protocolos como e-mails (MIME), URLs e JSON. Isso torna o Base64 útil para codificar binários, imagens, chaves criptográficas e outros dados que não são diretamente representáveis como texto legível.</p>
<p>O processo inverso, conhecido como decodificação (Decode), pega uma string codificada em Base64 e reconstrói os bytes originais, revertendo a conversão de 6 bits para 8 bits e removendo qualquer padding (=) que tenha sido adicionado na codificação. Assim como podemos converter a → 97 na tabela ASCII e depois reverter 97 → a, no Base64 podemos pegar "TWFu" e recuperar "Man" ou vice-versa, a partir de "Man" obter "TWFu".</p>
<p>No entanto, é importante lembrar que Base64 não é uma criptografia, pois qualquer pessoa pode decodificá-lo facilmente. Ele é apenas um método de representação de dados que facilita o transporte e armazenamento em sistemas que não suportam caracteres binários diretamente. Nota, o Base64 aumenta o tamanho dos dados em 33% em relação ao original.</p>
<h2 id="como-funciona-na-prática"><a class="header" href="#como-funciona-na-prática">Como funciona na prática?</a></h2>
<p>Vamos supor que a entrada sera a string "Rox". Cada caractere em um computador é representado por um número inteiro conforme a tabela ASCII.</p>
<h3 id="passo-1-obter-os-valores-ascii"><a class="header" href="#passo-1-obter-os-valores-ascii">Passo 1: Obter os valores ASCII</a></h3>
<p>Primeiro, vamos converter os caracteres em seus valores numéricos:</p>
<ul>
<li>R → 82</li>
<li>o → 111</li>
<li>x → 120</li>
</ul>
<p>Agora, precisamos representar esses números em binário (base 2), pois a codificação Base64 trabalha diretamente com bits:</p>
<h3 id="passo-2-converter-os-valores-ascii-para-binário-8-bits-cada"><a class="header" href="#passo-2-converter-os-valores-ascii-para-binário-8-bits-cada">Passo 2: Converter os valores ASCII para binário (8 bits cada)</a></h3>
<ul>
<li>R (82) → 01010010</li>
<li>o (111) → 01101111</li>
<li>x (120) → 01111000</li>
</ul>
<p>Agora temos um total de 3 bytes (24 bits), que são agrupados assim:</p>
<p>01010010 01101111 01111000</p>
<h3 id="passo-3-dividir-em-blocos-de-6-bits"><a class="header" href="#passo-3-dividir-em-blocos-de-6-bits">Passo 3: Dividir em blocos de 6 bits</a></h3>
<p>O Base64 trabalha com grupos de 6 bits, então precisamos separar nossos 24 bits assim:</p>
<p>010100 100110 111101 111000</p>
<p>Agora, cada grupo de 6 bits será convertido em um decimal cujo qual representa um índice na tabela Base64.</p>
<h3 id="passo-4-converter-os-grupos-de-6-bits-para-decimal"><a class="header" href="#passo-4-converter-os-grupos-de-6-bits-para-decimal">Passo 4: Converter os grupos de 6 bits para decimal</a></h3>
<ul>
<li>010100 → 20</li>
<li>100110 → 38</li>
<li>111101 → 61</li>
<li>111000 → 56</li>
</ul>
<p>Agora, usamos a tabela Base64 para converter esses números em caracteres.</p>
<h3 id="passo-5-mapear-os-valores-na-tabela-base64"><a class="header" href="#passo-5-mapear-os-valores-na-tabela-base64">Passo 5: Mapear os valores na tabela Base64</a></h3>
<p>A tabela Base64 contém 64 caracteres indexados de 0 até 63. Essa tabela segue uma ordem específica:</p>
<ol>
<li>Letras maiúsculas (A-Z) → índices 0 a 25</li>
<li>Letras minúsculas (a-z) → índices 26 a 51</li>
<li>Números (0-9) → índices 52 a 61</li>
<li>Caracteres especiais (+ e /) → índices 62 e 63</li>
</ol>
<p>Representação em Go:</p>
<pre><code class="language-go">const base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
</code></pre>
<p>Agora, usamos essa tabela para mapear os valores 20, 38, 61 e 56:</p>
<ul>
<li>base64Table[20] → "U"</li>
<li>base64Table[38] → "m"</li>
<li>base64Table[61] → "9"</li>
<li>base64Table[56] → "4"</li>
</ul>
<p>Com isso, o texto "Rox" foi convertido para Base64 como "Um94"</p>
<h3 id="resumo"><a class="header" href="#resumo">Resumo</a></h3>
<p>1 - Convertemos os caracteres para seus valores ASCII (R = 82, o = 111, x = 120).</p>
<p>2 - Transformamos esses valores em binário (01010010 01101111 01111000).</p>
<p>3 - Dividimos em blocos de 6 bits (010100 100110 111101 111000).</p>
<p>4 - Convertemos cada grupo de 6 bits em um número decimal (20, 38, 61, 56).</p>
<p>5 - Mapeamos esses números na tabela Base64, resultando na string "Um94".</p>
<p>Bem tranquilo, certo?</p>
<h2 id="implementação-em-go"><a class="header" href="#implementação-em-go">Implementação em Go</a></h2>
<p>O maior desafio que teremos é agrupar os bits em grupos de 6 bits, pois normalmente estamos trabalhando com 8 bits (1 byte). Isso implica que, a cada 3 bytes (24 bits no total), teremos 4 grupos de 6 bits, pois 24 / 6 = 4.</p>
<hr />
<summary>Extra: Entendendo o bitwise AND
<details>
<br>
<p>Se tivermos um valor binário qualquer e aplicarmos uma máscara bit a bit (bitwise AND) com 0b111111 (0x3F em hexadecimal), conseguimos extrair exatamente 6 bits da posição desejada.</p>
<p>Isso funciona porque o operador AND (&), mantém apenas os bits onde há 1 nos dois operadores, então podemos isolar porções específicas de um número maior.</p>
<h4 id="exemplo-prático"><a class="header" href="#exemplo-prático">Exemplo prático:</a></h4>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)
</code></pre>
<p>Note que AND tem o poder de desligar o bit ou mantê-lo sem modificação.</p>
<table border="1">
  <tr>
    <th>A</th>
    <th>AND</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>AND</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>
<br>
<p>Ou seja:</p>
<ul>
<li>Se você aplicar a máscara b00000000, vai apagar tudo</li>
<li>Se você aplicar a máscara b00000001 vai apagar tudo e, para o primeiro bit, vai depender se o outro valor tem 1 ou 0: se tiver 1, ele será mantido, se tiver 0, ele apaga.</li>
</ul>
<p>Outro exemplo: pegar apenas os bits 3 e 4 de um byte qualquer</p>
<pre>
BYTE qualquer:            <span style="color:#ffcc00;">01010010</span>  (82 em decimal)
Máscara de 6 bits:        <span style="color:#00ccff;">00111111</span>  (0x3F em hexadecimal)
Resultado após AND:       <span style="color:#ff6666;">00010010</span>  (18 em decimal)
</pre>
</details>
</summary>
<hr />
<p>Podemos trabalhar diretamente com 3 bytes em um inteiro e percorrer a mensagem de entrada de 3 em 3 bytes e para cada passagem jogar os 3 bytes no inteiro e extrair os valores usando máscara de bits.</p>
<pre><code class="language-go">for i := 0; i &lt; len(input); i += 6 {
    
    blk := int32(in[i    ]) &lt;&lt; 16 | 
           int32(in[i + 1]) &lt;&lt; 8  | 
           int32(in[i + 2])

    out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)

}
</code></pre>
<hr />
<summary>Extra: Explicação do código
<details>
<br>
<p>O que foi feito?</p>
<br>
<p>Criamos um inteiro de 32 bits (int32) e jogamos os 3 bytes do input em cima dele. Para o primeiro byte (na posição i) jogamos para a esquerda 16 bits, para o segundo byte (na posição i + 1) jogamos para a esquerda 8 bits e para o terceiro byte (na posição i + 2) não precisamos jogar nada para a esquerda.</p>
<p>
Imagine que são caixas que cabem 1 byte, o inteiro possui 4 dessas caixas, então precisamos jogar o primeiro byte para a esquerda 16 bits para que ele ocupe a terceira posição, o segundo byte para a esquerda 8 bits e o terceiro byte não precisamos jogar nada para a esquerda porque vai começar no bit 0. Graficamente temos isso:</p>
<pre>
Byte i + 0 = <span style="color:#ff6666;">01101111</span>  (111 em decimal)
Byte i + 1 = <span style="color:#00ccff;">01111000</span>  (120 em decimal)
Byte i + 2 = <span style="color:#ffcc00;">01010010</span>  (82 em decimal) <br>
blk = <span style="color:lightblue"> 000000000 00000000 00000000 00000000</span><br>
Primeiro byte entra começando no bit 16
blk = <span style="color:lightblue"> 000000000<span style="color:#ffcc00;">01010010</span>00000000 00000000</span><br>
Segundo byte entra começando no bit 8
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span>00000000</span><br>
Terceiro byte entra começando no bit 0
blk = <span style="color:lightblue"> 00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Vamos em câmera lenta. Suponha que</p>
<pre>
in[i    ] = b10000000
in[i + 1] = b00000001
in[i + 2] = b00010000
</pre>
<pre><code class="language-go">blk := int32(in[i    ]) &lt;&lt; 16  // blk = 00000000_10000000_00000000_00000000
blk  |= int32(in[i + 1]) &lt;&lt; 8  // blk = 00000000_10000000_00000001_00000000
blk |= int32(in[i + 2])        // blk = 00000000_10000000_00000001_00010000
</code></pre>
<p>Ou seja, ligou o bit 32 vindo do primeiro byte (ele já estava na posição 8, deslocou 16), o bit 8 do segundo byte (estava na posição 0 e deslocou 8) e o bit 5 (estava na posição 5 do terceiro byte e não teve deslocamento).</p>
<p>Sei que vocẽ já entendeu, mas cabe lembrar que OR funciona da seguinte forma, você tem um valor qualquer com alguns bits ligados e outros não, quando você aplica o OR com outro valor, o que já existe no seu continua, o que não existe no seu, mas existe no outro cara, ele passa a existir no seu. P.ex.: o seu é b00010000 o outro cara é b00000001 agora o seu será b00010001. Veja a tabela do OR para refrescar a memória:</p>
<table border="1">
  <tr>
  <th>A</th>
  <th>OR</th>
  <th>B</th>
  <th>C</th>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>1</td>
  <td>1</td>
  </tr>
  <tr>
  <td>1</td>
  <td>OR</td>
  <td>0</td>
  <td>1</td>
  </tr>
  <tr>
  <td>0</td>
  <td>OR</td>
  <td>0</td>
  <td>0</td>
  </tr>
</table>
<br>
<p>Agora que temos os 3 bytes dentro de um único inteiro de 32 bits (blk), precisamos extrair 4 grupos de 6 bits, pois cada caractere Base64 é representado por exatamente 6 bits.</p>
<p>A extração é feita aplicando deslocamento de bits (>>) e uma máscara (& 0b00111111), que serve para zerar os bits irrelevantes e pegar exatamente os 6 bits desejados.</p>
<p>Graficamente, temos:</p>
<pre>
blk = <span style="color:lightblue">00000000</span><span style="color:#ffcc00;">01010010</span><span style="color:#00ccff;">01111000</span><span style="color:#ff6666;">01010010</span>
</pre>
<p>Agora, extraímos os grupos de 6 bits um por um:</p>
<ul>
  <li>Primeiros 6 bits: Para extrair os bits mais à esquerda, deslocamos 18 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_1 = (blk >> 18) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000000_00010010 → 000100</span>
b64_1 = <span style="color:#ffcc00;">000100</span>
</pre>
<ul>
  <li>Segundos 6 bits: Deslocamos 12 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_2 = (blk >> 12) & 0b00111111  <span style="color:darkgreen">// 00000000_00000000_00000010_01010010 → 010100</span>
b64_2 = <span style="color:#00ccff;">010100</span>
</pre>
<ul>
  <li>Terceiros 6 bits: Deslocamos 6 bits para a direita e aplicamos a máscara.</li>
</ul>
<pre>
b64_3 = (blk >> 6) & 0b00111111   <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 011110
b64_3 = <span style="color:#ff6666;">011110</span>
</pre>
<ul>
  <li>Últimos 6 bits: Não há deslocamento, apenas aplicamos a máscara.</li>
</ul>
<pre>
b64_4 = blk & 0b00111111 <span style="color:darkgreen">// 00000000_00000000_01111000_01010010 → 100010
b64_4 = <span style="color:#ff9999;">100010</span>
</pre>
<p>Agora, temos os 4 índices da tabela Base64 prontos para serem mapeados!</p>
<p>Isso significa que podemos simplesmente usar o array <code>b64</code> para obter os caracteres correspondentes, indexando diretamente com <code>b64_1</code>, <code>b64_2</code>, <code>b64_3</code> e <code>b64_4</code>.</p>
<pre>
b64_1 = <span style="color:#ffcc00;">000100</span>  (4 em decimal)  →  Índice <code>b64[4]</code>  →  <span style="color:#ffcc00;">T</span>
b64_2 = <span style="color:#00ccff;">010100</span>  (20 em decimal) →  Índice <code>b64[20]</code> →  <span style="color:#00ccff;">U</span>
b64_3 = <span style="color:#ff6666;">011110</span>  (30 em decimal) →  Índice <code>b64[30]</code> →  <span style="color:#ff6666;">e</span>
b64_4 = <span style="color:#ff9999;">100010</span>  (34 em decimal) →  Índice <code>b64[34]</code> →  <span style="color:#ff9999;">Y</span>
</pre>
<p>Ou seja, os números binários extraídos representam <strong>índices na tabela Base64</strong>, e ao acessar <code>b64[4]</code>, <code>b64[20]</code>, etc., obtemos os caracteres finais da string codificada.</p>
</details>
</summary>
<hr />
<p>Agora só precisamos lidar com casos onde o input tem menos que 3 bytes ou o input não é múltiplo de 3 bytes</p>
<pre><code class="language-go">if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)

</code></pre>
<p>
Quando a entrada nã é múltiplo de 3 significa que ao sairmos do laço principal restará 1 ou 2 bytes. A especificação do Base64 exige que tenhamos 4 grupos fechados de 6 bits, que resultam 4 caracteres da tabela. 
</p>
<p>
Quando sobrar apenas 1 byte, teremos que agrupar em blocos de 6 bits e ter um total de 4 blocos. Como obter um total de 4 blocos de 6 bits com apenas 8 bits? A especificação diz que temos que pegar os 6 bits e obter qual o valor da tabela, para os 2 bits que sobrarem colocamos zeros **à direita** para completar 6 bits e então obtemos o valor na tabela e para os dois grupos restantes simplesmente consideramos o valor '='.
</p>
<p>
Então temos que: O primeiro grupo de 6 bits do byte pega um valor normalmente da tabela, o outro valor é obtido completando os 2 bits que sobraram com quatro zeros à direita e os outros dois grupos de 6 bits consideramos o '=' para cada um.
</p>
<p>
Quando sobram 2 bytes a regra é a mesma. Isto é, dos 16 bits teremos 2 valores _cheios_ e os 4 bits que sobram recebem dois zeros à direita e, diferente do caso que sobra apenas 1 byte, nesse caso precisamos de apenas um '=' para completar o grupo de 4 valores uma vez que já temos 3 grupos prontos.
</p>
<p>
P.ex.:
</p>
<p>
Se tivermos 1 byte sobrando (A = 01000001 em binário = 65 em decimal), precismos transformar isso em 4 blocos de 6 bits. Então fazemos o seguinte:
</p>
<pre>
<span style="color:yellow">010000</span><span style="color:rebeccapurple">01</span><span style="color:red">0000</span><span style="color:lightblue">=</span><span style="color:lightgreen">=</span>
</pre>
<p>Para os dois primeiros (coincidentemente) teremos o mesmo valor na b64table ('Q') e para os outros dois teremos o '='. Assim, ficamos com</p>
<pre>
<strong>QQ==</strong>
</pre>
<p>Com isso, c código completo fica assim:</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"encoding/base64"
)

const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func Encb64(in []byte) string {
	
    var out []byte
	len := len(in)
	rem := len % 3

    for i := 0; i &lt; len - rem; i += 3 {
    
        blk := int64(in[i    ]) &lt;&lt; 16 | 
               int64(in[i + 1]) &lt;&lt; 8  | 
               int64(in[i + 2])

        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt;  6) &amp; 0b00111111],
            b64[ blk        &amp; 0b00111111],
		)
	}

	if rem == 0 {
		return string(out)
	}
    
	var blk int64 = 0

 	if rem == 1 {
        blk = int64(in[len - rem]) &lt;&lt; 16
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            '=',
            '=',
        )
    } else if rem == 2 {
        blk = int64(in[len - rem]) &lt;&lt; 16 | int64(in[len - rem + 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk &gt;&gt; 18) &amp; 0b00111111],
            b64[(blk &gt;&gt; 12) &amp; 0b00111111],
            b64[(blk &gt;&gt; 6)  &amp; 0b00111111],
            '=',
        )
    }

	return string(out)
}

func main() {
    testCases := []string{"Manaed", "1234567890"}
	
    for _, test := range testCases {
		encoded := Encb64([]byte(test))
		encondedGo := base64.StdEncoding.EncodeToString([]byte(test))
		fmt.Println("Base64 de ", test, ": ", encoded)
		fmt.Println("Base64 Go : ", test, ": ", encondedGo)
		
	}
}
</code></pre>
<p>Curiosidade: nossa versão fica alguns ms mais lenta que a versão do Go, sintam-se à vontade para estudar a versão em Go, agora poderão entender todo o código!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-e-sha-256"><a class="header" href="#hashing-e-sha-256">Hashing e SHA-256</a></h1>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<h2 id="famílias-de-algorítmos-message-digest"><a class="header" href="#famílias-de-algorítmos-message-digest">Famílias de Algorítmos Message Digest</a></h2>
<h3 id="md2"><a class="header" href="#md2">MD2</a></h3>
<p>O primeiro algorítmo que vamos discutir é conhecido como MD2, o primeiro da família MD (Message Digest) e foi desenvolvido por Ronald Rivest em 1989. Ele foi projetado especificamente para computadores de 8 bits. Apesar de ter sido uma inovação importante, o MD2 se tornou obsoleto com o tempo devido a ataques criptográficos bem-sucedidos. Suas principais características eram:</p>
<ul>
<li>Tamanho da saída: 128 bits (16 bytes)</li>
<li>Entrada de tamanho variável</li>
<li>Projetado para máquinas de 8 bits</li>
<li>Inseguro desde 2004 devido a ataques práticos</li>
<li>Lento em hardware moderno devido à otimização para 8 bits</li>
</ul>
<h4 id="como-o-md2-funciona"><a class="header" href="#como-o-md2-funciona">Como o MD2 Funciona?</a></h4>
<p>A especificação do MD2 pode ser encontrada na RFC 1319. Esse algorítmo transforma qualquer entrada em um hash de 128bits. Ele faz isso seguindo 3 etapas principais:</p>
<p>1 - Padding</p>
<p>Para garantir que o tamanho da entrada seja um múltiplo de 16 bytes, adicionamos bytes de padding no final. A regra é a seguinte:</p>
<ul>
<li>se o tamanho da mensagem já for múltiplo de 16, adicionamos 16 bytes de 0x10.</li>
<li>se falta N bytes para completar 16, adicionamos N bytes do valor N</li>
</ul>
<p>Exemplo:</p>
<pre>
Entrada original: [41 42 43] = "ABC"
Tamanho: 3 bytes
Padding necessário: 16 - 3 = 13 bytes
Resultado final: [41 42 43 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D]
</pre>
<p>2 - Checksum</p>
<p>O MD2 adiciona um checksum de 16 bytes, que é computado iterando sobre a mensagem e aplicando XOR com uma tabela de permutação.</p>
<p>Essa tabela de permutação S-box (256 valores) foi escolhida manualmente por Rivest e usada para misturar os dados.</p>
<p>A fórmula para calcular o checksum de 16 bytes é:</p>
<pre><code>checksum[j] = checksum[j] XOR S(block[i] XOR checksum[j - 1])
</code></pre>
<p>Isso adiciona o efeito de difusão na mensagem antes da fase final.</p>
<p>3 - Processamento Principal</p>
<p>Agora pegamos a mensagem + checksum e a processamos usando uma permutação de 48 bytes, misturando os blocos de 16 bytes repetidamente.</p>
<p>O buffer inicial (48 bytes) é atualizado 18 vezes para fortalecer a resistência a colisões.</p>
<p>O MD2 não usa operações de bitwise complexas como rotação, apenas XOR e tabelas de substituição são usadas.</p>
<h4 id="implementação-do-md2-em-go"><a class="header" href="#implementação-do-md2-em-go">Implementação do MD2 em Go</a></h4>
<p>A tabela S-box define os bytes que serão permutados internamente.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela de permutação S-box
var S = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	// (o restante foi omitido por brevidade, consulte a RFC 1319)
}

func MD2(input []byte) [16]byte {
	// Parte 1: Padding
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	input = append(input, padding...)

	// Parte 2: Checksum
	var checksum [16]byte
	var L byte = 0
	for i := 0; i &lt; len(input); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= S[input[i+j]^L]
			L = checksum[j]
		}
	}
	input = append(input, checksum[:]...)

	// Parte 3: Transformação Principal
	var X [48]byte
	
    for i := 0; i &lt; len(input); i += 16 {
		
        // Copia bloco para X
		copy(X[16:32], input[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[16+j] ^ X[j]
		}
		var t byte = 0

		// 18 rounds de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= S[t]
				t = X[j]
			}
			t += byte(round)
		}
	}

	// O hash final está nos primeiros 16 bytes de X
	var hash [16]byte
	
    copy(hash[:], X[:16])
	
    return hash
}

func main() {
	data := []byte("Mensagem de teste")
	hash := MD2(data)
	fmt.Printf("MD2 Hash: %x\n", hash)
}
</code></pre>
<h3 id="md4---a-evolução-do-message-digest"><a class="header" href="#md4---a-evolução-do-message-digest">MD4 - A Evolução do Message Digest</a></h3>
<p>O MD4 (Message Digest 4) foi desenvolvido por Ronald Rivest em 1990 como uma melhoria do MD2, projetado especificamente para processadores de 32 bits. Ele introduziu um novo modelo de operação baseado em três rodadas de funções não lineares, tornando-o muito mais rápido que o MD2.</p>
<p>No entanto, o MD4 é extremamente fraco e foi quebrado rapidamente. Mesmo assim, sua estrutura inspirou diretamente o MD5 e SHA-1, servindo de base para os algoritmos de hash modernos e que veremos logo mais.</p>
<h4 id="como-o-md4-funciona"><a class="header" href="#como-o-md4-funciona">Como o MD4 Funciona?</a></h4>
<p>A especificação do MD4 pode ser encontrada na RFC 1320. O algoritmo transforma qualquer entrada em um hash de 128 bits usando 3 rodadas de operações baseadas em soma modular e funções booleanas.</p>
<p>O MD4 segue 4 etapas principais:</p>
<p>1 - Padding</p>
<ul>
<li>O comprimento da mensagem é ajustado para que seja múltiplo de 512 bits (64 bytes).</li>
<li>Um bit 1 é adicionado, seguido de zeros até que faltem 64 bits para completar um bloco.</li>
<li>Os últimos 64 bits armazenam o tamanho original da mensagem (antes do padding)</li>
</ul>
<p>Exemplo:</p>
<p>Se tivermos a mensagem "abc", que tem 24 bits (3 bytes), adicionamos:</p>
<pre><code>01100001 01100010 01100011 10000000 00000000 ... (até completar 448 bits)

</code></pre>
<p>E então adicionamos os 64 bits finais contendo o tamanho da mensagem.</p>
<p>2 - Inicialização dos Registradores</p>
<p>MD4 usa quatro registradores de 32 bits, inicializados com valores fixos:</p>
<pre><code>A = 0x67452301
B = 0xEFCDAB89
C = 0x98BADCFE
D = 0x10325476

</code></pre>
<p>Esses valores são inspirados na constante da raiz quadrada de números primos.</p>
<p>3 - Processamento em 3 Rodadas</p>
<p>A mensagem é dividida em blocos de 512 bits (64 bytes), e cada bloco passa por três rodadas de operações matemáticas:</p>
<p>3.1 - Função F (AND, OR, NOT)</p>
<pre><code>F(X, Y, Z) = (X AND Y) OR (NOT X AND Z)

</code></pre>
<p>Essa função favore um dos valores (X) e ajuda na difusão.</p>
<p>3.2 - Função G (Majority Vote)</p>
<pre><code>G(X, Y, Z) = (X AND Y) OR (X AND Z) OR (Y AND Z)

</code></pre>
<p>Utiliza uma "votação" entre os três valores.</p>
<p>3.3 - Função H (XOR)</p>
<pre><code>H(X, Y, Z) = X XOR Y XOR Z

</code></pre>
<p>Mistura os bits de forma caótica.</p>
<p>Cada uma dessas funções é aplicada a cada bloco de 512 bits da mensagem, alterando os registradores A, B, C e D.</p>
<p>4 - Hash Final</p>
<p>Após todas as rodadas, os valores finais dos registradores A, B, C e D são concatenados para formar um hash de 128 bits (16 bytes).</p>
<h4 id="implementação-do-md4-em-go"><a class="header" href="#implementação-do-md4-em-go">Implementação do MD4 em Go</a></h4>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
)

func leftRotate(x uint32, n uint) uint32 {
	return (x &lt;&lt; n) | (x &gt;&gt; (32 - n))
}

// Funções F, G e H do MD4
func F(x, y, z uint32) uint32 { return (x &amp; y) | (^x &amp; z) }
func G(x, y, z uint32) uint32 { return (x &amp; y) | (x &amp; z) | (y &amp; z) }
func H(x, y, z uint32) uint32 { return x ^ y ^ z }

// Transformação principal do MD4
func md4Transform(state *[4]uint32, block []byte) {
	var X [16]uint32
	for i := 0; i &lt; 16; i++ {
		X[i] = binary.LittleEndian.Uint32(block[i*4:])
	}

	a, b, c, d := state[0], state[1], state[2], state[3]

	// Primeira rodada
	a = leftRotate(a+F(b, c, d)+X[0], 3)
	d = leftRotate(d+F(a, b, c)+X[1], 7)
	c = leftRotate(c+F(d, a, b)+X[2], 11)
	b = leftRotate(b+F(c, d, a)+X[3], 19)

	// Segunda rodada
	a = leftRotate(a+G(b, c, d)+X[0]+0x5A827999, 3)
	d = leftRotate(d+G(a, b, c)+X[4]+0x5A827999, 5)
	c = leftRotate(c+G(d, a, b)+X[8]+0x5A827999, 9)
	b = leftRotate(b+G(c, d, a)+X[12]+0x5A827999, 13)

	// Terceira rodada
	a = leftRotate(a+H(b, c, d)+X[0]+0x6ED9EBA1, 3)
	d = leftRotate(d+H(a, b, c)+X[8]+0x6ED9EBA1, 9)
	c = leftRotate(c+H(d, a, b)+X[4]+0x6ED9EBA1, 11)
	b = leftRotate(b+H(c, d, a)+X[12]+0x6ED9EBA1, 15)

	state[0] += a
	state[1] += b
	state[2] += c
	state[3] += d
}

func md4(input []byte) [16]byte {
	// Padding
	length := len(input)
	padding := []byte{0x80}
	for (len(input)+len(padding))%64 != 56 {
		padding = append(padding, 0x00)
	}

	lengthBits := make([]byte, 8)
	binary.LittleEndian.PutUint64(lengthBits, uint64(length*8))

	input = append(input, padding...)
	input = append(input, lengthBits...)

	// Inicializar registradores
	var state = [4]uint32{0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476}

	// Processar blocos de 512 bits (64 bytes)
	for i := 0; i &lt; len(input); i += 64 {
		md4Transform(&amp;state, input[i:i+64])
	}

	// Converter saída para 16 bytes
	var hash [16]byte
	for i := 0; i &lt; 4; i++ {
		binary.LittleEndian.PutUint32(hash[i*4:], state[i])
	}
	return hash
}

func main() {
	data := []byte("Mensagem de teste")
	hash := md4(data)
	fmt.Printf("MD4 Hash: %x\n", hash)
}

</code></pre>
<h4 id="ataques-contra-o-md4"><a class="header" href="#ataques-contra-o-md4">Ataques Contra o MD4</a></h4>
<p>O MD4 foi um grande avanço na época, mas também teve falhas graves de segurança. Aqui, exploramos os ataques mais relevantes que levaram à sua obsolescência.</p>
<p>1 - Ataque de Colisão (1995) - Hans Dobbertin</p>
<p>Em 1995, o criptógrafo Hans Dobbertin publicou um ataque prático contra o MD4, demonstrando que era possível encontrar colisões em alguns segundos.</p>
<p>Isso quebra a confiabilidade do algoritmo, pois qualquer atacante pode substituir um documento sem alterar seu hash.</p>
<p>Como Dobbertin quebrou o MD4?
Ele explorou fraquezas estruturais nas três rodadas do MD4, usando um método conhecido como differential cryptanalysis.</p>
<p>Ele encontrou colisões em menos de 1 minuto usando um computador comum da época!</p>
<p>2 - Ataque de Colisão Rápido (2007) - Wang et al.</p>
<p>Em 2007, Xiaoyun Wang, Hongbo Yu e Yiqun Lisa Yin aprimoraram os ataques de Dobbertin e conseguiram gerar colisões em tempo real.</p>
<p>3 - Ataque de Pré-imagem (2009)</p>
<p>Em 2009, pesquisadores mostraram que dado um hash MD4, era possível reconstruir uma entrada que produzia o mesmo valor.</p>
<p>Esse ataque é catastrófico para aplicações que dependem de integridade, como assinaturas digitais.</p>
<p>4 - Ataque a Senhas no NTLM (Windows)</p>
<p>O MD4 foi usado no NTLM (Microsoft Windows Authentication). Como os ataques de colisão e pré-imagem são rápidos, foi possível quebrar senhas NTLM em milissegundos.</p>
<h4 id="implementando-um-ataque-de-colisão-contra-md4-em-go"><a class="header" href="#implementando-um-ataque-de-colisão-contra-md4-em-go">Implementando um Ataque de Colisão Contra MD4 em Go</a></h4>
<p>Vamos gerar duas mensagens diferentes com o mesmo hash.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Simulação de colisão no MD4
func findCollision() {
	msg1 := []byte("Ataque123")
	msg2 := []byte("At4que123") // Alteração mínima

	hash1 := md4(msg1)
	hash2 := md4(msg2)

	fmt.Printf("Mensagem 1: %s\nHash 1: %x\n", msg1, hash1)
	fmt.Printf("Mensagem 2: %s\nHash 2: %x\n", msg2, hash2)

	if hash1 == hash2 {
		fmt.Println("Colisão encontrada!")
	} else {
		fmt.Println("Nenhuma colisão encontrada.")
	}
}

func main() {
	findCollision()
}

</code></pre>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hmac---assinaturas-seguras"><a class="header" href="#hmac---assinaturas-seguras">HMAC - Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografia-simétrica-vs-assimétrica"><a class="header" href="#criptografia-simétrica-vs-assimétrica">Criptografia Simétrica vs Assimétrica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-web-token-jwt"><a class="header" href="#json-web-token-jwt">JSON Web Token (JWT)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estrutura-de-um-jwt"><a class="header" href="#estrutura-de-um-jwt">Estrutura de um JWT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assinatura-e-verificação"><a class="header" href="#assinatura-e-verificação">Assinatura e Verificação</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt-expiração-e-refresh-token"><a class="header" href="#jwt-expiração-e-refresh-token">JWT Expiração e Refresh Token</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go"><a class="header" href="#exemplo-prático-com-go">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-20-e-openid-connect"><a class="header" href="#oauth-20-e-openid-connect">OAuth 2.0 e OpenID Connect</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluxo-authorization-code"><a class="header" href="#fluxo-authorization-code">Fluxo Authorization Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-credentials-e-machine-to-machine"><a class="header" href="#client-credentials-e-machine-to-machine">Client Credentials e Machine-to-Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-scopes-e-permissões"><a class="header" href="#oauth-scopes-e-permissões">OAuth Scopes e Permissões</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-1"><a class="header" href="#exemplo-prático-com-go-1">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls-e-certificados-ssl"><a class="header" href="#tls-e-certificados-ssl">TLS e Certificados SSL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="como-funciona-o-handshake-tls"><a class="header" href="#como-funciona-o-handshake-tls">Como Funciona o Handshake TLS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="certificados-e-autoridades-certificadoras"><a class="header" href="#certificados-e-autoridades-certificadoras">Certificados e Autoridades Certificadoras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cipher-suites-e-forward-secrecy"><a class="header" href="#cipher-suites-e-forward-secrecy">Cipher Suites e Forward Secrecy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exemplo-prático-com-go-2"><a class="header" href="#exemplo-prático-com-go-2">Exemplo Prático com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segurança-em-apis-rest"><a class="header" href="#segurança-em-apis-rest">Segurança em APIs REST</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="https-obrigatório"><a class="header" href="#https-obrigatório">HTTPS Obrigatório</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protegendo-endpoints-com-jwt"><a class="header" href="#protegendo-endpoints-com-jwt">Protegendo Endpoints com JWT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limiting-e-proteção-contra-dos"><a class="header" href="#rate-limiting-e-proteção-contra-dos">Rate Limiting e Proteção contra DoS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assinaturas-hmac-para-webhooks"><a class="header" href="#assinaturas-hmac-para-webhooks">Assinaturas HMAC para Webhooks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="armazenamento-seguro-de-senhas"><a class="header" href="#armazenamento-seguro-de-senhas">Armazenamento Seguro de Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bcrypt-argon2-e-pbkdf2"><a class="header" href="#bcrypt-argon2-e-pbkdf2">Bcrypt, Argon2 e PBKDF2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erros-comuns-no-hashing-de-senhas"><a class="header" href="#erros-comuns-no-hashing-de-senhas">Erros Comuns no Hashing de Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerenciamento-de-tokens-seguros"><a class="header" href="#gerenciamento-de-tokens-seguros">Gerenciamento de Tokens Seguros</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="armazenando-tokens-com-segurança"><a class="header" href="#armazenando-tokens-com-segurança">Armazenando Tokens com Segurança</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expiração-e-rotação-de-tokens"><a class="header" href="#expiração-e-rotação-de-tokens">Expiração e Rotação de Tokens</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist-de-segurança-para-apis"><a class="header" href="#checklist-de-segurança-para-apis">Checklist de Segurança para APIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criando-um-servidor-oauth2-com-go"><a class="header" href="#criando-um-servidor-oauth2-com-go">Criando um Servidor OAuth2 com Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protegendo-um-backend-com-jwt-e-tls"><a class="header" href="#protegendo-um-backend-com-jwt-e-tls">Protegendo um Backend com JWT e TLS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementando-um-webhook-seguro-com-hmac"><a class="header" href="#implementando-um-webhook-seguro-com-hmac">Implementando um Webhook Seguro com HMAC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliotecas-recomendadas"><a class="header" href="#bibliotecas-recomendadas">Bibliotecas Recomendadas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links-e-leituras-adicionais"><a class="header" href="#links-e-leituras-adicionais">Links e Leituras Adicionais</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
