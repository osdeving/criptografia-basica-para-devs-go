<!DOCTYPE HTML>
<html lang="pt_BR" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Criptografia para Desenvolvedores Go</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Criptografia para Desenvolvedores Go</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<div align="center">
<img src="assets/capa.png" width="500" />
<h1 id="fundamentos-de-criptografia-para-desenvolvedores-fundamentos-e-prática"><a class="header" href="#fundamentos-de-criptografia-para-desenvolvedores-fundamentos-e-prática"><strong>Fundamentos de Criptografia para Desenvolvedores: Fundamentos e Prática</strong></a></h1>
<h3 id="criptografia-para-desenvollvedores"><a class="header" href="#criptografia-para-desenvollvedores">Criptografia para Desenvollvedores</a></h3>
<h4 id="por-willams-santos-de-sousa"><a class="header" href="#por-willams-santos-de-sousa">por Willams Santos de Sousa</a></h4>
<hr />
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="prefácio"><a class="header" href="#prefácio">Prefácio</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="manipulação-de-dados"><a class="header" href="#manipulação-de-dados">Manipulação de Dados</a></h1>
<p>Esta seção estabelece os fundamentos práticos para entender como os dados binários são tratados internamente — ponto essencial para compreender cifras, hashes e protocolos.</p>
<p>Começaremos com uma explicação rápida sobre endianness em <strong>Endianness – Organização de Bytes na Memória</strong>, que aborda como diferentes arquiteturas armazenam inteiros e como isso afeta a interoperabilidade e o uso seguro da criptografia.</p>
<p>Em seguida, em <strong>Operadores Bitwise</strong>, exploraremos os operadores bit a bit, que são fundamentais para a construção de cifras e hashes. Mostraremos como AND, OR, XOR e deslocamentos são usados na manipulação de bits, no controle de flags e na implementação de PRNGs e mecanismos criptográficos.</p>
<p>Veremos depois, em <strong>Operações em Blocos</strong>, os modos de operação (ECB, CBC, etc.) como técnicas de controle de fluxo entre blocos de dados — uma estrutura essencial para cifras reais. Aqui a conexão com criptografia é mais acentuada, mas o foco continua sendo como manipular blocos binários de forma sistemática.</p>
<p>Na sequência, estudaremos três conceitos fundamentais para o projeto de cifras modernas: <strong>Confusão e Difusão</strong>, <strong>S-Box</strong> e <strong>Permutações e Trocas</strong>. Embora estejam mais diretamente associados ao campo da criptografia, todos eles são, na essência, formas especializadas de manipulação de dados binários. Por esse motivo, optamos por incluí-los nesta seção, mantendo a coerência conceitual com os tópicos anteriores.</p>
<blockquote>
<p>Esses conceitos serão reaproveitados ao longo do livro e servem de base para o entendimento de algoritmos criptográficos reais. O objetivo é diminuir o esforço cognitivo ao apresentar tópicos mais avançados, dando a chance do leitor se familiarizar com tópicos mais gerais envolvendo manipulação de dados.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução"><a class="header" href="#introdução">Introdução</a></h1>
<p>Antes de explorarmos algoritmos criptográficos como funções hash, cifras de bloco ou mecanismos de assinatura, é essencial compreender <strong>como os dados são representados e manipulados em baixo nível</strong>. A criptografia opera sobre sequências binárias, e muitas de suas construções dependem de operações como <strong>máscaras de bits, deslocamentos, permutações, concatenação e particionamento de blocos</strong>.</p>
<p>Esta seção reúne os fundamentos práticos que formam a base para a implementação e compreensão de algoritmos criptográficos. Embora não envolvam segurança por si só, esses conceitos estruturam a <strong>transformação e o fluxo de dados</strong>, e são usados repetidamente em construções como:</p>
<ul>
<li>
<p>Expansão e compressão de blocos (como em DES)</p>
</li>
<li>
<p>Rotação de palavras (como em SHA e AES)</p>
</li>
<li>
<p>Aplicação de máscaras e XORs (ubíquos em todas as cifras)</p>
</li>
<li>
<p>Organização de blocos e endianness (em PBKDF2, HMAC, etc.)</p>
</li>
</ul>
<p>Mesmo algoritmos clássicos, como MD2, baseiam parte de sua segurança e funcionamento em <strong>operações simples, porém precisas, sobre bytes e bits</strong>. Por isso, essa preparação técnica é indispensável para leitura crítica, implementação correta e análise de sistemas criptográficos.</p>
<p>Nos próximos tópicos, cobriremos:</p>
<ul>
<li>
<p>A ordem dos bytes na memória (<strong>endianness</strong>)</p>
</li>
<li>
<p>Os operadores de bit mais utilizados (<strong>bitwise</strong>)</p>
</li>
<li>
<p>Como manipular dados em blocos, rotacionar e reorganizar estruturas</p>
</li>
</ul>
<p>Esses conceitos serão reaproveitados ao longo de todo o conteúdo técnico do livro e facilitarão a compreensão tanto matemática quanto prática dos algoritmos, reduzindo o esforço cognitivo necessário para entender as diversas manipulações de dados.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="endianness---organização-de-bytes-na-memória"><a class="header" href="#endianness---organização-de-bytes-na-memória">Endianness - Organização de Bytes na Memória</a></h1>
<h2 id="o-que-é-endianness"><a class="header" href="#o-que-é-endianness">O que é Endianness?</a></h2>
<p><strong>Endianness</strong> refere-se à ordem na qual os bytes de uma palavra multibyte (como <code>int32</code>, <code>uint64</code>, etc.) são armazenados na memória. Essa ordem pode variar entre arquiteturas e afeta diretamente a forma como os dados binários são interpretados em operações de leitura, escrita, serialização e comunicação entre sistemas.</p>
<p>Existem dois modelos principais: <strong>Little-endian</strong> e <strong>Big-endian</strong>.</p>
<h2 id="little-endian"><a class="header" href="#little-endian">Little-endian</a></h2>
<p>Nesse modelo, o <strong>byte menos significativo</strong> (<em>LSB – Least Significant Byte</em>) é armazenado primeiro, no menor endereço de memória. Suponha que o valor <code>0x12345678</code> (em hexadecimal) seja armazenado em 4 bytes. A ordem de armazenamento será:</p>
<div class="table-wrapper"><table><thead><tr><th>Endereço</th><th>Byte</th></tr></thead><tbody>
<tr><td>0x1000</td><td>0x78</td></tr>
<tr><td>0x1001</td><td>0x56</td></tr>
<tr><td>0x1002</td><td>0x34</td></tr>
<tr><td>0x1003</td><td>0x12</td></tr>
</tbody></table>
</div>
<h2 id="big-endian"><a class="header" href="#big-endian">Big-endian</a></h2>
<p>Neste modelo, o <strong>byte mais significativo</strong> (<em>MSB – Most Significant Byte</em>) é armazenado primeiro. Para o mesmo valor <code>0x12345678</code>, teríamos:</p>
<div class="table-wrapper"><table><thead><tr><th>Endereço</th><th>Byte</th></tr></thead><tbody>
<tr><td>0x1000</td><td>0x12</td></tr>
<tr><td>0x1001</td><td>0x34</td></tr>
<tr><td>0x1002</td><td>0x56</td></tr>
<tr><td>0x1003</td><td>0x78</td></tr>
</tbody></table>
</div>
<h2 id="implementação-em-go"><a class="header" href="#implementação-em-go">Implementação em Go</a></h2>
<p>Vamos verificar a ordem dos bytes em memória e converter entre endiannesses.</p>
<h3 id="detectando-o-endianness-do-sistema"><a class="header" href="#detectando-o-endianness-do-sistema">Detectando o endianness do sistema</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
	"unsafe"
)

func main() {
	var i int32 = 0x01020304
	ptr := (*[4]byte)(unsafe.Pointer(&amp;i))

	if ptr[0] == 0x04 {
		fmt.Printf("Primeiro byte é %v → sistema é Little-endian (ex: x86)\n", ptr[0])
	} else {
		fmt.Printf("Primeiro byte é %v → sistema é Big-endian\n", ptr[0])
	}
}
</code></pre>
<p>Saída esperada:</p>
<pre><code>Primeiro byte é 4 → sistema é Little-endian (ex: x86)
</code></pre>
<h3 id="conversão-explícita-usando-o-pacote-encodingbinary"><a class="header" href="#conversão-explícita-usando-o-pacote-encodingbinary">Conversão explícita usando o pacote encoding/binary</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
	"unsafe"
)

func main() {
	var i uint32 = 0x01020304
	b := make([]byte, 4)

	binary.BigEndian.PutUint32(b, i)
	fmt.Printf("Big-endian: % x\n", b)

	binary.LittleEndian.PutUint32(b, i)
	fmt.Printf("Little-endian: % x\n", b)
}
</code></pre>
<p>Saída esperada:</p>
<pre><code>Big-endian:    01 02 03 04
Little-endian: 04 03 02 01

</code></pre>
<h2 id="considerações"><a class="header" href="#considerações">Considerações</a></h2>
<p>Saber lidar com endianness é fundamental ao manipular dados binários em protocolos, arquivos binários, criptografia ou comunicação entre sistemas heterogêneos. Por exemplo:</p>
<ul>
<li>
<p>Algoritmos como <strong>SHA</strong> e <strong>MD5</strong> especificam explicitamente a ordem dos bytes em suas operações internas.</p>
</li>
<li>
<p>Protocolos de rede, como <strong>TCP/IP</strong>, utilizam o modelo <strong>big-endian</strong>, também chamado de <em>network byte order</em>.</p>
</li>
</ul>
<p>Arquiteturas modernas como x86 e x86-64 (Intel/AMD) adotam o modelo little-endian como padrão. Isso significa que o byte menos significativo de uma palavra é armazenado no menor endereço de memória. Essa decisão de projeto afeta diretamente a forma como inteiros são representados internamente e exige atenção ao manipular dados provenientes de ambientes que utilizam big-endian, como redes ou formatos binários padronizados.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operadores-bitwise"><a class="header" href="#operadores-bitwise">Operadores Bitwise</a></h1>
<h2 id="o-que-são-operadores-bit-a-bit"><a class="header" href="#o-que-são-operadores-bit-a-bit">O que são operadores bit a bit?</a></h2>
<p>Operadores bitwise (bit a bit) são operadores que atuam diretamente sobre os bits de inteiros binários. São fundamentais em implementações de algoritmos criptográficos, protocolos binários, manipulação de flags e otimizações de espaço e tempo.</p>
<p>Ao contrário dos operadores aritméticos tradicionais <code>(+, -, *, /)</code>, operadores bitwise operam posição a posição, diretamente sobre os bits das representações binárias dos operandos.</p>
<h2 id="operadores-fundamentais"><a class="header" href="#operadores-fundamentais">Operadores Fundamentais</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operador</th><th>Nome</th><th>Descrição</th></tr></thead><tbody>
<tr><td>&amp;</td><td>AND</td><td>Retorna 1 se ambos os bits forem 1.</td></tr>
<tr><td>|</td><td>OR</td><td>Retorna 1 se pelo menos um dos bits é 1.</td></tr>
<tr><td>^</td><td>XOR</td><td>Exclusivo: Retorna 1 se exatamente um dos bits é 1.</td></tr>
<tr><td>~</td><td>NOT</td><td>Inverte todos os bits.</td></tr>
<tr><td>&amp;^</td><td>AND NOT (Go)</td><td>Zera os bits do primeiro operando que forem 1 no segundo operando.</td></tr>
<tr><td>&lt;&lt;</td><td>Deslocamento à esquerda</td><td>Desloca os bits n posições à esquerda. (equivalente a multiplicar por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
<tr><td>&gt;&gt;</td><td>Deslocamento à direita</td><td>Desloca os bits n posições à direita. (equivalente a dividir por <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</td></tr>
</tbody></table>
</div>
<p>A tabela a seguir ilustra como os operadores bitwise atuam sobre valores binários. Os exemplos utilizam inteiros de 8 bits para facilitar a visualização:</p>
<div class="table-wrapper"><table><thead><tr><th>Expressão</th><th>Operação</th><th>Resultado Binário</th><th>Resultado Decimal</th></tr></thead><tbody>
<tr><td><code>0b1100 &amp; 0b1010</code></td><td>AND</td><td><code>0b1000</code></td><td><code>8</code></td></tr>
<tr><td><code>0b1100 | 0b1010</code></td><td>OR</td><td><code>0b1110</code></td><td><code>14</code></td></tr>
<tr><td><code>0b1100 ^ 0b1010</code></td><td>XOR</td><td><code>0b0110</code></td><td><code>6</code></td></tr>
<tr><td><code>^0b1100</code></td><td>NOT (unário)</td><td><code>0b...11110011</code>¹</td><td>depende do tipo</td></tr>
<tr><td><code>0b0001 &lt;&lt; 2</code></td><td>Shift à esquerda</td><td><code>0b0100</code></td><td><code>4</code></td></tr>
<tr><td><code>0b1000 &gt;&gt; 2</code></td><td>Shift à direita</td><td><code>0b0010</code></td><td><code>2</code></td></tr>
<tr><td><code>0b1111 &amp;^ 0b0101</code></td><td>AND NOT (Go)</td><td><code>0b1010</code>²</td><td><code>10</code></td></tr>
</tbody></table>
</div>
<p>¹ Em Go, o operador <code>^</code> representa o NOT unário. O resultado depende do tipo da variável (<code>uint8</code>, <code>int</code>, etc.). Por exemplo, <code>^uint8(0b1100)</code> resulta em <code>0b11110011</code> (243 decimal).</p>
<p>² O operador <code>&amp;^</code> é específico da linguagem Go e realiza uma operação conhecida como "bit clear". Ele equivale a <code>a &amp; (~b)</code>, ou seja, <strong>faz um NOT bit a bit do segundo operando e aplica AND com o primeiro</strong>. Em C, essa operação seria expressa como <code>a &amp; (~b)</code>.</p>
<h2 id="exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc"><a class="header" href="#exemplo-prático-1-isolando-bits-com-máscaras-base64-sha-etc">Exemplo prático 1: isolando bits com máscaras (Base64, SHA, etc)</a></h2>
<p>Uma das aplicações mais comuns do operador AND (<code>&amp;</code>) é a extração de porções específicas de um número binário, por meio de máscaras. Isso é amplamente usado em codificações como Base64, compressão, protocolos e algoritmos criptográficos.</p>
<p>Suponha que você queira extrair os 6 bits menos significativos de um byte. Para isso, podemos usar uma máscara <code>0b00111111</code>, que equivale a <code>0x3F</code> em hexadecimal. Veja:</p>
<pre><code>BYTE qualquer:            01010010  (82 em decimal)
Máscara de 6 bits:        00111111  (0x3F em hexadecimal)
Resultado após AND:       00010010  (18 em decimal)

</code></pre>
<p>O operador <code>&amp;</code> preserva apenas os bits em que ambos os operandos são 1. Portanto, ele serve como uma forma seletiva de “manter” ou “zerar” bits.</p>
<p><strong>Tabela verdade para <code>AND</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>AND</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>&amp;</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>&amp;</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>&amp;</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>Com isso, chegamos à conclusão de que:</p>
<ul>
<li>
<p>Uma máscara 0b00000000 apaga todos os bits.</p>
</li>
<li>
<p>Uma máscara 0b00000001 testa apenas o bit menos significativo.</p>
</li>
<li>
<p>Para extrair bits específicos, basta construir uma máscara com 1s nas posições desejadas.</p>
</li>
</ul>
<p>Por exemplo, podemos extrair os bits 3 e 4 de um byte da seguinte forma:</p>
<pre><code>BYTE qualquer:            01010010  (82)
Máscara:                  00011000  (0x18)
Resultado após AND:       00010000  (16)
</code></pre>
<h2 id="exemplo-prático-2-usando-bits-como-flags"><a class="header" href="#exemplo-prático-2-usando-bits-como-flags">Exemplo prático 2: usando bits como flags</a></h2>
<p>Uma aplicação prática de operadores bitwise é o uso de flags, onde cada bit representa uma característica binária (ligado ou desligado). Esse padrão é comum em linguagens como C, Go e Rust, e em estruturas compactas de controle, como permissões ou estados.</p>
<p>Abaixo, usaremos o contexto do anime Naruto para ilustrar como os operadores bitwise podem ser usados para representar e manipular características das personagens.</p>
<h3 id="definindo-estilos-de-um-ninja"><a class="header" href="#definindo-estilos-de-um-ninja">Definindo estilos de um ninja</a></h3>
<p>Abaixo, cada constante representa uma posição de bit única:</p>
<pre><code class="language-go">type NinjaRank uint8

const (
	Genin     NinjaRank = 1 &lt;&lt; iota // 00000001
	Chunin                          // 00000010
	Jounin                          // 00000100
	Ambu                            // 00001000
	Sannin                          // 00010000
	Kage                            // 00100000
	Sage                            // 01000000
	Jinchuriki                      // 10000000
)
</code></pre>
<h4 id="combinando-características-com-or-"><a class="header" href="#combinando-características-com-or-">Combinando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto  := Genin  | Sage   | Jinchuriki       // 10100001
tsunade := Jounin | Sannin | Kage             // 00110100
kakashi := Jounin | Ambu                      // 00001100
</code></pre>
<p><strong>Tabela verdade para <code>OR</code></strong></p>
<p>Para entender como a combinação funciona bit a bit, veja a tabela verdade da operação OR:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>OR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>|</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>|</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>O operador <code>|</code> retorna <code>1</code> sempre que pelo menos um dos bits for <code>1</code>. Por isso ele é ideal para adicionar flags a uma variável sem interferir nos bits já definidos.</p>
<h4 id="testando-características-com-and-"><a class="header" href="#testando-características-com-and-">Testando características com AND (<code>&amp;</code>)</a></h4>
<pre><code class="language-go">if naruto &amp; Genin == Genin {
	fmt.Println("Naruto é Genin.")
}
</code></pre>
<h4 id="adicionando-características-com-or-"><a class="header" href="#adicionando-características-com-or-">Adicionando características com OR (<code>|</code>)</a></h4>
<pre><code class="language-go">naruto |= Jounin // promove Naruto para Jounin
</code></pre>
<h4 id="removendo-características-com-and-not-"><a class="header" href="#removendo-características-com-and-not-">Removendo características com AND NOT (<code>&amp;^</code>)</a></h4>
<pre><code class="language-go">kakashi &amp;^= Kage // remove o status de Kage de Kakashi
</code></pre>
<p><strong>Tabela verdade para <code>NOT</code></strong></p>
<p>O operador NOT (<code>~</code>) inverte cada bit individualmente:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>NOT</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>~</td><td>0</td></tr>
<tr><td>0</td><td>~</td><td>1</td></tr>
</tbody></table>
</div>
<h2 id="exemplo-prático-3-usando-xor-em-prngs-e-criptografia"><a class="header" href="#exemplo-prático-3-usando-xor-em-prngs-e-criptografia">Exemplo prático 3: usando <code>XOR</code> em PRNGs e criptografia</a></h2>
<p>O operador XOR (<code>^</code>) é um dos mais utilizados em criptografia moderna, principalmente por suas propriedades de reversibilidade e difusão controlada. Ele também aparece como base de muitos geradores de números pseudoaleatórios (PRNGs), como a família <strong>Xorshift</strong>.</p>
<p>A propriedade central do <code>XOR</code> é:</p>
<pre><code>A ^ A = 0        (auto-cancelamento)
A ^ 0 = A        (identidade)
A ^ B ^ B = A    (reversível)
</code></pre>
<p>Essas propriedades tornam o <code>XOR</code> ideal para cifragem, embaralhamento e geração determinística de entropia.</p>
<h3 id="xorshift-simplificado"><a class="header" href="#xorshift-simplificado">Xorshift simplificado</a></h3>
<p>A seguir, um PRNG de 32 bits usando apenas <code>XOR</code> e <code>shifts</code>:</p>
<pre><code class="language-go">package main

import "fmt"

func xorshift32(x uint32) uint32 {
	x ^= x &lt;&lt; 13
	x ^= x &gt;&gt; 17
	x ^= x &lt;&lt; 5
	return x
}

func main() {
	seed := uint32(123456789)
	for i := 0; i &lt; 5; i++ {
		seed = xorshift32(seed)
		fmt.Printf("Valor %d: %032b\n", i+1, seed)
	}
}
</code></pre>
<p>Esse gerador, embora simples, é capaz de produzir uma sequência pseudoaleatória com boa dispersão de bits. Ele é construído exclusivamente com operadores <code>^</code>, <code>&lt;&lt;</code> e <code>&gt;&gt;</code>.</p>
<p><strong>Tabela verdade para <code>XOR</code></strong></p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>XOR</th><th>B</th><th>Resultado</th></tr></thead><tbody>
<tr><td>1</td><td>^</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>^</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>^</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>^</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>A operação retorna <code>1</code> apenas quando os bits são diferentes. Por isso, é chamada de <em>OU exclusivo</em> (exclusive OR).</p>
<h2 id="exemplo-prático-4-deslocamento-de-bits--e-"><a class="header" href="#exemplo-prático-4-deslocamento-de-bits--e-">Exemplo prático 4: deslocamento de bits (<code>&lt;&lt;</code> e <code>&gt;&gt;</code>)</a></h2>
<p>Os operadores de deslocamento <code>&lt;&lt;</code> (shift à esquerda) e <code>&gt;&gt;</code> (shift à direita) são amplamente utilizados em operações de dispersão, ajustes de bits e estruturação de dados binários. Eles são comuns em geradores pseudoaleatórios, cifras e funções de hash.</p>
<p>A operação <code>x &lt;&lt; n</code> desloca os bits de <code>x</code> para a esquerda em <code>n</code> posições, preenchendo com <code>0</code> à direita. Já <code>x &gt;&gt; n</code> desloca os bits para a direita, preenchendo com <code>0</code> à esquerda (em inteiros sem sinal).</p>
<h3 id="aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register"><a class="header" href="#aplicação-prática-passo-de-um-lfsr-linear-feedback-shift-register">Aplicação prática: passo de um LFSR (Linear Feedback Shift Register)</a></h3>
<p>Sem entrar nos detalhes do algoritmo agora, podemos observar um exemplo de uso de deslocamento para atualizar um valor de estado:</p>
<pre><code class="language-go">package main

import "fmt"

func stepLFSR(state uint8) uint8 {
	feedback := ((state &gt;&gt; 0) ^ (state &gt;&gt; 2)) &amp; 1
	state = (state &gt;&gt; 1) | (feedback &lt;&lt; 7)
	return state
}

func main() {
	state := uint8(0b10010010)
	for i := 0; i &lt; 5; i++ {
		state = stepLFSR(state)
		fmt.Printf("Estado %d: %08b\n", i+1, state)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li>
<p>Um bit de realimentação é calculado via <code>XOR</code> de dois bits do estado.</p>
</li>
<li>
<p>O estado é deslocado para a direita <code>(&gt;&gt; 1)</code>, descartando o LSB.</p>
</li>
<li>
<p>O novo bit de feedback é colocado na posição mais à esquerda via feedback <code>&lt;&lt; 7</code>.</p>
</li>
</ul>
<p>Embora não exista uma tabela verdade para o deslocamento, segue um exemplo visual do deslocamento:</p>
<div class="table-wrapper"><table><thead><tr><th>Operação</th><th>Entrada</th><th>Resultado</th><th>Observação</th></tr></thead><tbody>
<tr><td><code>x &lt;&lt; 1</code></td><td><span style="color:#ff6666;">0</span>1010010</td><td>1010010<span style="color:#66ccff;">0</span></td><td>Perde o MSB, ganha 0 no LSB</td></tr>
<tr><td><code>x &gt;&gt; 1</code></td><td>0101001<span style="color:#ff6666;">0</span></td><td><span style="color:#66ccff;">0</span>0101001</td><td>Perde o LSB, ganha 0 no MSB</td></tr>
<tr><td><code>x &gt;&gt; 3</code></td><td>111<span style="color:#ff6666;">00000</span></td><td><span style="color:#66ccff;">000</span>11100</td><td>Bits deslizam 3 casas à direita</td></tr>
</tbody></table>
</div>
<p>Esse comportamento é determinístico, barato computacionalmente e essencial para muitas transformações em cifras e PRNGs.</p>
<h2 id="importância-em-criptografia"><a class="header" href="#importância-em-criptografia">Importância em Criptografia</a></h2>
<p>Operadores bitwise são usados constantemente em algoritmos criptográficos. Exemplos:</p>
<ul>
<li>
<p>O <code>XOR</code> (<code>^</code>) é a operação mais usada em cifras de fluxo e blocos — por exemplo, no modo CTR ou no cálculo de paridade.</p>
</li>
<li>
<p>Cifras de fluxo: cada byte da mensagem é combinado com um byte do keystream usando <code>XOR</code>.</p>
</li>
<li>
<p>Funções hash: o <code>XOR</code> é usado para compressão, mistura e difusão de bits internos.</p>
</li>
<li>
<p><code>AND</code>, (<code>&amp;</code>) <code>OR</code> (<code>|</code>), e <code>NOT</code> (<code>~</code>) são usados em compressão de mensagens, máscaras, e manipulação de estruturas internas como as de <strong>SHA-2</strong>.</p>
</li>
<li>
<p>Shifts (<code>&lt;&lt;, &gt;&gt;</code>) implementam rotações e misturas, fundamentais em <strong>S-Boxes</strong> e funções de dispersão.</p>
</li>
</ul>
<h2 id="considerações-1"><a class="header" href="#considerações-1">Considerações</a></h2>
<p>Dominar os operadores bitwise é essencial para compreender o funcionamento interno de muitos algoritmos criptográficos. Além disso, esse tipo de manipulação é eficiente, compacta e amplamente utilizada em implementações de baixo nível, seja em bibliotecas de segurança, protocolos ou microcontroladores.</p>
<p>Nos próximos tópicos, aplicaremos esses conceitos na manipulação de blocos de dados, operações estruturais e transformação binária direta.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operações-em-blocos"><a class="header" href="#operações-em-blocos">Operações em Blocos</a></h1>
<h2 id="o-que-são-modos-de-operação"><a class="header" href="#o-que-são-modos-de-operação">O que são modos de operação?</a></h2>
<p>Muitos algoritmos lidam com blocos de dados de tamanho fixo, como 64 ou 128 bits. Quando a entrada é maior que um único bloco, é necessário dividir os dados e aplicar transformações <strong>bloco a bloco</strong>, seguindo um <strong>modo de operação</strong>.</p>
<p>Embora esses modos sejam usados em contextos criptográficos, o objetivo aqui é entender <strong>como os dados são processados tecnicamente</strong>, sem considerar a lógica de cifra. Vamos nos concentrar em:</p>
<ul>
<li>Como os blocos são encadeados</li>
<li>Qual a dependência entre entradas e saídas</li>
<li>Como o estado interno evolui</li>
<li>Como entrada, saída e IV interagem</li>
</ul>
<p>Para fins ilustrativos, faremos comentários como <code>// aplicar cifra aqui</code>, mas <strong>não implementaremos cifra real nesta seção</strong>.</p>
<h2 id="divisão-em-blocos"><a class="header" href="#divisão-em-blocos">Divisão em blocos</a></h2>
<p>Antes de aplicar qualquer modo de operação, os dados precisam ser divididos em blocos de tamanho fixo. Se os dados não são múltiplo do tamanho do bloco, algum tipo de preenchimento (padding) será necessário. Veremos mais sobre padding em uma seção posterior, em especial quando estivermos falando sobre Base64.</p>
<p>Exemplo com blocos de 8 bytes:</p>
<pre><code>Entrada (24 bytes): "ExemploDeTextoCriptografado"

Blocos:
B1 = "ExemploD"
B2 = "eTextoCr"
B3 = "iptograf"
B4 = "ado\x00\x00\x00" // padding se aplicado
</code></pre>
<p>A seguir, vamos examinar os principais modos de operação: ECB, CBC, CFB, OFB, CTR e outros opcionais.</p>
<h2 id="ecb--electronic-codebook"><a class="header" href="#ecb--electronic-codebook">ECB — Electronic Codebook</a></h2>
<p>O modo ECB é o mais simples de todos: cada bloco de entrada é processado <strong>de forma independente</strong> dos demais. Não há encadeamento, nem dependência de bloco anterior. Por isso, é possível aplicar a transformação a todos os blocos <strong>em paralelo</strong>.</p>
<p>Uma analogia útil é pensar em ECB como um carimbo: para cada pedaço do texto, aplica-se sempre o mesmo molde. Se dois blocos forem iguais, o resultado será o mesmo.</p>
<p>Apesar de sua simplicidade, esse comportamento pode expor padrões quando blocos repetidos resultam em saídas repetidas — por isso o ECB é desaconselhado em aplicações criptográficas. Mas como modelo de operação, é útil para entender a base dos modos.</p>
<h3 id="funcionamento"><a class="header" href="#funcionamento">Funcionamento</a></h3>
<pre><code>Entrada:     B1   B2   B3   B4
             |    |    |    |
             v    v    v    v
Saída:      C1   C2   C3   C4

// Cada Ci = cifra(Bi)
</code></pre>
<h3 id="implementação-simulada-em-go"><a class="header" href="#implementação-simulada-em-go">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func ecb(blocks []string) []string {
	out := make([]string, len(blocks))
	for i, b := range blocks {
		// Simulando uma "cifra" com reverso de string
		out[i] = reverse(b) // aplicar cifra real aqui
	}
	return out
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	saida := ecb(blocos)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Esse código demonstra a ideia de que cada bloco é transformado isoladamente. A função <code>reverse</code> simula uma transformação sem depender de contexto.</p>
<p>Nos próximos modos, veremos como introduzir <strong>estado</strong> e <strong>encadeamento</strong> entre os blocos.</p>
<h2 id="cbc--cipher-block-chaining"><a class="header" href="#cbc--cipher-block-chaining">CBC — Cipher Block Chaining</a></h2>
<p>O modo CBC introduz encadeamento entre os blocos de dados. Aqui, cada bloco de entrada é combinado (via <code>XOR</code>) com o bloco de saída anterior <strong>antes</strong> da transformação ser aplicada. Isso garante que blocos idênticos de entrada não gerem saídas idênticas, desde que a inicialização seja diferente.</p>
<p>O primeiro bloco é combinado com um <strong>vetor de inicialização</strong>  (<em>IV - Initialization Vector</em> ), que deve ser único e imprevisível para cada mensagem.</p>
<p>Pense em CBC como uma corrente: cada elo (bloco) depende do anterior. Se você mudar um elo, o restante da corrente será alterado. Esse encadeamento dá mais segurança estrutural ao fluxo de blocos.</p>
<h3 id="funcionamento-1"><a class="header" href="#funcionamento-1">Funcionamento</a></h3>
<pre><code>Entrada:     B1   B2   B3   B4
              |    |    |    |
IV ---&gt; XOR   |    |    |    |
        v     v    v    v    v
      cifra  XOR  XOR  XOR  ...
        |     |    |    |    |
       C1 -&gt; C2 -&gt; C3 -&gt; C4

// C1 = cifra(B1 ⊕ IV)
// C2 = cifra(B2 ⊕ C1)
// C3 = cifra(B3 ⊕ C2)
// C4 = cifra(B4 ⊕ C3)
</code></pre>
<h3 id="implementação-simulada-em-go-1"><a class="header" href="#implementação-simulada-em-go-1">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func cbc(blocks []string, iv string) []string {
	out := make([]string, len(blocks))
	prev := iv
	for i, b := range blocks {
		mix := xor(b, prev)
		out[i] = reverse(mix) // aplicar cifra real aqui
		prev = out[i]         // saída vira entrada para o próximo XOR
	}
	return out
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678" // mesmo tamanho de bloco
	saida := cbc(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Aqui, usamos uma função <code>xor</code> simples para combinar blocos. A função <code>reverse</code>, como antes, simula a aplicação de uma cifra. O encadeamento é visível no uso da variável <code>prev</code>, que propaga o resultado entre os blocos.</p>
<p>No próximo modo, veremos como esse encadeamento pode ser reorganizado para permitir recuperação de dados em tempo real.</p>
<h1 id="cfb--cipher-feedback"><a class="header" href="#cfb--cipher-feedback">CFB — Cipher Feedback</a></h1>
<p>O modo CFB transforma uma cifra de bloco em um sistema que se comporta como uma cifra de fluxo. Diferente do ECB e CBC, o CFB permite operar em unidades menores que o bloco (como bytes ou bits), o que é útil para aplicações onde os dados não chegam em blocos completos.</p>
<p>Apesar de utilizar uma cifra de bloco internamente, o que realmente é cifrado é o <strong>vetor de realimentação</strong>. Esse vetor é processado com a cifra, e o resultado é combinado (via XOR) com o bloco ou byte de entrada para gerar a saída.</p>
<h3 id="funcionamento-versão-em-blocos-inteiros"><a class="header" href="#funcionamento-versão-em-blocos-inteiros">Funcionamento (versão em blocos inteiros)</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV -----&gt; cifra     |      |      |
           |         |      |      |
           v         v      v      v
          XOR       XOR   XOR   XOR
           |         |      |      |
          C1  ---&gt;  C2 -&gt;  C3 -&gt;  C4

// C1 = P1 ⊕ cifra(IV)
// C2 = P2 ⊕ cifra(C1)
// C3 = P3 ⊕ cifra(C2)
// C4 = P4 ⊕ cifra(C3)
</code></pre>
<p>Diferente do CBC, a cifra é aplicada sobre a saída anterior, não sobre a entrada. Isso permite que a cifra seja usada como um gerador de fluxo pseudoaleatório que é então combinado com os dados reais.</p>
<h3 id="implementação-simulada-em-go-2"><a class="header" href="#implementação-simulada-em-go-2">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func cfb(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	estado := iv
	for i, p := range entrada {
		keystream := reverse(estado) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
		estado = saida[i] // realimentado com saída
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678"
	saida := cfb(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li><code>reverse</code> representa a cifra aplicada sobre o estado interno</li>
<li><code>estado</code> é atualizado com a saída anterior, simulando o feedback</li>
<li><code>xor</code> combina a saída da cifra com o bloco de entrada</li>
</ul>
<p>Nos modos seguintes, veremos como separar o fluxo gerado da entrada original (OFB) e como introduzir contadores (CTR).</p>
<h1 id="ofb--output-feedback"><a class="header" href="#ofb--output-feedback">OFB — Output Feedback</a></h1>
<p>O modo OFB (Output Feedback) é semelhante ao CFB, mas com uma diferença importante: o <strong>vetor de realimentação é atualizado independentemente da entrada</strong>. Isso significa que o fluxo pseudoaleatório gerado pela cifra é completamente dissociado do texto de entrada, permitindo paralelismo na geração e reutilização do keystream.</p>
<p>Na prática, o OFB transforma uma cifra de bloco em uma cifra de fluxo pura, onde o texto de entrada é combinado com uma sequência pseudoaleatória de bits gerados iterativamente a partir do IV.</p>
<h3 id="funcionamento-2"><a class="header" href="#funcionamento-2">Funcionamento</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV -----&gt; cifra ---&gt; cifra ---&gt; cifra ---&gt;
              |       |       |      |
              v       v       v      v
            XOR     XOR     XOR    XOR
              |       |       |      |
             C1      C2      C3     C4

// E1 = cifra(IV)
// E2 = cifra(E1)
// E3 = cifra(E2)
// E4 = cifra(E3)
// Ci = Pi ⊕ Ei
</code></pre>
<p>Como o OFB não depende da entrada anterior, ele é ideal para ambientes em que erros de transmissão não podem propagar corrompendo blocos seguintes.</p>
<h3 id="implementação-simulada-em-go-3"><a class="header" href="#implementação-simulada-em-go-3">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func ofb(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	estado := iv
	for i, p := range entrada {
		keystream := reverse(estado) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
		estado = keystream // fluxo é autônomo
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "12345678"
	saida := ofb(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Neste exemplo:</p>
<ul>
<li>O <code>estado</code> é atualizado <strong>somente pela cifra anterior</strong>, sem depender da entrada</li>
<li>O fluxo gerado é previsível e determinístico para o mesmo IV</li>
</ul>
<p>O modo OFB é adequado para aplicações onde a integridade parcial dos dados deve ser preservada mesmo em caso de erros de transmissão.</p>
<p>No próximo modo, introduziremos um contador para gerar blocos independentes — o modo CTR.</p>
<h1 id="ctr--counter-mode"><a class="header" href="#ctr--counter-mode">CTR — Counter Mode</a></h1>
<p>O modo CTR (Counter) transforma uma cifra de bloco em uma cifra de fluxo por meio da geração de um <strong>keystream determinístico</strong>, baseado em um contador. Ao invés de realimentar saídas anteriores, ele cifra valores sequenciais derivados de um IV (Initialization Vector).</p>
<p>Cada bloco de texto é combinado (via XOR) com a cifra do contador correspondente. Isso permite que cada bloco seja processado <strong>de forma independente</strong>, facilitando a paralelização.</p>
<h3 id="funcionamento-3"><a class="header" href="#funcionamento-3">Funcionamento</a></h3>
<pre><code>Entrada:     P1     P2     P3     P4
              |      |      |      |
IV+0 --&gt; cifra        
         |           |      |      |
         v           v      v      v
        XOR         XOR   XOR    XOR
         |           |      |      |
        C1          C2     C3     C4

// C1 = P1 ⊕ cifra(IV + 0)
// C2 = P2 ⊕ cifra(IV + 1)
// C3 = P3 ⊕ cifra(IV + 2)
// C4 = P4 ⊕ cifra(IV + 3)
</code></pre>
<p>Esse modo é muito utilizado por sua eficiência e por permitir operações em paralelo. Como o contador é previsível, os blocos de keystream podem ser gerados antes mesmo da chegada da mensagem.</p>
<h3 id="implementação-simulada-em-go-4"><a class="header" href="#implementação-simulada-em-go-4">Implementação simulada em Go</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
	"strconv"
)

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func padCounter(base string, count int) string {
	suffix := fmt.Sprintf("%08d", count)
	return base[:len(base)-len(suffix)] + suffix
}

func ctr(entrada []string, iv string) []string {
	saida := make([]string, len(entrada))
	for i, p := range entrada {
		counter := padCounter(iv, i)
		keystream := reverse(counter) // aplicar cifra real aqui
		saida[i] = xor(p, keystream)
	}
	return saida
}

func reverse(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	iv := "0000000000000000" // deve ter tamanho fixo
	saida := ctr(blocos, iv)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<p>Nesta simulação:</p>
<ul>
<li>O contador é representado por um sufixo decimal no <code>IV</code></li>
<li>A função <code>reverse</code> simula a cifra aplicada ao contador</li>
<li>Cada bloco é processado com base em um valor de contador diferente</li>
</ul>
<p>O CTR é amplamente utilizado em prática (por exemplo, em AES-CTR), sendo considerado seguro e eficiente quando o <code>IV</code> não é reutilizado com a mesma chave.</p>
<h1 id="xts--xex-based-tweaked-codebook-mode-with-ciphertext-stealing"><a class="header" href="#xts--xex-based-tweaked-codebook-mode-with-ciphertext-stealing">XTS — XEX-based Tweaked Codebook Mode with Ciphertext Stealing</a></h1>
<p>O modo XTS foi projetado especificamente para cifragem de <strong>unidades de armazenamento em blocos</strong>, como discos e SSDs. Ele combina uma cifra de bloco (como AES) com uma estrutura especial chamada <strong>tweak</strong>, que personaliza a operação para cada setor ou bloco físico, evitando repetições previsíveis.</p>
<p>XTS é um modo baseado em <strong>XEX (XOR-Encrypt-XOR)</strong> com <strong>roubo de texto cifrado (ciphertext stealing)</strong>, permitindo lidar com entradas que não são múltiplas do tamanho do bloco sem recorrer a padding.</p>
<blockquote>
<p>XTS é o modo de operação recomendado por padrões como IEEE P1619 para cifragem de dados em discos.</p>
</blockquote>
<h3 id="estrutura-geral"><a class="header" href="#estrutura-geral">Estrutura geral</a></h3>
<ul>
<li>Usa <strong>duas chaves</strong>: uma para a cifra principal (<code>K1</code>) e outra para o tweak (<code>K2</code>)</li>
<li>Gera um tweak a partir do número de setor ou posição lógica do bloco</li>
<li>Aplica o tweak com XOR antes e depois da cifra (XOR-Encrypt-XOR)</li>
</ul>
<h3 id="funcionamento-simplificado"><a class="header" href="#funcionamento-simplificado">Funcionamento simplificado</a></h3>
<pre><code>Para cada bloco i:

Tweak_i = cifra(K2, bloco_logico) &lt;&lt; i // ajustado por multiplicador

M_i' = P_i ⊕ Tweak_i
C_i' = cifra(K1, M_i')
C_i  = C_i' ⊕ Tweak_i
</code></pre>
<p>Essa construção garante que dois blocos com mesmo conteúdo, mas localização diferente no disco, produzam saídas diferentes. Além disso, XTS suporta entradas que não completam um bloco inteiro usando roubo de bits do bloco seguinte (ciphertext stealing).</p>
<h3 id="simulação-conceitual"><a class="header" href="#simulação-conceitual">Simulação conceitual</a></h3>
<p>Para simplificar, podemos demonstrar apenas a ideia do uso de tweak e da dupla XOR:</p>
<pre><code class="language-go">package main

import "fmt"

func xor(a, b string) string {
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return string(out)
}

func xts(blocks []string, tweakBase string) []string {
	saida := make([]string, len(blocks))
	for i, p := range blocks {
		tweak := genTweak(tweakBase, i)
		m1 := xor(p, tweak)
		cifra := reverse(m1) // cifra principal simulada
		saida[i] = xor(cifra, tweak)
	}
	return saida
}

func genTweak(base string, i int) string {
	b := []byte(base)
	for j := range b {
		b[j] = b[j] ^ byte(i) // mistura simples com índice
	}
	return string(b)
}

func reverse(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; j; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}

func main() {
	blocos := []string{"ExemploD", "eTextoCr", "iptograf", "ado\x00\x00\x00"}
	tweak := "SETORESP"
	saida := xts(blocos, tweak)
	for i, b := range saida {
		fmt.Printf("C%d: %q\n", i+1, b)
	}
}
</code></pre>
<h3 id="características"><a class="header" href="#características">Características</a></h3>
<ul>
<li>Suporta operação paralela</li>
<li>Seguro contra repetições de padrões em setores</li>
<li>Recomendado para cifragem de disco e armazenamento</li>
</ul>
<p>Embora mais complexo que os modos anteriores, o XTS resolve limitações práticas importantes na cifragem de dispositivos reais.</p>
<p>Com isso, encerramos os principais modos de operação. A seguir, faremos uma comparação entre eles, destacando características técnicas e aplicações ideais.</p>
<h1 id="comparação-entre-modos-de-operação"><a class="header" href="#comparação-entre-modos-de-operação">Comparação entre Modos de Operação</a></h1>
<p>A análise técnica dos modos de operação não deve ser feita apenas com base em características isoladas, mas também considerando seu contexto histórico e a motivação por trás de cada proposta. A seguir, apresentamos uma visão evolutiva e comparativa entre os modos ECB, CBC, CFB, OFB, CTR e XTS.</p>
<h2 id="evolução-histórica-e-motivação"><a class="header" href="#evolução-histórica-e-motivação">Evolução histórica e motivação</a></h2>
<p>O primeiro modo amplamente utilizado foi o <strong>ECB (Electronic Codebook)</strong>. Seu funcionamento direto e paralelizável o tornava atraente, mas rapidamente ficou claro que ele era <strong>inadequado para dados estruturados</strong>: blocos iguais produziam saídas idênticas, expondo padrões — o que compromete completamente a segurança.</p>
<p>Para contornar esse problema, surgiu o <strong>CBC (Cipher Block Chaining)</strong>. Ele introduziu <strong>encadeamento entre os blocos</strong>: cada bloco depende do anterior. Isso impede que blocos idênticos de entrada produzam saídas idênticas, mesmo com a mesma chave. Contudo, essa segurança adicional vem ao custo da <strong>impossibilidade de paralelismo na cifragem</strong> — já que é preciso aguardar o resultado do bloco anterior.</p>
<p>O modo <strong>CFB (Cipher Feedback)</strong> foi criado como alternativa ao CBC para contextos de <strong>transmissão de dados em tempo real</strong>, permitindo cifragem de <strong>tamanhos menores que o bloco</strong> (como bytes ou bits). Seu encadeamento ocorre via saída anterior, o que o torna seguro, mas ainda dependente do processamento sequencial.</p>
<p>Já o <strong>OFB (Output Feedback)</strong> nasce como uma variação do CFB, buscando resolver a propagação de erros: ao invés de realimentar com a saída cifrada, o OFB <strong>gera um fluxo independente da entrada</strong>, tornando o sistema mais tolerante a falhas e adequado para ambientes ruidosos (como transmissões digitais).</p>
<p>O modo <strong>CTR (Counter Mode)</strong> representa uma mudança significativa: elimina o encadeamento e adota um <strong>contador como fonte de entropia</strong>. Cada bloco da entrada é combinado com a cifra do contador correspondente. Com isso, torna-se <strong>totalmente paralelizável</strong>, ideal para ambientes de alto desempenho, redes e sistemas distribuídos. A cifragem pode inclusive ser precomputada, desde que o contador e a chave sejam fixos.</p>
<p>Por fim, o modo <strong>XTS</strong> surge para atender <strong>um problema prático não resolvido por nenhum dos anteriores</strong>: a cifragem segura de blocos físicos em discos. Ele se baseia em XEX (XOR-Encrypt-XOR), utiliza dois conjuntos de chaves, gera um tweak exclusivo por posição e ainda lida com blocos incompletos sem padding (via ciphertext stealing). XTS é, portanto, uma construção especializada, recomendada por padrões como o IEEE P1619.</p>
<h2 id="relações-e-compensações"><a class="header" href="#relações-e-compensações">Relações e compensações</a></h2>
<p>Cada modo surgiu como resposta a uma limitação do anterior:</p>
<ul>
<li><strong>CBC</strong> corrige a repetição de padrões do <strong>ECB</strong>.</li>
<li><strong>CFB</strong> adapta o CBC para trabalhar em unidades menores.</li>
<li><strong>OFB</strong> remove a propagação de erros do CFB.</li>
<li><strong>CTR</strong> substitui todos os anteriores quando o foco é paralelismo e desempenho.</li>
<li><strong>XTS</strong> trata o caso específico de cifragem de setores físicos.</li>
</ul>
<p>É importante compreender essas relações para fazer escolhas adequadas em projetos reais. Modos de operação não são equivalentes: cada um atende a um cenário específico de uso e impõe restrições distintas.</p>
<p>Na próxima seção, faremos considerações finais sobre segurança, desempenho e práticas recomendadas.</p>
<h1 id="considerações-finais-sobre-modos-de-operação"><a class="header" href="#considerações-finais-sobre-modos-de-operação">Considerações Finais sobre Modos de Operação</a></h1>
<p>Os modos de operação analisados neste capítulo evidenciam como decisões de projeto em criptografia envolvem trocas entre <strong>segurança</strong>, <strong>eficiência</strong>, <strong>flexibilidade</strong> e <strong>resiliência a falhas</strong>. Nenhum modo é universalmente superior: cada um resolve um subconjunto de problemas e impõe restrições específicas.</p>
<p>O objetivo deste capítulo foi <strong>isolar os modos de operação</strong>, apresentando suas características técnicas e funcionais de forma independente de algoritmos específicos. A relação com cifras reais (como AES ou ChaCha20), bem como as <strong>implicações práticas de segurança</strong> na escolha do modo, serão retomadas e aprofundadas em seções posteriores do livro.</p>
<h2 id="sobre-segurança"><a class="header" href="#sobre-segurança">Sobre segurança</a></h2>
<ul>
<li><strong>ECB</strong> deve ser evitado em qualquer situação onde haja estrutura ou repetição nos dados. Seu uso é restrito a testes ou casos didáticos.</li>
<li><strong>CBC</strong>, <strong>CFB</strong> e <strong>OFB</strong> oferecem segurança razoável quando combinados com IVs aleatórios e não reutilizados.</li>
<li><strong>CTR</strong> e <strong>XTS</strong> são considerados seguros e modernos, desde que o <strong>contador ou tweak não se repita</strong> com a mesma chave.</li>
</ul>
<h2 id="sobre-desempenho-e-paralelismo"><a class="header" href="#sobre-desempenho-e-paralelismo">Sobre desempenho e paralelismo</a></h2>
<ul>
<li><strong>CTR</strong> e <strong>XTS</strong> são os únicos modos que permitem paralelismo total na cifra e decifra.</li>
<li><strong>ECB</strong> também é paralelizável, mas inseguro.</li>
<li><strong>CBC</strong>, <strong>CFB</strong> e <strong>OFB</strong> são sequenciais na cifra e, portanto, menos eficientes para grandes volumes de dados ou ambientes concorrentes.</li>
</ul>
<h2 id="sobre-robustez"><a class="header" href="#sobre-robustez">Sobre robustez</a></h2>
<ul>
<li><strong>OFB</strong> e <strong>CTR</strong> não propagam erros em cadeia, tornando-os ideais para canais com ruído.</li>
<li><strong>CBC</strong> e <strong>CFB</strong> propagam erros de forma localizada, e podem corromper blocos subsequentes na decifra.</li>
</ul>
<h2 id="escolha-prática"><a class="header" href="#escolha-prática">Escolha prática</a></h2>
<p>A escolha do modo de operação deve considerar:</p>
<ul>
<li>A natureza dos dados (texto, fluxo, armazenamento físico)</li>
<li>A sensibilidade a erros de transmissão</li>
<li>A necessidade de desempenho e paralelismo</li>
<li>As garantias de segurança esperadas</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Caso de uso</th><th>Modo recomendado</th></tr></thead><tbody>
<tr><td>Criptografia de disco</td><td>XTS</td></tr>
<tr><td>Comunicação em tempo real</td><td>CFB ou OFB</td></tr>
<tr><td>Alta performance em redes</td><td>CTR</td></tr>
<tr><td>Arquivos e backups</td><td>CBC</td></tr>
</tbody></table>
</div>
<p>Em todos os casos, o uso de <strong>vetores de inicialização (IVs)</strong> únicos e imprevisíveis é essencial para garantir a segurança dos modos baseados em encadeamento ou contadores.</p>
<p>Com isso, concluímos a análise dos modos de operação. As próximas seções tratarão da implementação de cifras reais e da integração com essas estruturas de controle de fluxo.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="confusão-e-difusão"><a class="header" href="#confusão-e-difusão">Confusão e Difusão</a></h1>
<p>As propriedades de <strong>confusão</strong> e <strong>difusão</strong> são dois princípios fundamentais estabelecidos por Shannon [1], constituindo pilares da segurança em sistemas criptográficos modernos. Esses conceitos têm como objetivo maximizar a incerteza e a dispersão das relações estatísticas entre a mensagem não cifrada e a mensagem cifrada, dificultando ataques baseados em análise de frequência ou estrutura.</p>
<h2 id="definições-formais"><a class="header" href="#definições-formais">Definições formais</a></h2>
<p><strong>Confusão</strong>: o objetivo é tornar complexa a relação entre a chave de encriptação e o texto cifrado. De acordo com Shannon, "o sistema deve ser projetado de modo que cada bit da chave afete, de forma imprevisível, muitos bits da saída". Confusão impede que um atacante deduza partes da chave mesmo conhecendo partes do texto cifrado.</p>
<p><strong>Difusão</strong>: refere-se à dispersão estatística do conteúdo da mensagem não cifrada ao longo da mensagem cifrada. Ou seja, um pequeno número de bits alterados na entrada deve afetar um grande número de bits na saída. A difusão elimina padrões e distribui redundâncias da mensagem original.</p>
<p>Esse comportamento, em que pequenas alterações na entrada produzem grandes alterações na saída, é conhecido como <strong>efeito avalanche</strong>, e é resultado da aplicação combinada de confusão e difusão.</p>
<p>Essas duas propriedades são frequentemente implementadas em cifras modernas por meio de redes de substituição e permutação redes de substituição e permutação (Substitution-Permutation Networks), conforme discutido por Donald Knuth em <em>The Art of Computer Programming</em> [5], onde destaca a importância da aleatoriedade controlada na construção de algoritmos seguros.</p>
<h2 id="exemplo-prático-simulações-de-confusão-e-difusão-em-go"><a class="header" href="#exemplo-prático-simulações-de-confusão-e-difusão-em-go">Exemplo Prático: Simulações de Confusão e Difusão em Go</a></h2>
<p>Para isolar os conceitos, não implementamos uma cifra completa, mas sim funções que exemplificam mecanicamente confusão (via substituições não lineares com chave) e difusão (via permutações e operações de dispersão simples).</p>
<p>A estrutura será:</p>
<ul>
<li>
<p>Confusão: uso de uma substituição baseada em chave (S-Box parametrizada).</p>
</li>
<li>
<p>Difusão: uso de permutação fixa e dispersão via operações XOR.</p>
</li>
</ul>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"fmt"
)

// Gera uma S-Box pseudoaleatória baseada em uma chave
func generateSBox(key []byte) [256]byte {
	var sbox [256]byte
	hash := sha256.Sum256(key)
	seed := uint32(0)
	for i := 0; i &lt; 4; i++ {
		seed ^= uint32(hash[i]) &lt;&lt; (8 * i)
	}
	for i := range sbox {
		sbox[i] = byte((i*int(seed) + 31) % 256)
	}
	return sbox
}

// Confusão: aplica substituição não linear via S-Box
func confusion(input []byte, sbox [256]byte) []byte {
	out := make([]byte, len(input))
	for i, b := range input {
		out[i] = sbox[b]
	}
	return out
}

// Difusão: permutação e dispersão via XOR entre posições
func diffusion(input []byte) []byte {
	out := make([]byte, len(input))
	for i := range input {
		out[i] = input[i]
		if i &gt; 0 {
			out[i] ^= input[i-1]
		}
	}
	return out
}

func main() {
	key := []byte("chave-secreta")
	entrada := []byte("mensagem123456")

	sbox := generateSBox(key)
	c := confusion(entrada, sbox)
	d := diffusion(c)

	fmt.Printf("Original : %x\n", entrada)
	fmt.Printf("Confusão : %x\n", c)
	fmt.Printf("Difusão  : %x\n", d)
}

</code></pre>
<p>Análise do código:</p>
<p>Observe que:</p>
<ul>
<li>
<p>A função generateSBox cria uma tabela de substituição (S-Box) que introduz confusão, pois depende da chave de entrada.</p>
</li>
<li>
<p>A função diffusion implementa uma difusão simples, propagando a influência de cada byte anterior sobre o próximo com XOR.</p>
</li>
</ul>
<h2 id="considerações-finais"><a class="header" href="#considerações-finais">Considerações Finais</a></h2>
<p>A aplicação isolada de confusão e difusão permite o estudo modular de suas propriedades, sem a complexidade adicional de um esquema criptográfico completo. Shannon já antecipava que a combinação adequada dessas técnicas seria suficiente para criar sistemas resistentes à análise estatística.</p>
<p>Knuth, por sua vez, destacou que a boa aleatorização estruturada é o centro da segurança criptográfica — e que difusão e confusão são ferramentas matemáticas precisamente voltadas a esse objetivo.</p>
<p>O leitor é convidado a explorar esses conceitos com maior profundidade consultando a referência [1] e [5].</p>
<h2 id="referências"><a class="header" href="#referências">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-boxes-substituições-não-lineares"><a class="header" href="#s-boxes-substituições-não-lineares">S-Boxes: Substituições Não Lineares</a></h1>
<p>As S-Boxes (Substitution Boxes) são funções fundamentais em cifras simétricas modernas. Elas realizam substituições não lineares, introduzindo confusão no sistema criptográfico, conforme definido por Shannon [1]. Em redes de substituição-permutação (SPN) e cifras de Feistel, as S-Boxes são os principais elementos responsáveis por tornar complexa a relação entre a chave e o texto cifrado.</p>
<h2 id="definição-formal"><a class="header" href="#definição-formal">Definição Formal</a></h2>
<p>Uma S-Box é uma função</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></p>
<p>que mapeia uma entrada binária de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits para uma saída de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> bits. Quando <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, a S-Box é dita bijetiva (ou uma permutação) se cada saída for única.</p>
<p>Exemplo típico:</p>
<ul>
<li>No AES, a S-Box é uma permutação de 8 bits para 8 bits, isto é, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<p>Propriedades desejáveis:</p>
<ul>
<li>
<p>Não-linearidade alta (distância de Hamming em relação a todas funções lineares).</p>
</li>
<li>
<p>Avalanche: uma mudança de 1 bit na entrada afeta múltiplos bits da saída.</p>
</li>
<li>
<p>Resistência a diferenciais e lineares: saída deve ser estatisticamente imprevisível sob diferenças ou aproximações lineares na entrada.</p>
</li>
</ul>
<p>Métodos de construção:</p>
<p>A criação de S-Boxes pode ser feita de diferenes maneiras, dependendo do contexto e objetivos de segurança:</p>
<ol>
<li>Baseadas em estruturas algébricas</li>
</ol>
<ul>
<li>AES (Rijndael) utiliza a inversa multiplicativa no corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8665em;vertical-align:-0.1776em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5224em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1776em;"><span></span></span></span></span></span></span></span></span></span>, seguida de uma transformação afim:
<ul>
<li>Inverso: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> (com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6554em;vertical-align:-0.011em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</li>
<li>Transformação afim: multiplicação e soma sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p>Essa construção é baseada no padrão FIPS 197 [2]. e foi escolhida por sua alta não-linearidade e resistência a ataques diferenciais.</p>
<ol start="2">
<li>Baseadas em constantes (look-up fixo)</li>
</ol>
<ul>
<li>
<p>MD2 define uma S-Box de 256 bytes fixos, supostamente derivada dos dígitos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. A origem exata nunca foi publicada por Rivest, mas acredita-se que a sequência tenha sido escolhida de forma a evitar padrões evidentes [3].</p>
</li>
<li>
<p>DES usa oito S-Boxes diferentes com mapeamentos de 6 bits para 4 bits, cuidadosamente projetadas para resistir a criptoanálise diferencial (ver Coppersmith [4]).</p>
</li>
</ul>
<ol start="3">
<li>Pseudoaleatórias derivadas de chave</li>
</ol>
<ul>
<li>Em cifras modernas como Blowfish, a S-Box é preenchida dinamicamente durante a expansão da chave. Isso dificulta análise e torna a estrutura dependente da chave secreta.</li>
</ul>
<h2 id="exemplo-prático-em-go-construindo-uma-s-box-simples"><a class="header" href="#exemplo-prático-em-go-construindo-uma-s-box-simples">Exemplo prático em Go: Construindo uma S-Box simples</a></h2>
<p>Aqui, mostramos duas formas distintas de definir S-Boxes em Go:</p>
<ol>
<li>AES-like (algébrica) - inverso multiplicativo seguido de transformação afim (simplificada).</li>
<li>MD2-like (constante fixa) - look-up fixo.</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"math/bits"
)

// Exemplo simplificado de S-Box: inverso em GF(2^8) + afim (AES-like simplificada)
func simpleAffineSBox() [256]byte {
	var sbox [256]byte
	for i := 0; i &lt; 256; i++ {
		inv := inverseByte(byte(i))
		sbox[i] = inv ^ bits.RotateLeft8(inv, 1) ^ 0x63 // afim simplificada
	}
	return sbox
}

// Inverso multiplicativo em GF(2^8) com polinômio redutor x^8 + x^4 + x^3 + x + 1
func inverseByte(x byte) byte {
	if x == 0 {
		return 0
	}
	var inv byte = 1
	for i := 1; i &lt; 256; i++ {
		if byteMultiply(x, inv) == 1 {
			return inv
		}
		inv++
	}
	return 0
}

// Multiplicação em GF(2^8)
func byteMultiply(a, b byte) byte {
	var p byte = 0
	for b != 0 {
		if b&amp;1 != 0 {
			p ^= a
		}
		hi := a &amp; 0x80
		a &lt;&lt;= 1
		if hi != 0 {
			a ^= 0x1B // AES irreducible polynomial
		}
		b &gt;&gt;= 1
	}
	return p
}

// Exemplo de S-Box constante (MD2-like)
func md2SBox() [256]byte {
	return [256]byte{
		0x29, 0x2E, 0x43, 0x32, 0x8B, 0x1C, 0x1A, 0x06, 0x3F, 0x3C, 0x7F, 0x8A, 0x0E, 0x19, 0x4F, 0x43,
		// ... complete até 256 valores reais conforme tabela do MD2
	}
}

func main() {
	sbox := simpleAffineSBox()
	fmt.Printf("Exemplo de S-Box (simplificada):\n")
	for i := 0; i &lt; 16; i++ {
		fmt.Printf("%02x ", sbox[i])
	}
	fmt.Println()
}
</code></pre>
<h2 id="considerações-finais-1"><a class="header" href="#considerações-finais-1">Considerações finais</a></h2>
<p>As S-Boxes são blocos fundamentais na construção de cifras seguras. Sua estrutura influencia diretamente a resistência contra ataques diferenciais, lineares e por análise estatística. S-Boxes bem projetadas devem apresentar não-linearidade elevada e boa dispersão da entrada na saída, contribuindo para o efeito avalanche.</p>
<p>Embora possam ser fixas ou derivadas de chave, é essencial que sejam analisadas formalmente quanto às suas propriedades de segurança — algo que o projeto do AES exemplifica de forma rigorosa. Em contrapartida, designs mais antigos, como MD2, revelam escolhas empíricas, ainda que eficazes em seu tempo.</p>
<h2 id="referências-1"><a class="header" href="#referências-1">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[2] National Institute of Standards and Technology, FIPS-197: Advanced Encryption Standard (AES), 2001.</p>
<p>[3] R. Rivest, The MD2 Message-Digest Algorithm, RFC 1319, 1992.</p>
<p>[4] D. Coppersmith, The Data Encryption Standard (DES) and Its Strength Against Attacks, IBM Journal of Research and Development, 1994.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Vol. 2, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="permutações-e-trocas"><a class="header" href="#permutações-e-trocas">Permutações e Trocas</a></h1>
<p>Em cifras simétricas, a dispersão de dependências locais — fundamental para a difusão — pode ser alcançada por meio de operações lineares, como multiplicações matriciais, ou estruturais, como permutações e trocas de posição. Este tipo de transformação reorganiza os dados sem alterar seu conteúdo individual, mas com profundo impacto estatístico na propagação de alterações pela estrutura do algoritmo.</p>
<h2 id="permutações-como-mecanismo-de-difusão"><a class="header" href="#permutações-como-mecanismo-de-difusão">Permutações como mecanismo de difusão</a></h2>
<p>Uma permutação é uma bijeção sobre o conjunto de posições de bits ou bytes. Aplicada a um vetor de entrada, ela redistribui os elementos segundo uma ordem fixa ou pseudoaleatória. Embora não introduza não-linearidade, a permutação é essencial para ampliar o alcance das alterações provocadas pelas S-Boxes ou outras funções não lineares.</p>
<p>Na arquitetura de cifras modernas, as permutações são utilizadas para:</p>
<ul>
<li>
<p>Propagar a influência de bits da entrada por várias S-Boxes na rodada seguinte.</p>
</li>
<li>
<p>Impedir que padrões locais na entrada gerem padrões locais na saída.</p>
</li>
<li>
<p>Compor difusão com custo computacional baixo.</p>
</li>
</ul>
<h2 id="exemplo-em-spns"><a class="header" href="#exemplo-em-spns">Exemplo em SPNs</a></h2>
<p>No AES (FIPS-197), duas camadas implementam difusão com base em permutação:</p>
<ul>
<li><strong>ShiftRows</strong>: uma permutação de bytes por rotação de linhas.</li>
<li><strong>MixColumns</strong>: uma multiplicação linear que atua em colunas, mas combinada com ShiftRows produz difusão bidimensional.</li>
</ul>
<p>Essas operações não introduzem confusão, mas são vitais para garantir o efeito avalanche ao longo das rodadas.</p>
<h2 id="exemplo-em-feistel"><a class="header" href="#exemplo-em-feistel">Exemplo em Feistel</a></h2>
<p>Na estrutura de Feistel, usada no DES e em muitas cifras derivadas, a difusão é construída ao longo das rodadas, intercalando trocas de metades do bloco com aplicações de funções não lineares (geralmente baseadas em S-Boxes).</p>
<p>Permutações também aparecem de forma explícita:</p>
<ul>
<li>
<p>Initial Permutation (IP) e Final Permutation (FP) no DES são mapeamentos fixos de 64 bits, historicamente motivados por eficiência em hardware, mas com efeito colateral de difusão inicial e final.</p>
</li>
<li>
<p>Permutação P após a aplicação das S-Boxes na função F do DES serve para espalhar os resultados locais das substituições.</p>
</li>
</ul>
<h2 id="implementação-ilustrativa-em-go"><a class="header" href="#implementação-ilustrativa-em-go">Implementação ilustrativa em Go</a></h2>
<p>Abaixo, um exemplo de permutação simples de bytes em um vetor de 16 posições:</p>
<pre><code class="language-go">package main

import "fmt"

// Permutação fixa (exemplo artificial)
var permutation = [16]int{2, 0, 3, 1, 6, 4, 7, 5, 10, 8, 11, 9, 14, 12, 15, 13}

func permute(input []byte, p [16]int) []byte {
	out := make([]byte, len(input))
	for i := range p {
		out[i] = input[p[i]]
	}
	return out
}

func main() {
	entrada := []byte("abcdefghijklmnop")
	saida := permute(entrada, permutation)
	fmt.Printf("Original : %s\n", entrada)
	fmt.Printf("Permutada: %s\n", saida)
}
</code></pre>
<p>Esse tipo de permutação, apesar de simples, é o mecanismo base por trás de transformações como ShiftRows. A escolha da ordem é crítica: ela deve maximizar a dispersão estatística sem introduzir simetrias.</p>
<h2 id="considerações-finais-2"><a class="header" href="#considerações-finais-2">Considerações Finais</a></h2>
<p>Permutações e trocas estruturadas são ferramentas indispensáveis na construção de cifras robustas. Embora não introduzam entropia ou não-linearidade, são essenciais para distribuir os efeitos locais das S-Boxes e garantir que os princípios de difusão definidos por Shannon sejam plenamente realizados.</p>
<p>Além disso, entender como essas operações interagem com as camadas de substituição permite projetar SPNs eficientes e compreender como redes de Feistel obtêm segurança mesmo com funções internas relativamente simples.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="codificação-de-dados-representações-reversíveis-para-armazenamento-e-transmissão"><a class="header" href="#codificação-de-dados-representações-reversíveis-para-armazenamento-e-transmissão">Codificação de Dados: Representações Reversíveis para Armazenamento e Transmissão</a></h1>
<p>Esta seção reúne os principais esquemas de codificação utilizados para converter dados binários em formatos textuais seguros e reversíveis. Embora essas codificações não tenham relação direta com criptografia, elas desempenham papel essencial em aplicações que exigem compatibilidade com sistemas baseados em texto, como e-mails (MIME), URLs, APIs web, arquivos JSON e representações de chaves ou hashes.</p>
<p>Começamos com a codificação Base64, amplamente utilizada para transmitir dados binários por meios que aceitam apenas texto. Em seguida, analisamos variações como Base64URL (usada em JWT), Base32 (utilizada em TOTP e sistemas de backup de chaves) e Base16 (hexadecimal), muito comum na representação de hashes e valores binários compactos.</p>
<p>Completamos a análise com codificações mais especializadas como Base85 (PostScript, Git), Base58 (endereços Bitcoin) e Percent-Encoding, usada para garantir segurança sintática em URLs.</p>
<blockquote>
<p>Todas as codificações aqui tratadas são <strong>reversíveis</strong> e <strong>determinísticas</strong>, ou seja, não envolvem chave, sigilo ou aleatoriedade. São ferramentas auxiliares para transmissão e representação segura de dados, e servirão de base para os capítulos futuros onde aparecerão como parte de algoritmos criptográficos reais.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h1>
<p>Se o capítulo ficar complexo, incluir aqui uma introdução mais aprofundada sobre codificação e decodificação</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<p>Base64 é uma codificação reversível que converte qualquer sequência de bytes em uma representação textual composta por um conjunto de 64 caracteres, conforme especificado na RFC 4648 [1]. Ela é amplamente utilizada para permitir o transporte de dados binários por meios que só aceitam texto, como e-mails (MIME), URLs ou JSON.</p>
<p>A codificação Base64 funciona agrupando a entrada em blocos de 3 bytes (24 bits) e dividindo-os em 4 grupos de 6 bits. Cada grupo de 6 bits é então convertido em um caractere da tabela Base64, a qual é formada da seguinte forma:</p>
<ul>
<li>Letras maiúsculas (A–Z) → índices 0 a 25</li>
<li>Letras minúsculas (a–z) → índices 26 a 51</li>
<li>Números (0–9) → índices 52 a 61</li>
<li>Símbolos especiais <code>+</code> e <code>/</code> → índices 62 e 63</li>
</ul>
<p>Em Go, podemos representar essa tabela como uma string:</p>
<pre><code class="language-go">const base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
</code></pre>
<p>Quando a entrada não é múltiplo exato de 3 bytes, a codificação adiciona preenchimento (o caractere <code>=</code>) ao final para manter consistência com o número de blocos.</p>
<p>Cabe ressaltar que Base64 <strong>não é criptografia</strong>. Qualquer pessoa pode decodificar sua saída e seu uso é exclusivamente para <strong>representação e compatibilidade</strong>.</p>
<h2 id="exemplo-codificando-rox"><a class="header" href="#exemplo-codificando-rox">Exemplo: Codificando "Rox"</a></h2>
<h3 id="passo-1-conversão-para-ascii"><a class="header" href="#passo-1-conversão-para-ascii">Passo 1: Conversão para ASCII</a></h3>
<pre><code>R → 82
o → 111
x → 120
</code></pre>
<h3 id="passo-2-conversão-para-binário-8-bits-por-caractere"><a class="header" href="#passo-2-conversão-para-binário-8-bits-por-caractere">Passo 2: Conversão para binário (8 bits por caractere)</a></h3>
<pre><code>82  → 01010010
o  → 01101111
x  → 01111000
</code></pre>
<p>Agrupados: <code>01010010 01101111 01111000</code> (24 bits)</p>
<h3 id="passo-3-dividir-em-4-blocos-de-6-bits"><a class="header" href="#passo-3-dividir-em-4-blocos-de-6-bits">Passo 3: Dividir em 4 blocos de 6 bits</a></h3>
<pre><code>010100 100110 111101 111000
</code></pre>
<h3 id="passo-4-converter-cada-bloco-para-decimal"><a class="header" href="#passo-4-converter-cada-bloco-para-decimal">Passo 4: Converter cada bloco para decimal</a></h3>
<pre><code>20, 38, 61, 56
</code></pre>
<h3 id="passo-5-mapear-na-tabela-base64"><a class="header" href="#passo-5-mapear-na-tabela-base64">Passo 5: Mapear na tabela Base64</a></h3>
<pre><code>base64Table[20] = "U"
base64Table[38] = "m"
base64Table[61] = "9"
base64Table[56] = "4"
</code></pre>
<p>Resultado: <code>Um94</code></p>
<blockquote>
<p>Para extrair os grupos de 6 bits, utilizamos <strong>bitwise AND</strong> com uma máscara <code>0b00111111</code>. Para uma explicação mais detalhada sobre manipulação de bits, consulte a seção <a href="conceitos/encode-decode/../manipulacao-de-dados/operadores-bitwise.html">Operadores Bitwise</a>.</p>
</blockquote>
<h2 id="implementação-em-go-1"><a class="header" href="#implementação-em-go-1">Implementação em Go</a></h2>
<pre><code class="language-go">const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func Encb64(in []byte) string {
    var out []byte
    len := len(in)
    rem := len % 3

    for i := 0; i &lt; len - rem; i += 3 {
        blk := int64(in[i]) &lt;&lt; 16 | int64(in[i+1]) &lt;&lt; 8 | int64(in[i+2])
        out = append(out,
            b64[(blk&gt;&gt;18)&amp;0b111111],
            b64[(blk&gt;&gt;12)&amp;0b111111],
            b64[(blk&gt;&gt;6) &amp;0b111111],
            b64[blk&amp;0b111111],
        )
    }

    if rem == 1 {
        blk := int64(in[len - 1]) &lt;&lt; 16
        out = append(out,
            b64[(blk&gt;&gt;18)&amp;0b111111],
            b64[(blk&gt;&gt;12)&amp;0b111111], '=', '=',
        )
    } else if rem == 2 {
        blk := int64(in[len - 2]) &lt;&lt; 16 | int64(in[len - 1]) &lt;&lt; 8
        out = append(out,
            b64[(blk&gt;&gt;18)&amp;0b111111],
            b64[(blk&gt;&gt;12)&amp;0b111111],
            b64[(blk&gt;&gt;6) &amp;0b111111], '=',
        )
    }

    return string(out)
}
</code></pre>
<h3 id="explicação-do-código"><a class="header" href="#explicação-do-código">Explicação do código</a></h3>
<p>Cada grupo de 3 bytes (24 bits) é combinado em um único inteiro (<code>blk</code>) usando operações de shift e OR. Por exemplo:</p>
<pre><code class="language-go">blk := int64(in[i]) &lt;&lt; 16 | int64(in[i+1]) &lt;&lt; 8 | int64(in[i+2])
</code></pre>
<p>Dessa forma, <code>blk</code> conseguimos compactar os 3 bytes dentro de um inteiro, onde:</p>
<ul>
<li>o primeiro byte ocupa os bits 16 a 23</li>
<li>o segundo byte ocupa os bits 8 a 15</li>
<li>o terceiro byte ocupa os bits 0 a 7</li>
</ul>
<p>A extração dos grupos de 6 bits é feita da esquerda para a direita com deslocamento (<code>&gt;&gt;</code>) e máscara (<code>&amp; 0b111111</code>), isolando cada conjunto de 6 bits:</p>
<pre><code class="language-go">b64_1 = (blk &gt;&gt; 18) &amp; 0b111111
b64_2 = (blk &gt;&gt; 12) &amp; 0b111111
b64_3 = (blk &gt;&gt; 6)  &amp; 0b111111
b64_4 =  blk        &amp; 0b111111
</code></pre>
<p>Esses índices são então usados diretamente para acessar os caracteres na tabela Base64.</p>
<p>Quando sobram bytes (i.e. 1 ou 2 bytes) estes são tratados separadamente, incluindo o padding <code>=</code> conforme especificação.</p>
<h2 id="variante-base64url"><a class="header" href="#variante-base64url">Variante: Base64URL</a></h2>
<p>Uma variação comum do Base64 é o Base64URL, também definida na RFC 4648. Ela foi projetada para ser segura em contextos como URLs, nomes de arquivos e parâmetros HTTP, e, em especial, com JWT (Json Web Tokens). As modificações são as seguintes:</p>
<ol>
<li>
<p>Substituir os caracteres:</p>
<p><code>+</code> por <code>-</code> e <code>/</code> por <code>_</code></p>
</li>
<li>
<p>O caractere de preenchimento <code>=</code> pode ser omitido, já que o comprimento da string pode indicar os bits ausentes na decodificação.</p>
</li>
</ol>
<p>A lógica de codificação permanece idêntica ao Base64 padrão; apenas a tabela de caracteres muda:</p>
<pre><code class="language-go">const b64Url = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
</code></pre>
<h2 id="considerações-finais-3"><a class="header" href="#considerações-finais-3">Considerações finais</a></h2>
<ul>
<li>Base64 é uma transformação <strong>reversível</strong>.</li>
<li>Aumenta o tamanho da entrada em cerca de <strong>33%</strong>.</li>
<li>Útil para compatibilidade textual, não para segurança.</li>
</ul>
<p>Outras codificações com finalidades semelhantes incluem Base32, Base85 e Hex.</p>
<h2 id="referências-2"><a class="header" href="#referências-2">Referências</a></h2>
<p>[1] RFC 4648 – The Base16, Base32, and Base64 Data Encodings. Internet Engineering Task Force (IETF). Disponível em: https://datatracker.ietf.org/doc/html/rfc4648</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base32"><a class="header" href="#base32">Base32</a></h1>
<p>Base32 é uma codificação definida na RFC 4648 [1] que transforma dados binários em uma representação textual usando 32 caracteres seguros para transporte e legíveis. Ela é comumente utilizada em sistemas que impõem restrições a caracteres especiais, como nomes de arquivos, QR Codes, e na geração de segredos em algoritmos de autenticação como o TOTP (Time-based One-Time Password), amplamente empregado por aplicativos como o Google Authenticator.</p>
<p>A codificação Base32 opera agrupando a entrada binária em blocos de 5 bytes (40 bits) e os dividindo em 8 grupos de 5 bits. Cada grupo de 5 bits é mapeado para um caractere da tabela Base32, composta por:</p>
<ul>
<li>Letras maiúsculas (A–Z) → índices 0 a 25</li>
<li>Dígitos (2–7) → índices 26 a 31</li>
</ul>
<p><strong>Observação</strong>: Os dígitos 0 e 1 são evitados para reduzir ambiguidades com as letras O e I, o que torna o Base32 mais robusto para leitura manual e OCR.</p>
<hr />
<h2 id="exemplo-codificando-ma"><a class="header" href="#exemplo-codificando-ma">Exemplo: Codificando "Ma"</a></h2>
<p>"Ma" tem dois caracteres, ou seja, 2 bytes:</p>
<pre><code>M → 0x4D → 01001101
a → 0x61 → 01100001
</code></pre>
<p>Concatenando os bits: <code>0100110101100001</code> (16 bits)</p>
<p>Agora separamos os bits em blocos de 5:</p>
<pre><code>01001 10101 10000 1[padding]
</code></pre>
<p>Completamos com zeros à direita até ter múltiplo de 5 bits:</p>
<pre><code>01001 10101 10000 10000
</code></pre>
<p>Convertendo para decimal:</p>
<pre><code>9, 21, 16, 16
</code></pre>
<p>Usando a tabela Base32:</p>
<pre><code class="language-go">const base32Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
</code></pre>
<p>Temos:</p>
<pre><code>base32Table[9]  = J
base32Table[21] = V
base32Table[16] = Q
base32Table[16] = Q
</code></pre>
<p>Resultado: <code>JVQQ</code> (com padding = se aplicável)</p>
<hr />
<h2 id="implementação-em-go-básica"><a class="header" href="#implementação-em-go-básica">Implementação em Go (básica)</a></h2>
<pre><code class="language-go">import (
	"fmt"
	"strings"
)

const base32Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

func EncodeBase32(data []byte) string {
	var builder strings.Builder
	var buffer uint64
	var bits uint

	for _, b := range data {
		buffer = (buffer &lt;&lt; 8) | uint64(b)
		bits += 8
		for bits &gt;= 5 {
			index := (buffer &gt;&gt; (bits - 5)) &amp; 0b11111
			builder.WriteByte(base32Table[index])
			bits -= 5
		}
	}

	if bits &gt; 0 {
		index := (buffer &lt;&lt; (5 - bits)) &amp; 0b11111
		builder.WriteByte(base32Table[index])
	}

	for builder.Len()%8 != 0 {
		builder.WriteByte('=')
	}

	return builder.String()
}

func main() {
	entrada := []byte("Ma")
	fmt.Println("Base32: ", EncodeBase32(entrada))
}
</code></pre>
<hr />
<h2 id="considerações-2"><a class="header" href="#considerações-2">Considerações</a></h2>
<ul>
<li>É mais verboso que o Base64: a saída é cerca de 60% maior que a original.</li>
<li>Melhor tolerância à digitação e OCR.</li>
<li>Amplamente usado em aplicações como <strong>TOTP</strong> (RFC 6238) e <strong>secrets URI</strong> (RFC 3548 / 4648).</li>
</ul>
<hr />
<h2 id="referências-3"><a class="header" href="#referências-3">Referências</a></h2>
<p>[1] RFC 4648 – The Base16, Base32, and Base64 Data Encodings. IETF. Disponível em: https://datatracker.ietf.org/doc/html/rfc4648</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base16-hexadecimal"><a class="header" href="#base16-hexadecimal">Base16 (Hexadecimal)</a></h1>
<p>Base16, ou codificação <strong>hexadecimal</strong>, é uma forma de representar dados binários em texto usando 16 símbolos: os dígitos de <code>0</code> a <code>9</code> e as letras <code>A</code> a <code>F</code>. Cada byte (8 bits) é representado por dois caracteres hexadecimais — ou seja, 4 bits por caractere.</p>
<p>Essa codificação é amplamente utilizada em sistemas criptográficos para exibir valores binários de forma legível e padronizada, como hashes (MD5, SHA-1, SHA-256), chaves, IVs, e blocos de dados.</p>
<p>Está formalmente definida na RFC 4648 [1] como uma das representações canônicas para dados binários.</p>
<hr />
<h2 id="tabela-de-correspondência"><a class="header" href="#tabela-de-correspondência">Tabela de correspondência</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Binário</th><th>Hex</th></tr></thead><tbody>
<tr><td>0000</td><td>0</td></tr>
<tr><td>0001</td><td>1</td></tr>
<tr><td>0010</td><td>2</td></tr>
<tr><td>0011</td><td>3</td></tr>
<tr><td>0100</td><td>4</td></tr>
<tr><td>0101</td><td>5</td></tr>
<tr><td>0110</td><td>6</td></tr>
<tr><td>0111</td><td>7</td></tr>
<tr><td>1000</td><td>8</td></tr>
<tr><td>1001</td><td>9</td></tr>
<tr><td>1010</td><td>A</td></tr>
<tr><td>1011</td><td>B</td></tr>
<tr><td>1100</td><td>C</td></tr>
<tr><td>1101</td><td>D</td></tr>
<tr><td>1110</td><td>E</td></tr>
<tr><td>1111</td><td>F</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="exemplo-hi"><a class="header" href="#exemplo-hi">Exemplo: "Hi"</a></h2>
<p>A string "Hi" possui dois bytes:</p>
<pre><code>H → 0x48 → 01001000
i → 0x69 → 01101001
</code></pre>
<p>Convertendo byte a byte para hexadecimal:</p>
<pre><code>0x48 → 4 e 8 → "48"
0x69 → 6 e 9 → "69"
</code></pre>
<p>Resultado final: <code>4869</code></p>
<hr />
<h2 id="implementação-em-go-2"><a class="header" href="#implementação-em-go-2">Implementação em Go</a></h2>
<pre><code class="language-go">import (
	"encoding/hex"
	"fmt"
)

func main() {
	entrada := []byte("Hi")
	saida := hex.EncodeToString(entrada)
	fmt.Println("Hex: ", saida)
}
</code></pre>
<p>Essa é a forma canônica implementada na biblioteca padrão de Go, e pode ser usada para representar qualquer dado binário de forma segura, compacta e legível.</p>
<hr />
<h2 id="considerações-3"><a class="header" href="#considerações-3">Considerações</a></h2>
<ul>
<li>Cada byte vira 2 caracteres → aumento de 100% no tamanho.</li>
<li>Alta legibilidade e padronização.</li>
<li>Forma mais comum de visualizar hashes e chaves.</li>
<li>Diferente do Base64, <strong>não precisa de padding</strong>.</li>
</ul>
<hr />
<h2 id="referências-4"><a class="header" href="#referências-4">Referências</a></h2>
<p>[1] RFC 4648 – The Base16, Base32, and Base64 Data Encodings. IETF. Disponível em: https://datatracker.ietf.org/doc/html/rfc4648</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base85"><a class="header" href="#base85">Base85</a></h1>
<p>Devo incluir!?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="base58"><a class="header" href="#base58">Base58</a></h1>
<p>Devo incluir!?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="percent-encoding-url-encoding"><a class="header" href="#percent-encoding-url-encoding">Percent-Encoding (URL Encoding)</a></h1>
<p>O <strong>Percent-Encoding</strong>, também conhecido como <strong>URL encoding</strong>, é um mecanismo definido pela RFC 3986 [1] para representar caracteres arbitrários em URLs utilizando apenas um subconjunto seguro de ASCII. Esse método codifica bytes utilizando o símbolo <code>%</code> seguido de dois dígitos hexadecimais (0–9, A–F) que representam o valor do byte.</p>
<p>Essa codificação é comumente usada em:</p>
<ul>
<li>URLs e URIs</li>
<li>Parâmetros de requisições HTTP</li>
<li>JSON Web Tokens (JWT) no modo compact</li>
<li>Formulários HTML (<code>application/x-www-form-urlencoded</code>)</li>
</ul>
<hr />
<h2 id="exemplo"><a class="header" href="#exemplo">Exemplo</a></h2>
<p>Se quisermos transmitir o valor <code>senha=meu segredo</code> como parte de uma URL:</p>
<pre><code>senha=meu segredo
</code></pre>
<p>Espaços e caracteres especiais são codificados:</p>
<pre><code>senha=meu%20segredo
</code></pre>
<p>Outro exemplo, com caracteres não-ASCII:</p>
<pre><code>entrada: café
</code></pre>
<p>O caractere <code>é</code> (0xC3A9 em UTF-8) é convertido para:</p>
<pre><code>caf%C3%A9
</code></pre>
<hr />
<h2 id="caracteres-codificados-obrigatoriamente"><a class="header" href="#caracteres-codificados-obrigatoriamente">Caracteres codificados obrigatoriamente</a></h2>
<p>Qualquer caractere fora do conjunto seguro é codificado. O conjunto seguro inclui:</p>
<ul>
<li>Letras (<code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code>)</li>
<li>Dígitos (<code>0</code>–<code>9</code>)</li>
<li>Caracteres especiais: <code>-</code>, <code>_</code>, <code>.</code>, <code>~</code></li>
</ul>
<p>Tudo mais é substituído por <code>%XX</code>, onde <code>XX</code> é o byte em hexadecimal.</p>
<hr />
<h2 id="implementação-em-go-3"><a class="header" href="#implementação-em-go-3">Implementação em Go</a></h2>
<p>A biblioteca padrão oferece suporte completo via o pacote <code>net/url</code>:</p>
<pre><code class="language-go">import (
	"fmt"
	"net/url"
)

func main() {
	entrada := "café &amp; açúcar"
	encoded := url.QueryEscape(entrada)
	fmt.Println("Percent-encoded:", encoded)
}
</code></pre>
<p>Saída:</p>
<pre><code>Percent-encoded: caf%C3%A9+%26+a%C3%A7%C3%BAcar
</code></pre>
<p>Obs: Espaços podem ser representados como <code>+</code> (formulário) ou <code>%20</code> (padrão URI).</p>
<h2 id="como-a-codificação-xx-é-construída"><a class="header" href="#como-a-codificação-xx-é-construída">Como a codificação %XX é construída</a></h2>
<p>A codificação Percent-Encoding é determinada diretamente pelo valor binário de cada byte. Se o byte não pertence ao conjunto de caracteres seguros, ele será convertido para sua representação hexadecimal de dois dígitos, prefixada por %. Por exemplo, o caractere @ (código decimal 64) é codificado como %40 porque 0x40 é a representação hexadecimal de 64.</p>
<p>Essa transformação segue a fórmula:</p>
<pre><code>% + UPPERCASE(HEX(byte))

</code></pre>
<h2 id="considerações-4"><a class="header" href="#considerações-4">Considerações</a></h2>
<ul>
<li>Reversível: a decodificação é trivial.</li>
<li>Não fornece sigilo ou autenticidade.</li>
<li>Essencial para interoperabilidade com HTTP e navegadores.</li>
<li>Aparece como pré-processamento em várias aplicações web.</li>
</ul>
<hr />
<h2 id="referências-5"><a class="header" href="#referências-5">Referências</a></h2>
<p>[1] RFC 3986 – Uniform Resource Identifier (URI): Generic Syntax. IETF. Disponível em: https://datatracker.ietf.org/doc/html/rfc3986</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="verificação-de-integridade-de-dados-checksum-bit-de-paridade-e-crc"><a class="header" href="#verificação-de-integridade-de-dados-checksum-bit-de-paridade-e-crc">Verificação de Integridade de Dados: Checksum, Bit de Paridade e CRC</a></h1>
<p>Nesta seção, estudaremos mecanismos clássicos de verificação de integridade aplicados em transmissão e armazenamento de dados. Esses mecanismos são baseados em operações determinísticas que permitem identificar se houve erro ou corrupção durante o transporte ou gravação de informação.</p>
<p>Começamos com o <strong>Bit de Paridade</strong>, um dos métodos mais simples de detecção de erro, amplamente usado em memória RAM, protocolos seriais e dispositivos de baixo custo.</p>
<p>Em seguida, analisamos o <strong>Checksum</strong>, que agrupa e soma blocos de dados para gerar um valor de referência simples. Apesar de fraco do ponto de vista criptográfico, é eficiente para detectar corrupção acidental.</p>
<p>Por fim, estudamos o <strong>CRC (Cyclic Redundancy Check)</strong>, um algoritmo baseado em operações binárias e teoria de polinômios sobre GF(2), amplamente usado em redes, discos e protocolos robustos de comunicação como Ethernet e USB.</p>
<blockquote>
<p>Ao contrário das funções hash criptográficas, os algoritmos desta seção não são projetados para resistir a ataques intencionais, mas sim para detectar falhas acidentais. Servem como base histórica e técnica para compreender os limites da verificação simples de integridade antes de abordarmos as construções criptográficas propriamente ditas.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h1>
<p>Ao armazenar ou transmitir dados em sistemas computacionais, há sempre o risco de que a informação sofra alterações não intencionais — seja por falhas físicas, ruído elétrico, setores defeituosos ou erros de software. A verificação de integridade tem como objetivo detectar esse tipo de corrupção de maneira eficiente e automática.</p>
<p>Nesta seção, estudaremos algoritmos simples, mas historicamente relevantes, usados para validar a integridade de dados em diferentes contextos. Ao contrário das funções hash criptográficas, esses métodos não têm resistência contra ataques intencionais, mas são ideais para detectar erros acidentais com baixa sobrecarga computacional.</p>
<p>Nosso foco será entender os fundamentos e limites dessas técnicas, que antecedem as construções criptográficas modernas. Estudaremos como mecanismos como o bit de paridade, checksums e CRCs são aplicados em sistemas reais — desde memórias e redes até arquivos e protocolos industriais.</p>
<p>Esses conhecimentos são importantes não apenas por seu valor prático, mas também como base para compreender os objetivos e os desafios das abordagens mais robustas de integridade que serão tratadas posteriormente neste livro.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="bit-de-paridade-parity-bit"><a class="header" href="#bit-de-paridade-parity-bit">Bit de Paridade (Parity Bit)</a></h1>
<p>O <strong>bit de paridade</strong> é um dos mecanismos mais simples de detecção de erros. Consiste em adicionar um único bit à mensagem original para que o total de bits com valor 1 na transmissão seja par (<em>paridade par</em>) ou ímpar (<em>paridade ímpar</em>).</p>
<p>Esse bit adicional permite detectar se ocorreu a inversão de um único bit durante a transmissão ou armazenamento. Contudo, não permite localizar o erro nem corrigi-lo, e não detecta alterações que envolvam um número par de bits.</p>
<hr />
<h2 id="paridade-par"><a class="header" href="#paridade-par">Paridade Par</a></h2>
<p>Garante que o número total de bits 1 na mensagem, incluindo o bit de paridade, seja par.</p>
<p>Exemplo:</p>
<pre><code>Mensagem original: 10101110 (8 bits)
Número de bits "1": 5 (impar)
Bit de paridade: 1  → Total de bits "1" passa a ser 6 (par)
Mensagem transmitida: 101011101
</code></pre>
<h2 id="paridade-Ímpar"><a class="header" href="#paridade-Ímpar">Paridade Ímpar</a></h2>
<p>Garante que o total de bits 1 seja ímpar.</p>
<pre><code>Mensagem original: 10101110
Número de bits "1": 5 (impar)
Bit de paridade: 0  → Total de bits "1" continua ímpar
Mensagem transmitida: 101011100
</code></pre>
<hr />
<h2 id="verificação"><a class="header" href="#verificação">Verificação</a></h2>
<p>O receptor recalcula a paridade da mensagem recebida (incluindo o bit de paridade) e verifica se o valor é coerente com a paridade esperada (par ou ímpar).</p>
<p>Exemplo de erro detectado:</p>
<pre><code>Transmissão esperada: 101011101 (paridade par)
Erro no terceiro bit:
Recebido: 101001101
Número de bits "1": 4 (paridade inesperada) → erro detectado
</code></pre>
<p>Erro não detectado (dois bits invertidos):</p>
<pre><code>Erro nos bits 2 e 6:
Original: 101011101
Recebido: 111001101
Número de bits "1": 6 (mesma paridade) → erro não detectado
</code></pre>
<hr />
<h2 id="implementação-em-go-4"><a class="header" href="#implementação-em-go-4">Implementação em Go</a></h2>
<pre><code class="language-go">package main

import (
	"fmt"
	"math/bits"
)

// Calcula paridade par (retorna 0 ou 1)
func parityBit(data byte) byte {
	if bits.OnesCount8(data)%2 == 0 {
		return 0 // já é par
	}
	return 1
}

// Verifica a paridade de um byte + bit extra
func checkParity(data byte, parity byte) bool {
	return parityBit(data) == parity
}

func main() {
	data := byte(0b10101110) // 5 bits 1
	parity := parityBit(data)
	fmt.Printf("Paridade calculada: %d\n", parity)

	valid := checkParity(data, parity)
	fmt.Printf("Verificação: %v\n", valid)

	// Simulando erro
	corrupted := data ^ 0b00000100 // inverte o bit 2
	valid = checkParity(corrupted, parity)
	fmt.Printf("Verificação após erro: %v\n", valid)
}
</code></pre>
<hr />
<h2 id="limitações-e-aplicabilidades"><a class="header" href="#limitações-e-aplicabilidades">Limitações e Aplicabilidades</a></h2>
<ul>
<li>Detecta apenas <strong>um erro de bit</strong>.</li>
<li>Não localiza nem corrige o erro.</li>
<li>Falha em detectar erros com número par de bits invertidos.</li>
<li>É adequado para ambientes com ruído limitado e simplicidade de hardware.</li>
</ul>
<h3 id="exemplos-de-uso"><a class="header" href="#exemplos-de-uso">Exemplos de uso:</a></h3>
<ul>
<li>Memórias RAM com detecção simples</li>
<li>Protocolos seriais (UART, RS-232)</li>
<li>Dispositivos com restrição de custo e complexidade</li>
<li>Parte de códigos de correção como Hamming</li>
</ul>
<hr />
<h2 id="considerações-finais-4"><a class="header" href="#considerações-finais-4">Considerações finais</a></h2>
<p>O bit de paridade ilustra o conceito central da detecção de erros com custo mínimo de redundância. Apesar de suas limitações, é historicamente importante e ainda aplicável em contextos restritos. Os próximos métodos que estudaremos, <strong>Checksums</strong> e <strong>CRC</strong>, vão superar essas limitações oferecendo maior poder de detecção sem aumento significativo de complexidade.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="checksum"><a class="header" href="#checksum">Checksum</a></h1>
<p>O checksum é a forma mais simples de verificação de integridade, sendo calculado somando os valores dos bytes ou palavras de um dado e armazenando essa soma junto com os dados. Ao receber ou ler os dados, a soma é recalculada e comparada com o checksum armazenado. Se os valores diferirem, isso indica um erro na transmissão ou no armazenamento.</p>
<h2 id="exemplo-de-checksum-simples-soma-de-bytes"><a class="header" href="#exemplo-de-checksum-simples-soma-de-bytes">Exemplo de Checksum Simples (Soma de Bytes)</a></h2>
<p>Vamos criar uma implementação básica de checksum em Go, somando os valores dos bytes da mensagem e calculando o módulo 256 para manter um valor fixo de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Função de checksum simples (soma dos bytes módulo 256)
func SimpleChecksum(data []byte) byte {
	var checksum byte = 0
	for _, b := range data {
		checksum += b
	}
	return checksum
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("Checksum de 'HELLO': 0x%X\n", SimpleChecksum(data))
}
</code></pre>
<p>Um algorítmo simples como o demonstrado acima possui algumas limitações importantes:</p>
<ul>
<li>Não detecta trocas na ordem dos bytes (ABC e CBA geram o mesmo checksum)</li>
<li>Colisões serão frequentes (diferentes mensagens podem gerar o mesmo valor de checksum)</li>
<li>Não detecta alguns tiopos de erro bit a bit</li>
</ul>
<p>Para resolver esses problemas, foram criadas versões mais sofisticadas, como o CRC.</p>
<h2 id="checksum-no-udpip"><a class="header" href="#checksum-no-udpip">Checksum no UDP/IP</a></h2>
<p>O protocolo UDP (User Datagram Protocol) e o cabeçalho IP (Internet Protocol) utilizam um checksum baseado em complemento de um, que é uma técnica mais avançada do que a simples soma de bytes. Esse método melhora a detecção de erros, sendo amplamente usado na transmissão de pacotes de rede.</p>
<p>Como o checksum do UDP/IP funciona?</p>
<ul>
<li>A mensagem (ou cabeçalho IP) é dividida em blocos de 16 bits.</li>
<li>Os blocos são somados usando aritmética de complemento de um.</li>
<li>O complemento de um do resultado final é armazenado como o checksum.</li>
<li>No destino, o receptor soma todos os blocos novamente, incluindo o checksum recebido.</li>
<li>Se o resultado for 0xFFFF, os dados são considerados íntegros; caso contrário, há erro na transmissão.</li>
</ul>
<p>Isso permite detectar a maioria dos erros comuns em transmissões de rede.</p>
<h3 id="implementação-do-checksum-udpip-em-go"><a class="header" href="#implementação-do-checksum-udpip-em-go">Implementação do Checksum UDP/IP em Go</a></h3>
<pre><code class="language-go">package main

import (
	"encoding/binary"
	"fmt"
)

// Função para calcular o checksum do UDP/IP usando complemento de um
func UDPChecksum(data []byte) uint16 {
	var sum uint32

	// Processa os dados em blocos de 16 bits
	for i := 0; i &lt; len(data)-1; i += 2 {
		// Converte dois bytes em um uint16
		word := binary.BigEndian.Uint16(data[i : i+2]) 
		
		sum += uint32(word)
	}

	// Se o número de bytes for ímpar, adiciona o último byte com padding
	if len(data)%2 != 0 {
		sum += uint32(data[len(data)-1]) &lt;&lt; 8
	}

	// Adiciona os "overflows" da soma (carry bits)
	for (sum &gt;&gt; 16) &gt; 0 {
		sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16)
	}

	// Retorna o complemento de um do resultado final
	return uint16(^sum)
}

func main() {
	data := []byte("HELLOUDP")
	checksum := UDPChecksum(data)
	fmt.Printf("Checksum UDP de 'HELLOUDP': 0x%X\n", checksum)
}

</code></pre>
<p>Essa implementação reflete como os protocolos UDP e IP realizam a verificação de integridade, garantindo que os pacotes de rede cheguem corretamente ao destino.</p>
<h3 id="implementação-do-crc-8-em-go"><a class="header" href="#implementação-do-crc-8-em-go">Implementação do CRC-8 em Go</a></h3>
<p>O CRC-8 é uma das versões mais simples, usando um polinômio de 8 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela CRC-8 para polinômio 0x07 (x^8 + x^2 + x + 1)
var crc8Table [256]byte

// Inicializa a tabela CRC-8
func init() {
	const poly = byte(0x07)
	for i := 0; i &lt; 256; i++ {
		crc := byte(i)
		for j := 0; j &lt; 8; j++ {
			if (crc &amp; 0x80) != 0 {
				crc = (crc &lt;&lt; 1) ^ poly
			} else {
				crc &lt;&lt;= 1
			}
		}
		crc8Table[i] = crc
	}
}

// Calcula CRC-8 para um conjunto de dados
func CRC8(data []byte) byte {
	crc := byte(0)
	for _, b := range data {
		crc = crc8Table[crc^b]
	}
	return crc
}

func main() {
	data := []byte("HELLO")
	fmt.Printf("CRC-8 de 'HELLO': 0x%X\n", CRC8(data))
}
</code></pre>
<p>O CRC, diferente do checksum, detecta trocas na ordem dos bytes, detecta erros simples de mútiplos bits errados e possui menor taxa de colisões. Mas o CRC-8 não é reistente a ataques maliciosos (não deve ser usado para segurança) e pode falhar na detecção de alguns padrões específicos de erro se o polinômio não for bem escolhido.</p>
<h2 id="variações-do-crc"><a class="header" href="#variações-do-crc">Variações do CRC</a></h2>
<p>CRC-16
CRC-32
CRC-64
Adler-32
Fletcher-16/32</p>
<p>Cada algoritmo tem um nível diferente de eficiência e resistência a erros. CRC-32, por exemplo, é usado no ZIP e no protocolo de rede Ethernet devido à sua confiabilidade e baixo custo computacional.</p>
<h2 id="considerações-finais-5"><a class="header" href="#considerações-finais-5">Considerações Finais</a></h2>
<p>O checksum é uma técnica básica e eficiente para detecção de erros simples, mas tem falhas para detecção de padrões mais complexos. O CRC usa divisão polinomial para criar uma verificação mais robusta contra corrupção de dados, sendo amplamente utilizado em redes e armazenamento. Nenhum desses métodos deve ser confundido com funções hash criptográficas, que garantem segurança contra alterações intencionais nos dados.</p>
<p>Se queremos segurança contra modificações maliciosas, devemos usar HMAC, SHA-256 ou outras funções hash seguras.</p>
<p>Agora que entendemos essas formas de verificação de integridade fraca, podemos avançar para a família MD (Message Digest), que evolui de checksums simples para funções hash mais sofisticadas.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="crc---cyclic-redundandy-check"><a class="header" href="#crc---cyclic-redundandy-check">CRC - Cyclic Redundandy Check</a></h1>
<p>O CRC (Cyclic Redundancy Check) é um método de detecção de erros baseado em operações matemáticas sobre polinômios binários. Em vez de apenas somar valores, o CRC trata os dados como um número binário e divide esse número por um polinômio pré-determinado, registrando o resto da divisão como código de verificação.</p>
<p>O CRC é amplamente usado em:</p>
<ul>
<li>Transmissões de rede (Ethernet, Wi-Fi)</li>
<li>Armazenamento de arquivos (ZIP, RAR)</li>
<li>Sistemas embarcados (CD-ROM, comunicações seriais)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hashing-e-sha-256"><a class="header" href="#hashing-e-sha-256">Hashing e SHA-256</a></h1>
<h2 id="introdução-3"><a class="header" href="#introdução-3">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/hash/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hashing-e-sha-256-1"><a class="header" href="#hashing-e-sha-256-1">Hashing e SHA-256</a></h1>
<h2 id="introdução-4"><a class="header" href="#introdução-4">Introdução</a></h2>
<p>Funções hash são operações matemáticas que transformam uma entrada de qualquer tamanho em uma saída de tamanho fixo. Para uma mesma entrada, a saída gerada será sempre a mesma.</p>
<p>Uma das principais propriedades das funções hash é que a operação é irreversível, ou seja, não é possível obter a entrada original a partir da saída gerada.</p>
<p>Além disso, o tamanho da saída é sempre fixo, independentemente do tamanho da entrada. Isso significa que uma entrada curta e uma entrada muito longa geram um hash com a mesma quantidade de bits.</p>
<p>Embora seja esperado que entradas diferentes gerem hashes diferentes, existe a possibilidade de colisões, onde duas entradas distintas podem produzir o mesmo hash. A qualidade da função hash está diretamente ligada à sua capacidade de minimizar essas colisões.</p>
<p>Para começar, vamos criar uma função hash simples e passar por todos os pontos mencionados acima. Nossa função hash vai fazer o seguinte: dada uma entrada, somamos os valores ASCII da entrada e dessa soma obtemos o módulo 256, ou seja, teremos sempre um valor entre 0 e 255 não importando o tamanho da entrada. Acompanhe:</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

func simpleHash(in string) int {
    hash := 0
    for _, char := range in {
        hash += int(char)
    }
    return hash % 256
}

func main() {
	input1 := "willams sousa"
	input2 := "Go"
	input3 := "xyz"

    fmt.Printf("Hash de '%v':%v\n", input1, simpleHash(input1))
    fmt.Printf("Hash de '%v':%v\n", input2, simpleHash(input2))
    fmt.Printf("Hash de '%v':%v\n", input3, simpleHash(input3))
}
</code></pre>
<p>Nosso simpleHash tem apenas 256 saídas possíveis, mas pode processar infinitas entradas distintas. Isso inevitavelmente leva a colisões, pois, pelo Princípio da Pomba (Pigeonhole Principle), há mais entradas possíveis do que saídas distintas.</p>
<p>Por exemplo, todo palíndromo leva a colisões, pois a soma é uma operação comutativa, e a soma dos códigos ASCII dessas strings produz sempre o mesmo valor, independentemente da ordem dos caracteres. Mas esse problema não se restringe apenas a palíndromos. A string "wow" e "zft" também colidem, pois:</p>
<ul>
<li>"wow" → w=119, o=111, w=119 → 119 + 111 + 119 = 349</li>
<li>"zft" → z=122, f=102, t=125 → 122 + 102 + 125 = 349</li>
</ul>
<p>Isso demonstra que a ordem dos caracteres não é levada em conta, resultando em muitas colisões.</p>
<p>Propriedades de funções hash aplicadas ao simpleHash:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Determinística: Para a mesma entrada, sempre obtemos a mesma saída.</li>
<li><input disabled="" type="checkbox"/>
Irreversível: Nossa função não é verdadeiramente irreversível, pois permite encontrar entradas compatíveis facilmente.</li>
<li><input disabled="" type="checkbox"/>
Alta entropia e efeito avalanche: Pequenas mudanças na entrada não causam mudanças drásticas no hash.</li>
<li><input disabled="" type="checkbox"/>
Resistência à pré-imagem: Se tivermos o valor H, podemos facilmente encontrar um X tal que hash(X) = H, devido ao baixo espaço de saída.</li>
<li><input disabled="" type="checkbox" checked=""/>
Saída de tamanho fixo: A saída sempre tem 256 valores possíveis, independentemente do tamanho da entrada.</li>
</ul>
<p>Apesar disso, nosso algoritmo parece irreversível, mas pelos motivos errados! Devido à enorme incidência de colisões, não temos como saber qual foi a entrada exata que gerou determinada saída. Isso, porém, não é uma característica desejável em uma função hash criptográfica.</p>
<p><img src="conceitos/hash/images/image.png" alt="Simple Hash" /></p>
<p>Podemos melhorar nossa função hash usando multiplicação por um fator primo melhorando a dispersão e reduzindo colisões triviais. P.ex:</p>
<pre><code class="language-go">func betterHash(input string) int {
    hash := 0
    prime := 31 // Usar um número primo ajuda a dispersar os valores
	for i, char := range input {
		hash = hash*prime + int(char)
	}
	return hash &amp; 0xFFFFFFFF // tamanho fixo (32 bits)
}
</code></pre>
<p>Contudo, o espaço da saída ainda é muito pequeno, estamos limitando a saída a 32 bits. Para grandes volumes de dados as colisões ainda serão inevitáveis e o algorítmo também não é resistente a pré-imagem. Além disso, pequenas mudanças na entrada não afetam significativamente a saída (efeito avalanche).</p>
<p>Esses exemplos foram um ótimo ponto de partida, mas a computação exigiu funções hash mais poderosas. Vamos analisar como os algoritmos evoluíram ao longo do tempo até chegarmos às soluções modernas, como o SHA-256.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-md---message-digest"><a class="header" href="#família-de-algoritmos-md---message-digest">Família de Algoritmos MD - Message Digest</a></h1>
<h2 id="md2"><a class="header" href="#md2">MD2</a></h2>
<p>O primeiro algoritmo amplamente publicado da família MD (Message Digest) foi o MD2 e foi desenvolvido por Ronald Rivest em 1989 (não achei nenhuma publicação do MD1 nem do MD3). Ele foi projetado especificamente para computadores de 8 bits. Apesar de ter sido uma inovação importante, o MD2 se tornou obsoleto com o tempo devido a ataques criptográficos bem-sucedidos. Suas principais características eram:</p>
<ul>
<li>Tamanho da saída: 128 bits (16 bytes)</li>
<li>Entrada de tamanho variável</li>
<li>Projetado para máquinas de 8 bits</li>
<li>Inseguro desde 2004 devido a ataques práticos</li>
<li>Lento em hardware moderno devido à otimização para 8 bits</li>
</ul>
<h3 id="como-o-md2-funciona"><a class="header" href="#como-o-md2-funciona">Como o MD2 Funciona?</a></h3>
<p>A especificação do MD2 pode ser encontrada na RFC 1319. Esse algorítmo transforma qualquer entrada em um hash de 128bits. Ele faz isso seguindo 3 etapas principais:</p>
<h4 id="1---padding"><a class="header" href="#1---padding">1 - Padding</a></h4>
<p>Para garantir que o tamanho da entrada seja um múltiplo de 16 bytes, adicionamos bytes de padding no final. A regra é a seguinte:</p>
<ul>
<li>se o tamanho da mensagem já for múltiplo de 16, adicionamos 16 bytes com o valor 0x10 (16 em decimal).</li>
<li>se faltar N bytes para completar 16, adicionamos N bytes com o valor de N.</li>
</ul>
<p>Exemplo:</p>
<p><img src="conceitos/hash/images/padding-md2.png" alt="Padding MD2" /></p>
<p>Ou seja:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Etapa</strong></th><th><strong>Dados</strong></th></tr></thead><tbody>
<tr><td><strong>Entrada original</strong></td><td>Hexa: <code>[41 42 43]</code> = <code>"ABC"</code></td></tr>
<tr><td><strong>Tamanho</strong></td><td><strong>3 bytes</strong></td></tr>
<tr><td><strong>Padding necessário</strong></td><td><code>16 - 3 = 13</code> bytes</td></tr>
<tr><td><strong>Preenchimento</strong></td><td><strong>Faltam 13 bytes</strong>, então usamos <code>0x0D</code> (13)</td></tr>
<tr><td><strong>Resultado final</strong></td><td><code>[41 42 43 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D 0D]</code></td></tr>
</tbody></table>
</div>
<p>Se a entrada tivesse 15 bytes, haveria um padding de 1 byte com o valor 0x01, se tivesse exatamente 16 bytes, faríamos um padding de mais 16 bytes com o valor 0x10 (16 em decimal), e assim por diante.</p>
<h4 id="2---checksum"><a class="header" href="#2---checksum">2 - Checksum</a></h4>
<p>O MD2 adiciona um checksum de 16 bytes, que é computado iterando sobre a mensagem e aplicando XOR com uma tabela de permutação.</p>
<p>Essa tabela de permutação S-box (256 valores) foi escolhida manualmente por Rivest e é baseada em uma permutação "aleatória" dos dígitos de Pi.</p>
<p>Uma S-box (Substitution Box) é uma tabela de substituição não linear usada em criptografia para aumentar a confusão, um conceito fundamental introduzido por Claude Shannon em seu estudo seminal sobre teoria da criptografia (Shannon, 1949)[1].</p>
<p>O objetivo do checksum no MD2 é adicionar redundância e garantir que qualquer alteração na mensagem original impacte significativamente o resultado final. O checksum não serve como verificação de integridade tradicional (como em CRCs), mas sim para aumentar a resistência do algoritmo contra colisões.</p>
<h5 id="como-o-checksum-é-calculado"><a class="header" href="#como-o-checksum-é-calculado">Como o Checksum é Calculado?</a></h5>
<p>A cada bloco de 16 bytes da mensagem (com padding já aplicado), percorremos byte a byte e atualizamos o checksum usando a tabela S-Box.</p>
<p>O cálculo segue a seguinte fórmula:</p>
<pre><code>C[j] = C[j] XOR S[M[i * 16 + j] XOR L]
L = C[j]
</code></pre>
<p>Onde:</p>
<ul>
<li>C[j] -&gt; byte j do checksum</li>
<li>M[i * 16 + j] -&gt; byte j do bloco i da mensagem</li>
<li>S[x] -&gt; S-Box, uma tabela de substituição com 256 valores, indexada pelo resultado do XOR</li>
<li>L -&gt; Último valor atualizado do checksum, começando com 0.</li>
</ul>
<p>Veja um passo a passo com valores reais:</p>
<p>Suponha que:</p>
<ul>
<li>C[3] = 0xA5</li>
<li>M[3] = 0x7F</li>
<li>L = 0x2C</li>
<li>S[0x53] = 0xD4 (porque 0x7F XOR 0x2C = 0x53)</li>
</ul>
<p>Agora, aplicamos:</p>
<pre><code>C[3] = C[3] XOR S[ M[3] XOR L ]
     = 0xA5 XOR S[0x53]
     = 0xA5 XOR 0xD4
     = 0x71

L = C[3] = 0x71

</code></pre>
<p>Essa fase adiciona o efeito de difusão na mensagem antes da fase final.</p>
<p>A difusão é um conceito introduzido por Claude Shannon [Shannon, 1949] [1], onde pequenas mudanças na entrada devem se espalhar por toda a saída, dificultando a recuperação do texto original a partir do hash ou da cifra</p>
<p>Após processar todos os blocos, os 16 bytes do checksum são anexados à mensagem.</p>
<h5 id="implementação-em-go-5"><a class="header" href="#implementação-em-go-5">Implementação em Go</a></h5>
<pre><code class="language-go">var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
	251, 140, 206, 36, 255, 96, 147, 158, 69, 48, 36, 136, 74, 95, 35, 94,
	191, 249, 189, 14, 125, 77, 135, 55, 146, 147, 238, 93, 139, 140, 74, 38,
	192, 89, 246, 116, 40, 158, 136, 171, 166, 123, 101, 26, 52, 36, 252, 176,
	191, 226, 174, 121, 38, 160, 202, 64, 141, 197, 210, 251, 144, 45, 47, 157,
	202, 121, 128, 192, 105, 111, 94, 108, 218, 158, 71, 89, 152, 76, 108, 188,
	50, 203, 61, 117, 158, 140, 76, 144, 55, 199, 24, 97, 46, 24, 94, 82,
	113, 72, 54, 86, 109, 98, 125, 204, 159, 107, 38, 249, 72, 36, 84, 113,
	194, 250, 70, 161, 78, 245, 121, 158, 239, 190, 42, 222, 104, 63, 93, 106,
	242, 216, 64, 122, 174, 210, 194, 79, 124, 55, 198, 156, 168, 40, 56, 156,
	64, 54, 73, 87, 179, 51, 173, 40, 180, 199, 47, 105, 26, 43, 76, 174,
	45, 195, 89, 147, 67, 252, 184, 248, 128, 137, 223, 62, 142, 119, 196, 32,
	32, 129, 107, 244, 153, 178, 61, 134, 240, 144, 47, 226, 121, 69, 116, 48,
	155, 158, 112, 164, 109, 140, 167, 220, 111, 115, 137, 187, 61, 122, 82, 194,
	218, 102, 243, 99, 208, 172, 193, 141, 145, 226, 218, 162, 232, 64, 202, 47,
	118, 164, 108, 173, 98, 217, 187, 178, 244, 130, 108, 78, 122, 84, 133, 150,
}

func computeChecksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0 // Inicializa L com 0

	// Percorre a mensagem em blocos de 16 bytes
	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			c := message[i+j]
			checksum[j] ^= SBox[c^L] // Calcula o novo valor do checksum
			L = checksum[j]           // Atualiza L para o próximo passo
		}
	}
	return checksum
}
</code></pre>
<h4 id="3---processamento-principal"><a class="header" href="#3---processamento-principal">3 - Processamento Principal</a></h4>
<p>Agora pegamos a <strong>mensagem com padding</strong> e <strong>checksum</strong> e a processamos utilizando um buffer intermediário de <strong>48 bytes</strong>. O objetivo desta fase é misturar os dados de forma não linear para aumentar a resistência a colisões.</p>
<p>Diferente de outros algoritmos como o MD4 e MD5, que usam operações de <strong>rotação bitwise</strong> para aumentar a difusão dos bits, o MD2 utiliza <strong>apenas operações XOR e tabelas de substituição</strong> (S-Box). Isso se deve ao fato de que ele foi projetado para <strong>arquiteturas de 8 bits</strong>, onde operações bitwise mais complexas poderiam ser ineficientes.</p>
<h5 id="estrutura-do-buffer-de-48-bytes"><a class="header" href="#estrutura-do-buffer-de-48-bytes">Estrutura do Buffer de 48 Bytes</a></h5>
<p>O <strong>buffer de processamento</strong> (<code>X</code>) é um array de <strong>48 bytes</strong>, onde os primeiros <strong>16 bytes</strong> armazenam o hash intermediário, os <strong>segundos 16 bytes</strong> armazenam um bloco da mensagem e os <strong>últimos 16 bytes</strong> contêm a mistura do bloco da mensagem com os primeiros 16 bytes.</p>
<pre><code>X = [H(0) H(1) .. H(15) | M(0) M(1)... M(15) | H(0) XOR M(0), ... , H(15) XOR M(15)]
</code></pre>
<p>Onde:</p>
<ul>
<li><code>H</code> representa os primeiros 16 bytes do buffer, que armazenam o estado atual do hash.</li>
<li><code>M</code> representa os 16 bytes do bloco da mensagem sendo processado.</li>
</ul>
<h5 id="etapas-do-processamento"><a class="header" href="#etapas-do-processamento">Etapas do Processamento</a></h5>
<p>A cada <strong>bloco de 16 bytes</strong>, fazemos o seguinte:</p>
<ol>
<li><strong>Copiamos o bloco da mensagem (<code>M</code>) para os bytes 16 a 31</strong> do buffer.</li>
<li><strong>Criamos a mistura dos primeiros 16 bytes (<code>H</code>) com o bloco <code>M</code></strong>, armazenando nos bytes 32 a 47.</li>
<li>Executamos 18 rodadas de processamento, onde aplicamos XOR sequencialmente nos 48 bytes do buffer usando a tabela S-Box. O número 18 não foi escolhido arbitrariamente: ele está relacionado ao fato de que o MD2 foi projetado para rodar eficientemente em arquiteturas de 8 bits. Como a S-Box tem 256 valores possíveis (8 bits), e um bloco do MD2 possui 16 bytes, Rivest determinou que 18 rodadas forneciam difusão suficiente sem comprometer o desempenho em hardware de baixa capacidade. Esse valor foi escolhido de forma empírica para equilibrar segurança e eficiência computacional.</li>
</ol>
<p>Cada rodada segue esta fórmula:</p>
<pre><code>X[j] = X[j] XOR SBox[T]
T = X[j]
</code></pre>
<p>Sendo que <code>T</code> é um acumulador que começa em zero e é atualizado ao longo da iteração.</p>
<p>Isso garante que o hash seja alterado a cada rodada, propagando as mudanças nos bytes de maneira não linear.</p>
<h5 id="exemplo-de-transformação"><a class="header" href="#exemplo-de-transformação">Exemplo de Transformação</a></h5>
<p>Suponha que o buffer <code>X</code> comece com:</p>
<pre><code>X = [ A1 A2 ... A16 | B1 B2 ... B16 | C1 C2 ... C16 ]
</code></pre>
<p>Após aplicar a <strong>permutação com a S-Box</strong>, obtemos:</p>
<pre><code>X' = [ P1 P2 ... P16 | Q1 Q2 ... Q16 | R1 R2 ... R16 ]
</code></pre>
<p>Essa transformação acontece <strong>18 vezes</strong>, garantindo uma alta difusão dos bits.</p>
<p>A implementação do <strong>processamento principal</strong> segue abaixo:</p>
<pre><code class="language-go">func processMD2Blocks(message []byte) [16]byte {
	var X [48]byte // Buffer intermediário de 48 bytes

	for i := 0; i &lt; len(message); i += 16 {
		// Copia o bloco da mensagem para os bytes 16 a 31 do buffer
		copy(X[16:32], message[i:i+16])

		// Preenche os últimos 16 bytes com H ⊕ M
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0

		// 18 rodadas de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T] // Permutação não linear usando a S-Box
				T = X[j]        // Atualiza T
			}
			T += byte(round) // Incrementa T a cada rodada
		}
	}

	// O hash final é extraído dos primeiros 16 bytes do buffer X
	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}
</code></pre>
<h5 id="conceitos-aplicados"><a class="header" href="#conceitos-aplicados">Conceitos Aplicados</a></h5>
<p>Este processamento principal do MD2 explora três princípios fundamentais da criptografia:</p>
<p>Confusão ([Shannon, 1949][1])
A permutação S-Box adiciona um grau de não linearidade ao algoritmo, tornando difícil estabelecer relações diretas entre a entrada e a saída.</p>
<p>Difusão ([Shannon, 1949][1])
Cada byte do hash final depende de todos os bytes da mensagem de entrada, devido à aplicação iterativa da S-Box e do XOR.</p>
<p>Avalanche Effect
Pequenas mudanças na entrada resultam em grandes mudanças no hash, pois cada rodada mistura bits de diferentes partes da mensagem.</p>
<p>Após esse processo, os primeiros 16 bytes do buffer X formam o hash MD2 final.</p>
<h3 id="implementação-completa-do-algoritmo-md2-em-go"><a class="header" href="#implementação-completa-do-algoritmo-md2-em-go">Implementação Completa do Algoritmo MD2 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Tabela de permutação S-box
var S = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	// (o restante foi omitido por brevidade, consulte a RFC 1319)
}

func MD2(input []byte) [16]byte {
	// Parte 1: Padding
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	input = append(input, padding...)

	// Parte 2: Checksum
	var checksum [16]byte
	var L byte = 0
	for i := 0; i &lt; len(input); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= S[input[i+j]^L]
			L = checksum[j]
		}
	}
	input = append(input, checksum[:]...)

	// Parte 3: Transformação Principal
	var X [48]byte
	
    for i := 0; i &lt; len(input); i += 16 {
		
        // Copia bloco para X
		copy(X[16:32], input[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[16+j] ^ X[j]
		}
		var t byte = 0

		// 18 rounds de processamento
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= S[t]
				t = X[j]
			}
			t += byte(round)
		}
	}

	// O hash final está nos primeiros 16 bytes de X
	var hash [16]byte
	
    copy(hash[:], X[:16])
	
    return hash
}

func main() {
	data := []byte("Mensagem de teste")
	hash := MD2(data)
	fmt.Printf("MD2 Hash: %x\n", hash)
}
</code></pre>
<h2 id="md4---a-evolução-do-message-digest"><a class="header" href="#md4---a-evolução-do-message-digest">MD4 - A Evolução do Message Digest</a></h2>
<p>O MD4 (Message Digest 4) foi desenvolvido por Ronald Rivest em 1990 como uma melhoria do MD2, projetado especificamente para processadores de 32 bits. Ele introduziu um novo modelo de operação baseado em três rodadas de funções não lineares, tornando-o muito mais rápido que o MD2.</p>
<p>No entanto, o MD4 é extremamente fraco e foi quebrado rapidamente. Mesmo assim, sua estrutura inspirou diretamente o MD5 e SHA-1, servindo de base para os algoritmos de hash modernos e que veremos logo mais.</p>
<h3 id="como-o-md4-funciona"><a class="header" href="#como-o-md4-funciona">Como o MD4 Funciona?</a></h3>
<p>A especificação do MD4 pode ser encontrada na RFC 1320. O algoritmo transforma qualquer entrada em um hash de 128 bits usando 3 rodadas de operações baseadas em soma modular e funções booleanas.</p>
<p>O MD4 segue 4 etapas principais:</p>
<p>1 - Padding</p>
<ul>
<li>O comprimento da mensagem é ajustado para que seja múltiplo de 512 bits (64 bytes).</li>
<li>Um bit 1 é adicionado, seguido de zeros até que faltem 64 bits para completar um bloco.</li>
<li>Os últimos 64 bits armazenam o tamanho original da mensagem (antes do padding)</li>
</ul>
<p>Exemplo:</p>
<p>Se tivermos a mensagem "abc", que tem 24 bits (3 bytes), adicionamos:</p>
<pre><code>01100001 01100010 01100011 10000000 00000000 ... (até completar 448 bits)

</code></pre>
<p>E então adicionamos os 64 bits finais contendo o tamanho da mensagem.</p>
<p>2 - Inicialização dos Registradores</p>
<p>MD4 usa quatro registradores de 32 bits, inicializados com valores fixos:</p>
<pre><code>A = 0x67452301
B = 0xEFCDAB89
C = 0x98BADCFE
D = 0x10325476

</code></pre>
<p>Esses valores são inspirados na constante da raiz quadrada de números primos.</p>
<p>3 - Processamento em 3 Rodadas</p>
<p>A mensagem é dividida em blocos de 512 bits (64 bytes), e cada bloco passa por três rodadas de operações matemáticas:</p>
<p>3.1 - Função F (AND, OR, NOT)</p>
<pre><code>F(X, Y, Z) = (X AND Y) OR (NOT X AND Z)

</code></pre>
<p>Essa função favore um dos valores (X) e ajuda na difusão.</p>
<p>3.2 - Função G (Majority Vote)</p>
<pre><code>G(X, Y, Z) = (X AND Y) OR (X AND Z) OR (Y AND Z)

</code></pre>
<p>Utiliza uma "votação" entre os três valores.</p>
<p>3.3 - Função H (XOR)</p>
<pre><code>H(X, Y, Z) = X XOR Y XOR Z

</code></pre>
<p>Mistura os bits de forma caótica.</p>
<p>Cada uma dessas funções é aplicada a cada bloco de 512 bits da mensagem, alterando os registradores A, B, C e D.</p>
<p>4 - Hash Final</p>
<p>Após todas as rodadas, os valores finais dos registradores A, B, C e D são concatenados para formar um hash de 128 bits (16 bytes).</p>
<h3 id="implementação-do-md4-em-go"><a class="header" href="#implementação-do-md4-em-go">Implementação do MD4 em Go</a></h3>
<pre><code class="language-go">package main

import (
	"crypto/md2"
	"encoding/hex"
	"fmt"
	"golang.org/x/crypto/md2" // Biblioteca oficial do Go para MD2
)

// Tabela de permutação S-box (definida na RFC 1319)
var SBox = [256]byte{
	41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19,
	98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202,
	30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18,
	190, 78, 130, 235, 167, 56, 19, 64, 70, 57, 64, 195, 148, 36, 198, 28,
	242, 101, 37, 149, 184, 120, 215, 68, 76, 168, 73, 226, 70, 32, 62, 203,
	113, 107, 34, 82, 178, 175, 212, 81, 78, 100, 212, 180, 38, 186, 59, 113,
	79, 52, 202, 51, 89, 197, 60, 22, 184, 79, 63, 174, 196, 142, 95, 35,
	235, 221, 169, 128, 248, 105, 194, 54, 204, 134, 179, 227, 91, 225, 92, 239,
	191, 138, 75, 209, 123, 112, 147, 131, 175, 148, 100, 245, 196, 56, 109, 92,
	241, 241, 107, 206, 161, 24, 108, 72, 85, 176, 46, 130, 187, 20, 166, 76,
	101, 150, 53, 216, 38, 244, 186, 155, 43, 80, 231, 49, 205, 18, 38, 141,
	106, 169, 173, 89, 151, 152, 145, 232, 165, 29, 214, 32, 212, 185, 58, 5,
	208, 141, 116, 55, 63, 158, 98, 164, 218, 228, 67, 193, 66, 56, 55, 96,
	197, 61, 91, 164, 216, 21, 55, 249, 245, 77, 117, 193, 179, 75, 89, 217,
	244, 51, 96, 191, 166, 63, 131, 250, 48, 219, 41, 56, 154, 81, 70, 196,
}

// Aplicar Padding conforme RFC 1319
func md2Padding(input []byte) []byte {
	paddingSize := 16 - (len(input) % 16)
	padding := make([]byte, paddingSize)
	for i := range padding {
		padding[i] = byte(paddingSize)
	}
	return append(input, padding...)
}

// Calcular Checksum
func md2Checksum(message []byte) [16]byte {
	var checksum [16]byte
	var L byte = 0

	for i := 0; i &lt; len(message); i += 16 {
		for j := 0; j &lt; 16; j++ {
			checksum[j] ^= SBox[message[i+j]^L]
			L = checksum[j]
		}
	}

	return checksum
}

// Aplicar Transformação Principal
func md2Transform(message []byte) [16]byte {
	var X [48]byte

	for i := 0; i &lt; len(message); i += 16 {
		copy(X[16:32], message[i:i+16])
		for j := 0; j &lt; 16; j++ {
			X[32+j] = X[j] ^ X[16+j]
		}

		var T byte = 0
		for round := 0; round &lt; 18; round++ {
			for j := 0; j &lt; 48; j++ {
				X[j] ^= SBox[T]
				T = X[j]
			}
			T += byte(round)
		}
	}

	var hash [16]byte
	copy(hash[:], X[:16])
	return hash
}

// Função principal MD2
func MD2(input []byte) [16]byte {
	padded := md2Padding(input)
	checksum := md2Checksum(padded)
	message := append(padded, checksum[:]...)
	return md2Transform(message)
}

// Função para comparar com a implementação oficial
func compareWithLibrary(input string) {
	hash := MD2([]byte(input))
	fmt.Printf("Nosso MD2: %x\n", hash)

	libHash := md2.New()
	libHash.Write([]byte(input))
	fmt.Printf("MD2 OpenSSL: %x\n", libHash.Sum(nil))
}

func main() {
	testInput := "Mensagem de teste"
	compareWithLibrary(testInput)
}

</code></pre>
<p>Podemos comparar também com o openssl para ver se a mensagem bate:</p>
<pre><code class="language-bash">echo -n "Mensagem de teste" | openssl md2
</code></pre>
<h4 id="ataques-contra-o-md4"><a class="header" href="#ataques-contra-o-md4">Ataques Contra o MD4</a></h4>
<p>O MD4 foi um grande avanço na época, mas também teve falhas graves de segurança. Aqui, exploramos os ataques mais relevantes que levaram à sua obsolescência.</p>
<p>1 - Ataque de Colisão (1995) - Hans Dobbertin</p>
<p>Em 1995, o criptógrafo Hans Dobbertin publicou um ataque prático contra o MD4, demonstrando que era possível encontrar colisões em alguns segundos.</p>
<p>Isso quebra a confiabilidade do algoritmo, pois qualquer atacante pode substituir um documento sem alterar seu hash.</p>
<p>Como Dobbertin quebrou o MD4?
Ele explorou fraquezas estruturais nas três rodadas do MD4, usando um método conhecido como differential cryptanalysis.</p>
<p>Ele encontrou colisões em menos de 1 minuto usando um computador comum da época!</p>
<p>2 - Ataque de Colisão Rápido (2007) - Wang et al.</p>
<p>Em 2007, Xiaoyun Wang, Hongbo Yu e Yiqun Lisa Yin aprimoraram os ataques de Dobbertin e conseguiram gerar colisões em tempo real.</p>
<p>3 - Ataque de Pré-imagem (2009)</p>
<p>Em 2009, pesquisadores mostraram que dado um hash MD4, era possível reconstruir uma entrada que produzia o mesmo valor.</p>
<p>Esse ataque é catastrófico para aplicações que dependem de integridade, como assinaturas digitais.</p>
<p>4 - Ataque a Senhas no NTLM (Windows)</p>
<p>O MD4 foi usado no NTLM (Microsoft Windows Authentication). Como os ataques de colisão e pré-imagem são rápidos, foi possível quebrar senhas NTLM em milissegundos.</p>
<h3 id="implementando-um-ataque-de-colisão-contra-md4-em-go"><a class="header" href="#implementando-um-ataque-de-colisão-contra-md4-em-go">Implementando um Ataque de Colisão Contra MD4 em Go</a></h3>
<p>Vamos gerar duas mensagens diferentes com o mesmo hash.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

// Simulação de colisão no MD4
func findCollision() {
	msg1 := []byte("Ataque123")
	msg2 := []byte("At4que123") // Alteração mínima

	hash1 := md4(msg1)
	hash2 := md4(msg2)

	fmt.Printf("Mensagem 1: %s\nHash 1: %x\n", msg1, hash1)
	fmt.Printf("Mensagem 2: %s\nHash 2: %x\n", msg2, hash2)

	if hash1 == hash2 {
		fmt.Println("Colisão encontrada!")
	} else {
		fmt.Println("Nenhuma colisão encontrada.")
	}
}

func main() {
	findCollision()
}

</code></pre>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-des---data-encryption-standard"><a class="header" href="#família-de-algoritmos-des---data-encryption-standard">Família de Algoritmos DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="família-de-algoritmos-sha---secure-hash-algorithms"><a class="header" href="#família-de-algoritmos-sha---secure-hash-algorithms">Família de Algoritmos SHA - Secure Hash Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="pbkdf2-argon2-e-scrypt---hash-para-senhas"><a class="header" href="#pbkdf2-argon2-e-scrypt---hash-para-senhas">PBKDF2, Argon2 e Scrypt - Hash para Senhas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="criptografia-simétrica"><a class="header" href="#criptografia-simétrica">Criptografia Simétrica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introdução-e-contexto"><a class="header" href="#introdução-e-contexto">Introdução e Contexto</a></h1>
<p>Antes de apresentar teoria e implementação, exploraremos os fundamentos históricos, conceituais e práticos da criptografia simétrica. Entender por que ela foi desenvolvida, como evoluiu e quais são suas limitações e aplicações atuais é essencial para contextualizar os algoritmos que estudaremos a seguir.</p>
<p>Vamos abordar:</p>
<ul>
<li>história e contexto da criptografia simétrica;</li>
<li>A distinção entre cifras de fluxo e de bloco;</li>
<li>Como a criptografia evoluiu no contexto militar, político e computacional;</li>
<li>Quem foram os principais nomes envolvidos em sua criação e padronização;</li>
<li>E o papel da criptografia simétrica no mundo atual.</li>
</ul>
<p>Este contexto é essencial para que, ao estudar algoritmos como DES, RC4 e AES, você enxergue mais do que código: veja as decisões, problemas e soluções que moldaram cada etapa dessa tecnologia.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="o-que-é-criptografia-simétrica"><a class="header" href="#o-que-é-criptografia-simétrica">O que é criptografia simétrica</a></h2>
<p>A criptografia simétrica é um tipo de criptografia em que a mesma chave é usada tanto para cifrar quanto para decifrar dados. Isso significa que quem envia e quem recebe precisam ter acesso à mesma chave secreta — o que implica em um desafio logístico importante: a troca segura dessa chave.</p>
<p>Esse modelo contrasta com a criptografia assimétrica, onde as chaves de cifragem e decifragem são diferentes. A criptografia simétrica é, em geral, mais rápida e simples de implementar. É usada em grande escala em sistemas que exigem desempenho, como conexões seguras, discos criptografados, redes privadas virtuais (VPNs) e proteção de arquivos.</p>
<p>A segurança dos algoritmos simétricos depende totalmente da chave: se ela for descoberta ou mal protegida, todo o sistema fica vulnerável. Isso torna a gestão de chaves um ponto crítico.</p>
<p>Existem dois grandes grupos de cifras simétricas: <strong>cifras de fluxo</strong>, que processam dados em sequência contínua, e <strong>cifras de bloco</strong>, que operam sobre blocos fixos de bits. Essa distinção será explorada na próxima seção.</p>
<hr />
<h2 id="breve-história-da-criptografia-moderna"><a class="header" href="#breve-história-da-criptografia-moderna">Breve história da criptografia moderna</a></h2>
<p>A criptografia existe desde a antiguidade, mas a criptografia moderna começa a tomar forma no século XX. Nesse período, a guerra, a espionagem e o surgimento da computação moldaram os fundamentos do campo. Foi um momento em que o sigilo deixou de ser apenas uma ferramenta diplomática ou militar isolada, e passou a influenciar diretamente estratégias geopolíticas e o curso da história.</p>
<p>Antes dos computadores, cifras como a <strong>de César</strong>, as transposições e artefatos físicos como as escítalas espartanas eram comuns. Elas já aplicavam ideias de confusão e difusão, mesmo sem formalização matemática.</p>
<p>Durante a Segunda Guerra Mundial, a criptografia ganhou escala e importância estratégica. Máquinas como a <strong>Enigma</strong>, da Alemanha, e a <strong>Purple</strong>, do Japão, exigiram o uso de técnicas de criptoanálise sistemática — o que levou à criação dos primeiros computadores.</p>
<p>A quebra da Enigma pelos aliados, liderada pelos trabalhos em <strong>Bletchley Park</strong>, não foi apenas um feito técnico: estima-se que tenha encurtado a guerra em pelo menos dois anos e salvado milhões de vidas. O esforço envolveu matemáticos como <strong>Alan Turing</strong> e <strong>Gordon Welchman</strong>, mas também operadores, linguistas e especialistas em interceptação de sinais. O impacto foi tão profundo que grande parte do projeto permaneceu classificado por décadas.</p>
<p>No caso da Purple, os norte-americanos, liderados por William Friedman e sua equipe, conseguiram reconstruir completamente a lógica da máquina japonesa sem nunca terem visto um exemplar. A partir da análise de padrões e repetições em mensagens interceptadas, conseguiram acessar comunicações diplomáticas e militares de alto nível.</p>
<p>No pós-guerra, os EUA padronizaram internamente o uso de sistemas como a <strong>SIGABA</strong>, que incorporava mecanismos de troca aleatória de rotores para evitar padrões repetitivos, dificultando a criptoanálise. Já a União Soviética operava com a <strong>FIALKA</strong>, uma evolução da Enigma com recursos adicionais como verificação redundante e alfabetos em cirílico.</p>
<p>Essas máquinas mostraram limites fundamentais da abordagem mecânica. Elas eram grandes, caras, lentas, e exigiam sincronização precisa entre remetente e receptor. Além disso, vulnerabilidades práticas — como reutilização de configurações ou erros de operador — tornavam o sistema quebrável mesmo sem falhas matemáticas.</p>
<p>Com o avanço da eletrônica e da computação, tornou-se inevitável o desenvolvimento de algoritmos puramente digitais. Na década de 1970, a IBM desenvolveu o <strong>Lucifer</strong>, que, com a colaboração da NSA, se transformaria no <strong>DES</strong> — o primeiro algoritmo de cifra simétrica padronizado para uso civil. Isso marcou uma mudança de paradigma: a criptografia saiu do domínio exclusivamente governamental e passou a fazer parte da infraestrutura de empresas, bancos e, eventualmente, da internet.</p>
<p>Concursos como o do <strong>AES</strong>, e mais tarde o <strong>eSTREAM</strong>, marcaram a transição para uma era de padronizações abertas, revisão por pares e competição internacional entre algoritmos candidatos. Esses processos mostraram que segurança não é apenas uma questão técnica, mas também política, institucional e social.</p>
<p>A criptografia moderna nasceu da necessidade urgente de vencer guerras — mas sobreviveu, amadureceu e se democratizou como uma das bases fundamentais da era digital.</p>
<p>A criptografia existe desde a antiguidade, mas a criptografia moderna começa a tomar forma no século XX. Nesse período, a guerra, a espionagem e o surgimento da computação moldaram os fundamentos do campo.</p>
<p>Antes dos computadores, cifras como a <strong>de César</strong>, as transposições e artefatos físicos como as escítalas espartanas eram comuns. Elas já aplicavam ideias de confusão e difusão, mesmo sem formalização matemática.</p>
<p>Durante a Segunda Guerra Mundial, a criptografia ganhou escala e importância estratégica. Máquinas como a <strong>Enigma</strong>, da Alemanha, e a <strong>Purple</strong>, do Japão, exigiram o uso de técnicas de criptoanálise sistemática — o que levou à criação dos primeiros computadores.</p>
<p>No pós-guerra, os EUA padronizaram internamente o uso de sistemas como a <strong>SIGABA</strong>, enquanto a União Soviética adotava sistemas como a <strong>FIALKA</strong>. A complexidade dessas máquinas mecânicas logo se mostrou insuficiente para o novo ritmo das comunicações digitais, e foi necessário o desenvolvimento de algoritmos eletrônicos.</p>
<p>Na década de 1970, a IBM desenvolveu o <strong>Lucifer</strong>, que, com a colaboração da NSA, se transformaria no <strong>DES</strong> — o primeiro algoritmo de cifra simétrica padronizado para uso civil.</p>
<p>Concursos como o do <strong>AES</strong>, e mais tarde o <strong>eSTREAM</strong>, marcaram a transição para uma era de padronizações abertas, revisão por pares e competição internacional entre algoritmos candidatos. Esses processos mostraram que segurança não é apenas uma questão técnica, mas também política e institucional.</p>
<hr />
<h2 id="códigos-militares-espionagem-e-cifras-quebradas"><a class="header" href="#códigos-militares-espionagem-e-cifras-quebradas">Códigos militares, espionagem e cifras quebradas</a></h2>
<p>Boa parte da evolução da criptografia vem das quebras — das falhas que revelaram as limitações de métodos anteriores.</p>
<p>A <strong>máquina Enigma</strong>, por exemplo, foi considerada segura por oficiais alemães, mas foi derrotada por falhas operacionais, reutilização de padrões e interceptação massiva. O trabalho de Alan Turing, Gordon Welchman e equipes em <strong>Bletchley Park</strong> foi crucial para quebrá-la. A cifra <strong>Purple</strong>, do Japão, foi reconstruída por criptoanalistas americanos com base em análise estatística e engenharia reversa.</p>
<p>Décadas depois, já no contexto digital, algoritmos amplamente utilizados também foram alvo de ataques eficazes. Um dos exemplos mais importantes é o <strong>RC4</strong>, uma cifra de fluxo criada por Ron Rivest em 1987. Apesar de sua simplicidade e velocidade, ela apresentava uma fraqueza crítica: os primeiros bytes gerados pelo seu PRGA (Pseudo-Random Generation Algorithm) tinham viés estatístico. Esse viés pôde ser explorado em ataques práticos, especialmente em protocolos como WEP e TLS, que usavam RC4 sem descartar os bytes iniciais. Em 2013, ataques de recuperação de texto claro em tempo real contra RC4 no TLS levaram à sua obsolescência definitiva.</p>
<p>No caso do <strong>MD5</strong>, uma função de hash originalmente considerada resistente a colisões, os primeiros ataques teóricos datam do final da década de 1990. Em 2004, Xiaoyun Wang e sua equipe demonstraram um ataque prático de colisão, com custo computacional muito abaixo do esperado por força bruta. Com o tempo, ataques mais sofisticados, como a criação de certificados SSL fraudulentos com colisões prefixadas, mostraram que o MD5 não podia mais ser usado em contextos de segurança. Hoje, ele é considerado inseguro para qualquer aplicação que dependa de unicidade ou integridade.</p>
<p>O avanço dos ataques levou ao desenvolvimento de novas abordagens para cifras de fluxo e PRNGs (geradores pseudoaleatórios criptograficamente seguros). O <strong>projeto eSTREAM</strong>, parte do consórcio europeu ECRYPT, buscou identificar cifras de fluxo seguras para aplicações leves e de alto desempenho. Dali surgiram algoritmos como <strong>Salsa20</strong>, <strong>Grain</strong>, <strong>HC-128</strong> e <strong>Rabbit</strong>, que oferecem segurança com desempenho competitivo, mesmo em dispositivos embarcados.</p>
<p>Esses episódios mostram que a criptografia é um campo em constante movimento: algoritmos são propostos, testados, criticados, melhorados — ou aposentados. E cada quebra bem-sucedida representa, ao mesmo tempo, uma vulnerabilidade corrigida e um avanço para o campo.</p>
<p>Boa parte da evolução da criptografia vem das quebras — das falhas que revelaram as limitações de métodos anteriores.</p>
<hr />
<h2 id="o-nascimento-do-des-e-a-influência-da-ibm"><a class="header" href="#o-nascimento-do-des-e-a-influência-da-ibm">O nascimento do DES e a influência da IBM</a></h2>
<p>O algoritmo <strong>DES (Data Encryption Standard)</strong> nasceu a partir do projeto <strong>Lucifer</strong>, desenvolvido por <strong>Horst Feistel</strong> na IBM. O Lucifer introduziu a <strong>rede de Feistel</strong>, estrutura que permite que o mesmo algoritmo seja usado para cifrar e decifrar apenas invertendo a ordem das rodadas.</p>
<p>A proposta foi adaptada com a colaboração da <strong>NSA</strong>, que sugeriu alterações nas S-boxes e uma redução no tamanho da chave. Em 1977, o <strong>NIST</strong> oficializou o DES como padrão federal dos EUA. Foi a primeira cifra amplamente usada fora de ambientes militares.</p>
<p>Apesar de sua importância histórica, o DES logo mostrou fragilidades: o tamanho da chave (56 bits) tornou-se pequeno diante da capacidade computacional crescente. Em 1998, a <strong>EFF</strong> demonstrou um ataque de força bruta que quebrou o DES em poucos dias usando hardware dedicado.</p>
<p>A resposta temporária foi o <strong>3DES</strong>, que aplicava o DES três vezes com chaves diferentes, aumentando a segurança mas também o custo computacional.</p>
<hr />
<h2 id="nist-nsa-e-as-controvérsias-na-padronização"><a class="header" href="#nist-nsa-e-as-controvérsias-na-padronização">NIST, NSA e as controvérsias na padronização</a></h2>
<p>A padronização do DES expôs tensões entre agências governamentais, instituições civis e a comunidade científica.</p>
<p>A <strong>NSA</strong> teve participação ativa no processo, influenciando detalhes técnicos do algoritmo — o que gerou suspeitas. O design das <strong>S-boxes</strong>, inicialmente mantido em sigilo, foi posteriormente revelado como otimizado contra criptoanálise diferencial — uma técnica ainda não publicada à época, mas conhecida pela NSA.</p>
<p>Essa falta de transparência gerou críticas, especialmente entre acadêmicos e defensores da criptografia civil. Como resposta, o NIST passou a adotar processos mais abertos em concursos posteriores, como o do <strong>AES</strong> e do <strong>SHA-3</strong>, com submissões públicas e avaliações internacionais.</p>
<p>A relação entre agências como a NSA e padrões civis permanece delicada, e episódios como o vazamento do algoritmo de geração de números pseudoaleatórios <strong>Dual_EC_DRBG</strong>, suspeito de conter backdoors, reforçaram a necessidade de auditoria pública e desconfiança saudável.</p>
<hr />
<h2 id="personagens-e-contribuições"><a class="header" href="#personagens-e-contribuições">Personagens e contribuições</a></h2>
<p>A criptografia moderna foi moldada por contribuições de matemáticos, engenheiros e cientistas da computação. A seguir, alguns nomes centrais:</p>
<blockquote>
<p><strong>Claude Shannon (1916–2001)</strong><br />
Nasceu em Michigan, EUA. Doutorou-se no MIT, onde também trabalhou como pesquisador.<br />
É considerado o "pai da teoria da informação". Publicou "Communication Theory of Secrecy Systems" [1], onde formalizou a segurança perfeita e os conceitos de confusão e difusão. Seu trabalho definiu a base teórica da criptografia moderna.</p>
</blockquote>
<blockquote>
<p><strong>Horst Feistel (1915–1990)</strong><br />
Alemão naturalizado americano, trabalhou na IBM. Desenvolveu o algoritmo Lucifer, baseado na estrutura de rede que leva seu nome: a <strong>rede de Feistel</strong>. Essa estrutura foi usada no DES e inspirou algoritmos como Blowfish, CAST e AES.</p>
</blockquote>
<blockquote>
<p><strong>Whitfield Diffie (n. 1944) &amp; Martin Hellman (n. 1945)</strong><br />
Norte-americanos, ambos com formação em engenharia elétrica e ciência da computação. Trabalharam juntos na Stanford University.<br />
Em 1976, publicaram "New Directions in Cryptography" [2], introduzindo o conceito de criptografia assimétrica e troca de chaves pública, revolucionando o campo.</p>
</blockquote>
<blockquote>
<p><strong>Ron Rivest (n. 1947)</strong><br />
Professor do MIT. Coautor do algoritmo RSA, ao lado de Adleman e Shamir. Criador das cifras RC (Rivest Cipher), como RC4, RC5 e RC6. Contribuiu para o desenvolvimento de funções de hash e protocolos de autenticação.</p>
</blockquote>
<blockquote>
<p><strong>Joan Daemen (n. 1965) &amp; Vincent Rijmen (n. 1970)</strong><br />
Belgas, ambos formados na KU Leuven. Criaram o algoritmo Rijndael, vencedor do concurso AES. Seu design baseado em substituições e permutações é eficiente em hardware e software.<br />
Publicaram diversos artigos sobre criptografia leve, estruturas SPN e segurança de blocos simétricos [3].</p>
</blockquote>
<blockquote>
<p><strong>Eli Biham (n. 1960)</strong><br />
Israelense, professor no Technion (Israel Institute of Technology). Coautor da criptoanálise diferencial com Adi Shamir — técnica que influenciou o design de S-boxes no DES e no AES.<br />
Autor de livros e artigos sobre segurança simétrica, criptoanálise linear e criptografia leve.</p>
</blockquote>
<blockquote>
<p><strong>Daniel J. Bernstein (n. 1971)</strong><br />
Professor na University of Illinois at Chicago. Ativista da criptografia de código aberto. Criador do ChaCha20, Salsa20 e Poly1305. Também desenvolveu o conjunto de ferramentas NaCl (Networking and Cryptography library).<br />
Publicou trabalhos influentes sobre segurança prática e criptografia pós-quântica [4].</p>
</blockquote>
<blockquote>
<p><strong>Adversários históricos</strong></p>
<ul>
<li><strong>Marian Rejewski</strong>: matemático polonês que, com Zygalski e Rozycki, quebrou a Enigma antes da Segunda Guerra.</li>
<li><strong>Alan Turing</strong>: matemático britânico, atuou em Bletchley Park e contribuiu para a quebra automatizada da Enigma.</li>
<li><strong>Bletchley Park Team</strong>: equipe interdisciplinar de criptoanalistas, engenheiros e operadores.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>NSA</strong>: embora não creditada publicamente, contribuiu para a resistência do DES à criptoanálise diferencial, antecipando ataques publicados anos depois.</li>
</ul>
</blockquote>
<p>Esses nomes aparecem ligados a algoritmos, conceitos ou estruturas usados até hoje — e ajudam a contextualizar o motivo pelo qual os sistemas atuais têm a forma que têm.</p>
<p>Referências:<br />
[1] C. Shannon, "Communication Theory of Secrecy Systems," Bell System Technical Journal, vol. 28, pp. 656–715, 1949.<br />
[2] W. Diffie and M. E. Hellman, "New Directions in Cryptography," IEEE Transactions on Information Theory, vol. 22, no. 6, pp. 644–654, 1976.<br />
[3] J. Daemen and V. Rijmen, "The Design of Rijndael: AES – The Advanced Encryption Standard," Springer, 2002.<br />
[4] D. J. Bernstein, "The Salsa20 family of stream ciphers," in New Stream Cipher Designs, Springer, 2008, pp. 84–97.</p>
<hr />
<h2 id="linha-do-tempo-da-criptografia-simétrica-moderna"><a class="header" href="#linha-do-tempo-da-criptografia-simétrica-moderna">Linha do tempo da criptografia simétrica moderna</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Ano</th><th>Evento</th></tr></thead><tbody>
<tr><td>~1900 a.C.</td><td>Uso de formas primitivas de substituição em mensagens militares egípcias.</td></tr>
<tr><td>~58 a.C.</td><td>Cifra de César é usada pelo Império Romano.</td></tr>
<tr><td>~850 d.C.</td><td>Al-Kindi descreve a análise de frequência como técnica de criptoanálise.</td></tr>
<tr><td>1917</td><td>A cifra ADFGVX é usada pela Alemanha na Primeira Guerra Mundial.</td></tr>
<tr><td>1920–1945</td><td>Enigma (Alemanha), Purple (Japão), SIGABA (EUA), FIALKA (URSS) são desenvolvidas.</td></tr>
<tr><td>1943–1945</td><td>Quebra da Enigma em Bletchley Park; criação dos primeiros computadores especializados.</td></tr>
<tr><td>1949</td><td>Claude Shannon publica "Communication Theory of Secrecy Systems".</td></tr>
<tr><td>1970</td><td>Lucifer é desenvolvido pela IBM (Horst Feistel).</td></tr>
<tr><td>1977</td><td>DES é padronizado pelo NIST com apoio da NSA.</td></tr>
<tr><td>1987</td><td>Ron Rivest propõe o algoritmo RC4.</td></tr>
<tr><td>1990</td><td>MD5 é publicado como função de hash.</td></tr>
<tr><td>1997</td><td>Início do concurso AES.</td></tr>
<tr><td>2000</td><td>Rijndael é selecionado como AES.</td></tr>
<tr><td>2004</td><td>Ataques práticos contra MD5 são divulgados.</td></tr>
<tr><td>2008</td><td>eSTREAM publica finalistas para cifras de fluxo.</td></tr>
<tr><td>2013</td><td>RC4 é considerado quebrado para uso em TLS.</td></tr>
<tr><td>2015</td><td>ChaCha20-Poly1305 é adotado no TLS como alternativa segura ao RC4.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="criptografia-simétrica-no-mundo-real-hoje"><a class="header" href="#criptografia-simétrica-no-mundo-real-hoje">Criptografia simétrica no mundo real hoje</a></h2>
<p>Hoje, a criptografia simétrica está no coração de praticamente toda comunicação segura.</p>
<ul>
<li><strong>TLS/HTTPS</strong>: protege a comunicação web. Após a troca de chaves, os dados trafegam com AES ou ChaCha20.</li>
<li><strong>SSH</strong>: conexão segura com servidores.</li>
<li><strong>VPNs (IPsec, WireGuard)</strong>: usam criptografia simétrica para encapsular e proteger pacotes.</li>
<li><strong>Sistemas de arquivos (LUKS, BitLocker)</strong>: usam AES para proteger dados em disco.</li>
<li><strong>Aplicativos de mensagem (Signal, WhatsApp)</strong>: usam criptografia ponta a ponta baseada em chaves simétricas derivadas.</li>
</ul>
<p>Além disso, algoritmos simétricos estão presentes em sistemas embarcados, criptomoedas, roteadores, bancos e firmware. A combinação entre eficiência, simplicidade e maturidade torna a criptografia simétrica uma escolha sólida para o sigilo de dados — desde que bem implementada e atualizada conforme novas vulnerabilidades forem descobertas.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="fluxo-ou-bloco-modos-distintos-de-cifrar"><a class="header" href="#fluxo-ou-bloco-modos-distintos-de-cifrar">Fluxo ou bloco: modos distintos de cifrar</a></h1>
<p>Cifras simétricas podem ser divididas em dois tipos principais: cifras de fluxo e cifras de bloco.</p>
<ul>
<li><strong>Cifras de fluxo</strong> operam sobre dados bit a bit ou byte a byte, idealmente sincronizadas com um gerador pseudoaleatório.</li>
<li><strong>Cifras de bloco</strong> processam dados em blocos fixos (geralmente 64 ou 128 bits), aplicando transformações estruturadas.</li>
</ul>
<p>A distinção entre essas abordagens impacta o desempenho, a segurança e o tipo de uso adequado para cada uma.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cifras-de-fluxo"><a class="header" href="#cifras-de-fluxo">Cifras de Fluxo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="conceito-e-aplicações"><a class="header" href="#conceito-e-aplicações">Conceito e aplicações</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="geradores-de-fluxo-pseudoaleatório"><a class="header" href="#geradores-de-fluxo-pseudoaleatório">Geradores de fluxo pseudoaleatório</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="xor-como-primitiva-central"><a class="header" href="#xor-como-primitiva-central">XOR como primitiva central</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rc4-funcionamento-popularidade-e-quedas"><a class="header" href="#rc4-funcionamento-popularidade-e-quedas">RC4: funcionamento, popularidade e quedas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cifras-modernas-chacha-e-salsa"><a class="header" href="#cifras-modernas-chacha-e-salsa">Cifras modernas: ChaCha e Salsa</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rc4-em-go"><a class="header" href="#rc4-em-go">RC4 em Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="segurança-em-cifras-de-fluxo"><a class="header" href="#segurança-em-cifras-de-fluxo">Segurança em cifras de fluxo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cifras-de-bloco"><a class="header" href="#cifras-de-bloco">Cifras de Bloco</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="o-que-é-uma-cifra-de-bloco"><a class="header" href="#o-que-é-uma-cifra-de-bloco">O que é uma cifra de bloco</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="a-estrutura-de-feistel"><a class="header" href="#a-estrutura-de-feistel">A estrutura de Feistel</a></h1>
<p>Vimos que cifras de bloco transformam blocos de dados de tamanho fixo (e.g. 64 bits) em blocos cifrados de mesmo tamanho. A <code>estrutura de Feistel</code> é um padrão de construção de cifras de bloco que permite aplicar <code>confusão</code> e <code>difusão</code>.</p>
<p>A estrutura de Feistel (chamada também de <code>Feistel Network</code>), proposta por Horst Feistel em 1970, é uma abordagem muito utilizada para construir cifras de bloco a partir de funções não necessariamente invertíveis. A ideia central dessa estrutura é dividir o bloco de entrada em duas partes iguais, aplicar uma função não invertível a uma das partes e combinar o resultado com a outra parte usando uma operação <code>XOR</code>.</p>
<h2 id="estrutura-geral-1"><a class="header" href="#estrutura-geral-1">Estrutura Geral</a></h2>
<p>Dado um bloco de entrada de tamanho <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span>, ele é dividido em duas partes iguais, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">parte esquerda do bloco</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">parte direita do bloco</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Cada rodada <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> aplica a seguinte transformação:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Aqui, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> é uma função que pode ser não invertível, e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> é a subchave da rodada <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>.</p>
<p>Ao final das rodadas, o par <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> é combinado e (em alguns casos) passado por uma permutação final.</p>
<p>Uma característica importante da estrutura de Feistel é que a decifração é realizada aplicando as mesmas operações em ordem inversa, com as subchaves utilizadas na ordem inversa.</p>
<h3 id="exemplo-simplificado-rede-de-feistel-de-2-rodadas"><a class="header" href="#exemplo-simplificado-rede-de-feistel-de-2-rodadas">Exemplo simplificado (Rede de Feistel de 2 rodadas)</a></h3>
<p>Para ilustrar, considere uma rede de Feistel com 2 rodadas e blocos de 8 bits, divididos em duas metades de 4 bits.</p>
<pre><code class="language-go">package main

import (
	"fmt"
)

func F(R, K byte) byte {
	return (R + K) % 16
}

func FeistelEncrypt(P byte, K []byte) byte {
	L := (P &gt;&gt; 4) &amp; 0xF 
	R := P &amp; 0xF

	for i := 0; i &lt; len(K); i++ {
		newL := R
		R = L ^ F(R, K[i])
		L = newL
	}

	return (L &lt;&lt; 4) | R
}

func FeistelDecrypt(C byte, K []byte) byte {
	L := (C &gt;&gt; 4) &amp; 0xF
	R := C &amp; 0xF
	
	for i := len(K) - 1; i &gt;= 0; i-- {
		newR := L
		L = R ^ F(L, K[i])
		R = newR
	}
	return (L &lt;&lt; 4) | R
}

func main() {
	P := byte('A')        // plaintext: bloco de 8 bits, caractere 'A' = 0x41 = 01000001
	K := []byte{7, 3}     // chaves: 2 chaves de 4 bits para 2 rodadas

	C := FeistelEncrypt(P, K)
	D := FeistelDecrypt(C, K)
	
	fmt.Println()
	fmt.Println("=== Demonstração da Cifra de Feistel (2 rodadas, 8 bits) ===")
	fmt.Println()
	fmt.Printf("%-12s %-10s %-10s %-10s %-10s\n", "Tipo", "Char", "Bin", "Hex", "Decimal")
	fmt.Println("------------------------------------------------------------")
	fmt.Printf("%-12s %-10q %08b   0x%02X       %-10d\n", "Plaintext", P, P, P, P)
	fmt.Printf("%-12s %-10q %08b   0x%02X       %-10d\n", "Ciphertext", C, C, C, C)
	fmt.Printf("%-12s %-10q %08b   0x%02X       %-10d\n", "Decrypted", D, D, D, D)
	fmt.Println()
}
</code></pre>
<p>Esse exemplo usa operações simples para fins didáticos. A ideia é mostrar como, mesmo com funções unilaterais simples, a estrutura de Feistel permite a construção de cifras reversíveis.</p>
<h2 id="algoritmos-que-usam-a-estrutura-de-feistel"><a class="header" href="#algoritmos-que-usam-a-estrutura-de-feistel">Algoritmos que usam a estrutura de Feistel</a></h2>
<p>Esses algoritmos seguem a estrutura clássica ou variantes da rede de Feistel:</p>
<p>Clássicos / Históricos
Lucifer (IBM, 1973): primeiro a usar Feistel explicitamente.</p>
<p>DES (1977): 16 rodadas de Feistel com S-boxes e permutações fixas.</p>
<p>3DES (Triple-DES): composição de DES, também baseado em Feistel.</p>
<p>Modernos (até anos 2000)
Blowfish (Schneier, 1993): Feistel de 16 rodadas com chave variável.</p>
<p>Twofish (Schneier et al., 1998): usa uma estrutura pseudo-Feistel.</p>
<p>CAST-128/CAST-256: cifras de Feistel com funções não lineares.</p>
<p>Camellia (NTT, Mitsubishi, 2000): estrutura Feistel com S-boxes inspiradas no AES.</p>
<p>MARS (IBM, candidato AES): usa um núcleo do tipo Feistel.</p>
<p>GOST 28147-89 (União Soviética): 32 rodadas de Feistel com S-boxes configuráveis.</p>
<p>RC5 / RC6: estrutura Feistel modificada (dependendo da parametrização).</p>
<p>Outros exemplos notáveis
ICE (Information Concealment Engine)</p>
<p>FEAL (Fast Data Encipherment Algorithm)</p>
<p>HIGHT (cifra leve baseada em Feistel, usada em IoT)</p>
<p>LEA (cifra leve coreana, com estrutura semelhante a Feistel)</p>
<h2 id="algoritmos-que-não-usam-rede-de-feistel"><a class="header" href="#algoritmos-que-não-usam-rede-de-feistel">Algoritmos que não usam rede de Feistel</a></h2>
<p>Esses usam redes de substituição-permutação (SPN) ou outras estruturas:</p>
<p>AES e derivados
AES (Rijndael): usa uma rede SPN (Substituição–Permutação Network), não é Feistel.</p>
<p>PRESENT: cifra leve SPN, amplamente usada em hardware.</p>
<p>LED (Lightweight Encryption Device): também SPN.</p>
<p>Modernos e pós-quantum
SIMON / SPECK (NSA): SIMON usa estrutura bitwise alternada, não exatamente Feistel.</p>
<p>ASCON (padrão NIST para cifragem autenticada): SPN com permutação.</p>
<p>NOEKEON: cifra leve, rede SPN.</p>
<p>PRINCE: estrutura reflexiva, não Feistel.</p>
<p>Outros exemplos
Khazad / Anubis: SPN, baseados em ideias do AES.</p>
<p>Grain / Trivium: cifras de fluxo (não são cifras de bloco, mas também não usam Feistel).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="des-arquitetura-s-boxes-e-permutações"><a class="header" href="#des-arquitetura-s-boxes-e-permutações">DES: arquitetura, S-boxes e permutações</a></h1>
<h1 id="data-encryption-standard-des"><a class="header" href="#data-encryption-standard-des">Data Encryption Standard (DES)</a></h1>
<p>O DES foi concebido no início dos anos 70 e pode ser considerado o primeiro algorítmo de cifra moderno. Ele foi o mais popular algoritmo de cifra simétrica nos anos 80 e 90. Embora o DES seja considerado inseguro em sua forma original, por causa de sua chave pequena, algumas de suas variantes, como o Triple DES (3DES), é ainda usado em muitos sistemas nos dias atuais. Triple DES é uma extensão do DES que usa o DES três vezes em sequência. O design do DES inspirou muitas cifras atuais tornando seu estudo importante para o entendimento de cifras modernas.</p>
<p>Neste capítulo você aprenderá:</p>
<ul>
<li>O processo de desenvolvimento do DES, útil para entender a evolução técnica e pollítica da criptografia moderna.</li>
<li>As idéias de projeto das cifras de bloco, incluindo confusão e difusão, que são propriedades importantes de todas as cifras de bloco modernas.</li>
<li>A estrutura interna do DES, incluindo a estrutura de Feistel, S-boxes, permutações e o agendamento de chaves (key scheduling).</li>
<li>Análise de segurança do DES, incluindo ataques de criptoanálise.</li>
<li>Alternativas ao DES, incluindo 3DES e a cifra de bloco leve PRESENT.</li>
</ul>
<p>Em 1972, um ato levemente revolucionário foi realizado pelo National Bureau of Standards (NBS) dos Estados Unidos, atualmente chamado de National Institute of Standards and Technology (NIST): o NBS iniciou um processo de chamada pública de propostas para selecionar uma cifra padronizada nos EUA. A ideia era encontrar um único algoritmo criptográfico seguro que pudesse ser utilizado em diversas aplicações. Até então, os governos consideravam a criptografia — e especialmente a criptoanálise — algo tão crucial para a segurança nacional que deveria ser mantido em segredo. No entanto, no início da década de 1970, a demanda por criptografia em aplicações comerciais, como o setor bancário, tornou-se tão urgente que não poderia mais ser ignorada sem consequências econômicas.</p>
<p>O NBS recebeu o candidato mais promissor em 1974, vindo de uma equipe de criptógrafos da IBM. O algoritmo submetido era baseado na cifra Lucifer. Lucifer era uma família de cifras desenvolvida por Horst Feistel no final da década de 1960, sendo uma das primeiras cifras de bloco projetadas para operar sobre dados digitais. Lucifer é uma cifra de Feistel que cifra blocos de 64 bits utilizando uma chave de 128 bits.</p>
<p>Para avaliar a segurança dos algoritmos recebidos, o NBS solicitou ajuda da NSA (National Security Agency), que na época nem sequer admitia sua existência oficialmente. É praticamente certo que a NSA influenciou mudanças na cifra, que foi rebatizada como DES. Uma das alterações foi que o DES foi especificamente projetado para resistir à criptoanálise diferencial, um tipo de ataque que só se tornou conhecido publicamente em 1990. Não está claro se a equipe da IBM desenvolveu esse conhecimento de forma independente ou se foi orientada pela NSA. Supostamente, a NSA também teria convencido a IBM a reduzir o tamanho da chave de Lucifer de 128 bits para 56 bits — o que deixou o algoritmo muito mais vulnerável a ataques de força bruta.</p>
<p>A participação da NSA gerou preocupações, pois havia o receio de que uma backdoor secreta — ou seja, uma propriedade matemática que permitiria quebrar o DES e que só seria conhecida pela NSA — fosse a verdadeira razão por trás das modificações. Outra crítica importante foi a redução do tamanho da chave. Algumas pessoas conjecturaram que a NSA teria capacidade computacional para explorar o espaço de chaves de 2⁵⁶ combinações e assim quebrar o algoritmo por força bruta. Nas décadas seguintes, a maioria dessas preocupações mostrou-se infundada.</p>
<p>Apesar das críticas e controvérsias, em 1977 o NBS publicou todas as especificações da cifra modificada da IBM como o Data Encryption Standard (FIPS PUB 46). Embora a cifra seja descrita no padrão com precisão até o nível de bits, a motivação para diversas decisões de projeto (os chamados critérios de projeto), especialmente a escolha das caixas de substituição (S-boxes), nunca foi oficialmente divulgada.</p>
<p>Com o crescimento rápido dos computadores pessoais no início da década de 1980 — e com todas as especificações do DES sendo públicas — tornou-se mais fácil analisar sua estrutura interna. Nesse período, a comunidade acadêmica de pesquisa em criptografia também cresceu, e o DES passou a ser alvo de intensa análise. No entanto, até 1990, nenhuma vulnerabilidade grave foi encontrada. Inicialmente, o DES foi padronizado por 10 anos, até 1987. Devido ao uso generalizado e à ausência de falhas críticas, o NIST reafirmou seu uso federal até 1999, quando foi finalmente substituído pelo Advanced Encryption Standard (AES).</p>
<h2 id="311-confusion-and-diffusion"><a class="header" href="#311-confusion-and-diffusion">3.1.1 Confusion and Diffusion</a></h2>
<p>Antes de analisarmos os detalhes do DES, é útil entender as operações básicas que podem ser aplicadas para alcançar uma criptografia forte. Segundo o famoso teórico da informação Claude Shannon, existem duas operações primitivas com as quais se pode construir algoritmos criptográficos robustos [232]:</p>
<p>Confusão é uma operação criptográfica em que a relação entre a chave e o texto cifrado é obscurecida. Atualmente, um elemento comum para alcançar confusão é a substituição, presente tanto no DES quanto no AES.</p>
<p>Difusão é uma operação criptográfica em que a influência de um símbolo do texto original é espalhada por muitos símbolos do texto cifrado, com o objetivo de ocultar propriedades estatísticas do texto original. Um exemplo simples de elemento de difusão é a permutação de bits, usada com frequência no DES. O AES utiliza a operação mais avançada chamada MixColumn.</p>
<p>Cifras que aplicam apenas confusão — como a cifra de César ou a máquina Enigma usada na Segunda Guerra Mundial — não são seguras. O mesmo vale para cifras que aplicam apenas difusão. No entanto, ao combinar essas operações em sequência, é possível construir cifras robustas. A ideia de concatenar várias operações criptográficas também foi proposta por Shannon. Tais cifras são conhecidas como cifras de produto (product ciphers). Todas as cifras de bloco modernas pertencem a essa categoria, pois consistem em rodadas repetidas aplicadas aos dados (ver Figura 3.1).
As cifras de bloco modernas possuem excelentes propriedades de difusão. Isso significa que, ao nível do algoritmo, uma alteração de um único bit no texto original (plaintext) tende a modificar, em média, metade dos bits de saída — fazendo com que o texto cifrado resultante pareça estatisticamente independente do original. Essa é uma propriedade fundamental a se ter em mente ao lidar com cifras de bloco. Podemos demonstrar esse comportamento com o exemplo a seguir:</p>
<p>Exemplo 3.1
Considere uma cifra de bloco simplificada com comprimento de bloco de 8 bits. A criptografia de dois textos originais x₁ e x₂, que diferem em apenas um bit, deve resultar aproximadamente na situação mostrada na Figura 3.2.</p>
<p>Observe que cifras de bloco modernas operam com blocos de 64 ou 128 bits, mas exibem exatamente o mesmo comportamento se um único bit de entrada for alterado.</p>
<p>3.2 Visão geral do algoritmo DES
O DES é uma cifra que criptografa blocos de 64 bits utilizando uma chave de 56 bits (ver Figura 3.3).</p>
<p>O DES é uma cifra simétrica, ou seja, a mesma chave é usada tanto para cifrar quanto para decifrar. Assim como praticamente todas as cifras de bloco modernas, o DES é um algoritmo baseado em rodadas. Para cada bloco de texto original, o processo de criptografia envolve 16 rodadas, todas com a mesma estrutura. A Figura 3.4 mostra essa estrutura. Em cada rodada é usada uma subchave diferente kᵢ, derivada da chave principal k.</p>
<p>Vamos agora examinar com mais detalhes a estrutura interna do DES, conforme ilustrado na Figura 3.5. A estrutura apresentada é chamada de rede de Feistel (Feistel network), que pode formar cifras muito fortes se bem projetada. Redes de Feistel são utilizadas em outras cifras modernas (embora não em todas; por exemplo, o AES não é uma cifra de Feistel).</p>
<p>💡 Vantagem prática: Um dos benefícios das redes de Feistel é que os processos de cifragem e decifragem são praticamente idênticos. A única diferença é a ordem das subchaves. Isso facilita a implementação em software e hardware.</p>
<p>Após a permutação inicial de bits (IP) sobre o bloco de 64 bits de entrada x, o texto é dividido em duas metades: L₀ e R₀. Essas duas metades de 32 bits são a entrada para a rede de Feistel, que consiste em 16 rodadas. A metade direita Rᵢ é passada como entrada para a função f. O resultado da f é então XOR com a metade esquerda Lᵢ. Por fim, as metades são trocadas. Esse processo se repete nas rodadas seguintes, e pode ser descrito por:</p>
<p>Lᵢ = Rᵢ₋₁<br />
Rᵢ = Lᵢ₋₁ ⊕ f(Rᵢ₋₁, kᵢ)</p>
<p>para i = 1, ..., 16.</p>
<p>Após a rodada 16, as metades L₁₆ e R₁₆ são trocadas novamente, e a permutação final (IP⁻¹) é aplicada — sendo o inverso da permutação inicial IP.</p>
<p>Em cada rodada, a subchave kᵢ é gerada a partir da chave principal de 56 bits, por meio de um processo chamado de agendamento de chaves (key schedule).</p>
<p>É importante observar que a estrutura de Feistel criptografa, em cada rodada, apenas metade do bloco de entrada. A metade direita Rᵢ₋₁ passa pela função f, enquanto a metade esquerda é atualizada via XOR com a saída dessa função. A metade direita é apenas copiada para a próxima rodada.</p>
<p>🎯 Interpretação útil: A função f pode ser vista como um gerador pseudoaleatório que recebe como entrada Rᵢ₋₁ e kᵢ. Sua saída serve para “embaralhar” Lᵢ₋₁ via XOR. Se a saída de f for imprevisível, o resultado é uma cifra forte.</p>
<p>Do ponto de vista matemático, a estrutura de Feistel mapeia bijetivamente os 64 bits de entrada para os 64 bits de saída — ou seja, cada entrada tem uma única saída correspondente, e vice-versa. Isso permanece verdadeiro mesmo que a função f interna não seja bijetiva. No caso do DES, a f é uma função não injetora, que mapeia 32 bits de entrada para 32 bits de saída, usando uma subchave de 48 bits.</p>
<blockquote>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:18.1863em;vertical-align:-8.8432em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:9.3432em;"><span style="top:-11.4572em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-9.9331em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-8.409em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-5.909em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-4.409em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-2.909em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-0.409em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:1.091em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:3.705em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:5.2292em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:8.8432em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:9.3432em;"><span style="top:-11.5032em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord textbf">1. Permuta</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord textbf">c</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2556em;"><span class="mord textbf">¸</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1701em;"><span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord textbf">a</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord textbf">˜</span></span></span></span></span></span></span><span class="mord textbf">o Inicial (IP)</span></span></span></span><span style="top:-9.9791em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">onde </span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span><span style="top:-8.455em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span><span style="top:-5.955em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord textbf">2. Rodadas de Feistel (i = 1,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord textbf">,16)</span></span></span></span><span style="top:-4.455em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.955em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-0.455em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord textbf">3. Troca final (Swap)</span></span></span></span><span style="top:1.045em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:3.6591em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord text"><span class="mord textbf">4. Permuta</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord textbf">c</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2556em;"><span class="mord textbf">¸</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1701em;"><span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord textbf">a</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord textbf">˜</span></span></span></span></span></span></span><span class="mord textbf">o Final (IP</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord textbf">)</span></span></span></span><span style="top:5.1832em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">(bloco cifrado)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:8.8432em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p><img src="criptografia-simetrica/cifras-de-bloco/des-image.svg" alt="DES" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="limitações-e-abandono-do-des"><a class="header" href="#limitações-e-abandono-do-des">Limitações e abandono do DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="3des-extensão-temporária"><a class="header" href="#3des-extensão-temporária">3DES: extensão temporária</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="modos-de-operação"><a class="header" href="#modos-de-operação">Modos de operação</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rc5-e-rc6"><a class="header" href="#rc5-e-rc6">RC5 e RC6</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes-concurso-e-escolha"><a class="header" href="#aes-concurso-e-escolha">AES: concurso e escolha</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes-funcionamento-interno"><a class="header" href="#aes-funcionamento-interno">AES: funcionamento interno</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes-em-modos-de-operação"><a class="header" href="#aes-em-modos-de-operação">AES em modos de operação</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes-em-go"><a class="header" href="#aes-em-go">AES em Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="armadilhas-e-boas-práticas"><a class="header" href="#armadilhas-e-boas-práticas">Armadilhas e boas práticas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="algorítmos-de-criptografia"><a class="header" href="#algorítmos-de-criptografia">Algorítmos de Criptografia</a></h1>
<h2 id="criptografia-simétrica-1"><a class="header" href="#criptografia-simétrica-1">Criptografia Simétrica</a></h2>
<p>Neste capítulo, veremos como criptografar e descriptografar dados usando algoritmos de chave simétrica. Exploraremos os algoritmos DES (Data Encryption Standard) e AES (Advanced Encryption Standard), além de cifras anteriores que influenciaram esses padrões, como a estrutura de Feistel e suas variações. Também analisaremos, na prática, implementações de algoritmos da família RC (Rivest Cipher).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="des---data-encryption-standard"><a class="header" href="#des---data-encryption-standard">DES - Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="3des---triple-des"><a class="header" href="#3des---triple-des">3DES - Triple DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="aes---advanced-encryption-standard"><a class="header" href="#aes---advanced-encryption-standard">AES - Advanced Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="rsa---rivest-shamir-e-adleman"><a class="header" href="#rsa---rivest-shamir-e-adleman">RSA - Rivest, Shamir e Adleman</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="ecdsa---elliptic-curve-digital-signature-algorithm"><a class="header" href="#ecdsa---elliptic-curve-digital-signature-algorithm">ECDSA - Elliptic Curve Digital Signature Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hmac---assinaturas-seguras"><a class="header" href="#hmac---assinaturas-seguras">HMAC - Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="criptografia-simétrica-vs-assimétrica"><a class="header" href="#criptografia-simétrica-vs-assimétrica">Criptografia Simétrica vs Assimétrica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miscelânea"><a class="header" href="#miscelânea">Miscelânea</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="confusão-e-difusão-1"><a class="header" href="#confusão-e-difusão-1">Confusão e Difusão</a></h1>
<p>As propriedades de <strong>confusão</strong> e <strong>difusão</strong> são dois princípios fundamentais estabelecidos por Shannon [1], constituindo pilares da segurança em sistemas criptográficos modernos. Esses conceitos têm como objetivo maximizar a incerteza e a dispersão das relações estatísticas entre a mensagem não cifrada e a mensagem cifrada, dificultando ataques baseados em análise de frequência ou estrutura.</p>
<h2 id="definições-formais-1"><a class="header" href="#definições-formais-1">Definições formais</a></h2>
<p><strong>Confusão</strong>: o objetivo é tornar complexa a relação entre a chave de encriptação e o texto cifrado. De acordo com Shannon, "o sistema deve ser projetado de modo que cada bit da chave afete, de forma imprevisível, muitos bits da saída". Confusão impede que um atacante deduza partes da chave mesmo conhecendo partes do texto cifrado.</p>
<p><strong>Difusão</strong>: refere-se à dispersão estatística do conteúdo da mensagem não cifrada ao longo da mensagem cifrada. Ou seja, um pequeno número de bits alterados na entrada deve afetar um grande número de bits na saída. A difusão elimina padrões e distribui redundâncias da mensagem original.</p>
<p>Esse comportamento, em que pequenas alterações na entrada produzem grandes alterações na saída, é conhecido como <strong>efeito avalanche</strong>, e é resultado da aplicação combinada de confusão e difusão.</p>
<p>Essas duas propriedades são frequentemente implementadas em cifras modernas por meio de redes de substituição e permutação redes de substituição e permutação (Substitution-Permutation Networks), conforme discutido por Donald Knuth em <em>The Art of Computer Programming</em> [5], onde destaca a importância da aleatoriedade controlada na construção de algoritmos seguros.</p>
<h2 id="exemplo-prático-simulações-de-confusão-e-difusão-em-go-1"><a class="header" href="#exemplo-prático-simulações-de-confusão-e-difusão-em-go-1">Exemplo Prático: Simulações de Confusão e Difusão em Go</a></h2>
<p>Para isolar os conceitos, não implementamos uma cifra completa, mas sim funções que exemplificam mecanicamente confusão (via substituições não lineares com chave) e difusão (via permutações e operações de dispersão simples).</p>
<p>A estrutura será:</p>
<ul>
<li>
<p>Confusão: uso de uma substituição baseada em chave (S-Box parametrizada).</p>
</li>
<li>
<p>Difusão: uso de permutação fixa e dispersão via operações XOR.</p>
</li>
</ul>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"fmt"
)

// Gera uma S-Box pseudoaleatória baseada em uma chave
func generateSBox(key []byte) [256]byte {
	var sbox [256]byte
	hash := sha256.Sum256(key)
	seed := uint32(0)
	for i := 0; i &lt; 4; i++ {
		seed ^= uint32(hash[i]) &lt;&lt; (8 * i)
	}
	for i := range sbox {
		sbox[i] = byte((i*int(seed) + 31) % 256)
	}
	return sbox
}

// Confusão: aplica substituição não linear via S-Box
func confusion(input []byte, sbox [256]byte) []byte {
	out := make([]byte, len(input))
	for i, b := range input {
		out[i] = sbox[b]
	}
	return out
}

// Difusão: permutação e dispersão via XOR entre posições
func diffusion(input []byte) []byte {
	out := make([]byte, len(input))
	for i := range input {
		out[i] = input[i]
		if i &gt; 0 {
			out[i] ^= input[i-1]
		}
	}
	return out
}

func main() {
	key := []byte("chave-secreta")
	entrada := []byte("mensagem123456")

	sbox := generateSBox(key)
	c := confusion(entrada, sbox)
	d := diffusion(c)

	fmt.Printf("Original : %x\n", entrada)
	fmt.Printf("Confusão : %x\n", c)
	fmt.Printf("Difusão  : %x\n", d)
}

</code></pre>
<p>Análise do código:</p>
<p>Observe que:</p>
<ul>
<li>
<p>A função generateSBox cria uma tabela de substituição (S-Box) que introduz confusão, pois depende da chave de entrada.</p>
</li>
<li>
<p>A função diffusion implementa uma difusão simples, propagando a influência de cada byte anterior sobre o próximo com XOR.</p>
</li>
</ul>
<h2 id="considerações-finais-6"><a class="header" href="#considerações-finais-6">Considerações Finais</a></h2>
<p>A aplicação isolada de confusão e difusão permite o estudo modular de suas propriedades, sem a complexidade adicional de um esquema criptográfico completo. Shannon já antecipava que a combinação adequada dessas técnicas seria suficiente para criar sistemas resistentes à análise estatística.</p>
<p>Knuth, por sua vez, destacou que a boa aleatorização estruturada é o centro da segurança criptográfica — e que difusão e confusão são ferramentas matemáticas precisamente voltadas a esse objetivo.</p>
<p>O leitor é convidado a explorar esses conceitos com maior profundidade consultando a referência [1] e [5].</p>
<h2 id="referências-6"><a class="header" href="#referências-6">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-boxes-substituições-não-lineares-1"><a class="header" href="#s-boxes-substituições-não-lineares-1">S-Boxes: Substituições Não Lineares</a></h1>
<p>As S-Boxes (Substitution Boxes) são funções fundamentais em cifras simétricas modernas. Elas realizam substituições não lineares, introduzindo confusão no sistema criptográfico, conforme definido por Shannon [1]. Em redes de substituição-permutação (SPN) e cifras de Feistel, as S-Boxes são os principais elementos responsáveis por tornar complexa a relação entre a chave e o texto cifrado.</p>
<h2 id="definição-formal-1"><a class="header" href="#definição-formal-1">Definição Formal</a></h2>
<p>Uma S-Box é uma função</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></p>
<p>que mapeia uma entrada binária de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits para uma saída de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> bits. Quando <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, a S-Box é dita bijetiva (ou uma permutação) se cada saída for única.</p>
<p>Exemplo típico:</p>
<ul>
<li>No AES, a S-Box é uma permutação de 8 bits para 8 bits, isto é, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<p>Propriedades desejáveis:</p>
<ul>
<li>
<p>Não-linearidade alta (distância de Hamming em relação a todas funções lineares).</p>
</li>
<li>
<p>Avalanche: uma mudança de 1 bit na entrada afeta múltiplos bits da saída.</p>
</li>
<li>
<p>Resistência a diferenciais e lineares: saída deve ser estatisticamente imprevisível sob diferenças ou aproximações lineares na entrada.</p>
</li>
</ul>
<p>Métodos de construção:</p>
<p>A criação de S-Boxes pode ser feita de diferenes maneiras, dependendo do contexto e objetivos de segurança:</p>
<ol>
<li>Baseadas em estruturas algébricas</li>
</ol>
<ul>
<li>AES (Rijndael) utiliza a inversa multiplicativa no corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8665em;vertical-align:-0.1776em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5224em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1776em;"><span></span></span></span></span></span></span></span></span></span>, seguida de uma transformação afim:
<ul>
<li>Inverso: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> (com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6554em;vertical-align:-0.011em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</li>
<li>Transformação afim: multiplicação e soma sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p>Essa construção é baseada no padrão FIPS 197 [2]. e foi escolhida por sua alta não-linearidade e resistência a ataques diferenciais.</p>
<ol start="2">
<li>Baseadas em constantes (look-up fixo)</li>
</ol>
<ul>
<li>
<p>MD2 define uma S-Box de 256 bytes fixos, supostamente derivada dos dígitos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. A origem exata nunca foi publicada por Rivest, mas acredita-se que a sequência tenha sido escolhida de forma a evitar padrões evidentes [3].</p>
</li>
<li>
<p>DES usa oito S-Boxes diferentes com mapeamentos de 6 bits para 4 bits, cuidadosamente projetadas para resistir a criptoanálise diferencial (ver Coppersmith [4]).</p>
</li>
</ul>
<ol start="3">
<li>Pseudoaleatórias derivadas de chave</li>
</ol>
<ul>
<li>Em cifras modernas como Blowfish, a S-Box é preenchida dinamicamente durante a expansão da chave. Isso dificulta análise e torna a estrutura dependente da chave secreta.</li>
</ul>
<h2 id="exemplo-prático-em-go-construindo-uma-s-box-simples-1"><a class="header" href="#exemplo-prático-em-go-construindo-uma-s-box-simples-1">Exemplo prático em Go: Construindo uma S-Box simples</a></h2>
<p>Aqui, mostramos duas formas distintas de definir S-Boxes em Go:</p>
<ol>
<li>AES-like (algébrica) - inverso multiplicativo seguido de transformação afim (simplificada).</li>
<li>MD2-like (constante fixa) - look-up fixo.</li>
</ol>
<pre><code class="language-go">package main

import (
	"fmt"
	"math/bits"
)

// Exemplo simplificado de S-Box: inverso em GF(2^8) + afim (AES-like simplificada)
func simpleAffineSBox() [256]byte {
	var sbox [256]byte
	for i := 0; i &lt; 256; i++ {
		inv := inverseByte(byte(i))
		sbox[i] = inv ^ bits.RotateLeft8(inv, 1) ^ 0x63 // afim simplificada
	}
	return sbox
}

// Inverso multiplicativo em GF(2^8) com polinômio redutor x^8 + x^4 + x^3 + x + 1
func inverseByte(x byte) byte {
	if x == 0 {
		return 0
	}
	var inv byte = 1
	for i := 1; i &lt; 256; i++ {
		if byteMultiply(x, inv) == 1 {
			return inv
		}
		inv++
	}
	return 0
}

// Multiplicação em GF(2^8)
func byteMultiply(a, b byte) byte {
	var p byte = 0
	for b != 0 {
		if b&amp;1 != 0 {
			p ^= a
		}
		hi := a &amp; 0x80
		a &lt;&lt;= 1
		if hi != 0 {
			a ^= 0x1B // AES irreducible polynomial
		}
		b &gt;&gt;= 1
	}
	return p
}

// Exemplo de S-Box constante (MD2-like)
func md2SBox() [256]byte {
	return [256]byte{
		0x29, 0x2E, 0x43, 0x32, 0x8B, 0x1C, 0x1A, 0x06, 0x3F, 0x3C, 0x7F, 0x8A, 0x0E, 0x19, 0x4F, 0x43,
		// ... complete até 256 valores reais conforme tabela do MD2
	}
}

func main() {
	sbox := simpleAffineSBox()
	fmt.Printf("Exemplo de S-Box (simplificada):\n")
	for i := 0; i &lt; 16; i++ {
		fmt.Printf("%02x ", sbox[i])
	}
	fmt.Println()
}
</code></pre>
<h2 id="considerações-finais-7"><a class="header" href="#considerações-finais-7">Considerações finais</a></h2>
<p>As S-Boxes são blocos fundamentais na construção de cifras seguras. Sua estrutura influencia diretamente a resistência contra ataques diferenciais, lineares e por análise estatística. S-Boxes bem projetadas devem apresentar não-linearidade elevada e boa dispersão da entrada na saída, contribuindo para o efeito avalanche.</p>
<p>Embora possam ser fixas ou derivadas de chave, é essencial que sejam analisadas formalmente quanto às suas propriedades de segurança — algo que o projeto do AES exemplifica de forma rigorosa. Em contrapartida, designs mais antigos, como MD2, revelam escolhas empíricas, ainda que eficazes em seu tempo.</p>
<h2 id="referências-7"><a class="header" href="#referências-7">Referências</a></h2>
<p>[1] C. E. Shannon, Communication Theory of Secrecy Systems, Bell System Technical Journal, 1949.</p>
<p>[2] National Institute of Standards and Technology, FIPS-197: Advanced Encryption Standard (AES), 2001.</p>
<p>[3] R. Rivest, The MD2 Message-Digest Algorithm, RFC 1319, 1992.</p>
<p>[4] D. Coppersmith, The Data Encryption Standard (DES) and Its Strength Against Attacks, IBM Journal of Research and Development, 1994.</p>
<p>[5] D. E. Knuth, The Art of Computer Programming, Vol. 2, Addison-Wesley, 1997.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="permutações-e-trocas-1"><a class="header" href="#permutações-e-trocas-1">Permutações e Trocas</a></h1>
<p>Em cifras simétricas, a dispersão de dependências locais — fundamental para a difusão — pode ser alcançada por meio de operações lineares, como multiplicações matriciais, ou estruturais, como permutações e trocas de posição. Este tipo de transformação reorganiza os dados sem alterar seu conteúdo individual, mas com profundo impacto estatístico na propagação de alterações pela estrutura do algoritmo.</p>
<h2 id="permutações-como-mecanismo-de-difusão-1"><a class="header" href="#permutações-como-mecanismo-de-difusão-1">Permutações como mecanismo de difusão</a></h2>
<p>Uma permutação é uma bijeção sobre o conjunto de posições de bits ou bytes. Aplicada a um vetor de entrada, ela redistribui os elementos segundo uma ordem fixa ou pseudoaleatória. Embora não introduza não-linearidade, a permutação é essencial para ampliar o alcance das alterações provocadas pelas S-Boxes ou outras funções não lineares.</p>
<p>Na arquitetura de cifras modernas, as permutações são utilizadas para:</p>
<ul>
<li>
<p>Propagar a influência de bits da entrada por várias S-Boxes na rodada seguinte.</p>
</li>
<li>
<p>Impedir que padrões locais na entrada gerem padrões locais na saída.</p>
</li>
<li>
<p>Compor difusão com custo computacional baixo.</p>
</li>
</ul>
<h2 id="exemplo-em-spns-1"><a class="header" href="#exemplo-em-spns-1">Exemplo em SPNs</a></h2>
<p>No AES (FIPS-197), duas camadas implementam difusão com base em permutação:</p>
<ul>
<li><strong>ShiftRows</strong>: uma permutação de bytes por rotação de linhas.</li>
<li><strong>MixColumns</strong>: uma multiplicação linear que atua em colunas, mas combinada com ShiftRows produz difusão bidimensional.</li>
</ul>
<p>Essas operações não introduzem confusão, mas são vitais para garantir o efeito avalanche ao longo das rodadas.</p>
<h2 id="exemplo-em-feistel-1"><a class="header" href="#exemplo-em-feistel-1">Exemplo em Feistel</a></h2>
<p>Na estrutura de Feistel, usada no DES e em muitas cifras derivadas, a difusão é construída ao longo das rodadas, intercalando trocas de metades do bloco com aplicações de funções não lineares (geralmente baseadas em S-Boxes).</p>
<p>Permutações também aparecem de forma explícita:</p>
<ul>
<li>
<p>Initial Permutation (IP) e Final Permutation (FP) no DES são mapeamentos fixos de 64 bits, historicamente motivados por eficiência em hardware, mas com efeito colateral de difusão inicial e final.</p>
</li>
<li>
<p>Permutação P após a aplicação das S-Boxes na função F do DES serve para espalhar os resultados locais das substituições.</p>
</li>
</ul>
<h2 id="implementação-ilustrativa-em-go-1"><a class="header" href="#implementação-ilustrativa-em-go-1">Implementação ilustrativa em Go</a></h2>
<p>Abaixo, um exemplo de permutação simples de bytes em um vetor de 16 posições:</p>
<pre><code class="language-go">package main

import "fmt"

// Permutação fixa (exemplo artificial)
var permutation = [16]int{2, 0, 3, 1, 6, 4, 7, 5, 10, 8, 11, 9, 14, 12, 15, 13}

func permute(input []byte, p [16]int) []byte {
	out := make([]byte, len(input))
	for i := range p {
		out[i] = input[p[i]]
	}
	return out
}

func main() {
	entrada := []byte("abcdefghijklmnop")
	saida := permute(entrada, permutation)
	fmt.Printf("Original : %s\n", entrada)
	fmt.Printf("Permutada: %s\n", saida)
}
</code></pre>
<p>Esse tipo de permutação, apesar de simples, é o mecanismo base por trás de transformações como ShiftRows. A escolha da ordem é crítica: ela deve maximizar a dispersão estatística sem introduzir simetrias.</p>
<h2 id="considerações-finais-8"><a class="header" href="#considerações-finais-8">Considerações Finais</a></h2>
<p>Permutações e trocas estruturadas são ferramentas indispensáveis na construção de cifras robustas. Embora não introduzam entropia ou não-linearidade, são essenciais para distribuir os efeitos locais das S-Boxes e garantir que os princípios de difusão definidos por Shannon sejam plenamente realizados.</p>
<p>Além disso, entender como essas operações interagem com as camadas de substituição permite projetar SPNs eficientes e compreender como redes de Feistel obtêm segurança mesmo com funções internas relativamente simples.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="geradores-de-números-pseudoaleatórios-prng"><a class="header" href="#geradores-de-números-pseudoaleatórios-prng">Geradores de Números Pseudoaleatórios (PRNG)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="lfsr--linear-feedback-shift-register"><a class="header" href="#lfsr--linear-feedback-shift-register">LFSR – Linear Feedback Shift Register</a></h1>
<p>O LFSR (Registrador de Deslocamento com Realimentação Linear em português) é uma estrutura fundamental na geração de números pseudoaleatórios (PRNGs) e desempenha papel central em técnicas de criptografia de fluxo. Nesta seção vamos entender como o LFSR funciona e como ele é usado para gerar números aleatórios.</p>
<p>Ao final, implementaremos um LFSR em Go para ilustrar seu funcionamento simulando as funções srand e rand tais como as encontradas na biblioteca padrão de C. O LFSR sozinho não é um algorítmo seguro, mas é uma ferramenta útil para entender como os PRNGs funcionam.</p>
<h2 id="funcionamento-4"><a class="header" href="#funcionamento-4">Funcionamento</a></h2>
<p>Um LFSR é composto por um vetor de bits que representa o estado interno. A cada iteração, os bits do registrador são deslocados à direita, e um novo bit entra pela extremidade esquerda. Esse novo bit, chamado de feedback, é calculado usando XOR com certos bits do estado atual que chamamos de taps.</p>
<p>A escolha dos taps não é arbitrária. Eles devem corresponder a um polinômio primitivo sobre o corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, garantindo que o LFSR atinja seu período máximo, ou seja, percorra todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis (exceto o estado nulo).</p>
<h2 id="taps-e-polinômios"><a class="header" href="#taps-e-polinômios">Taps e Polinômios</a></h2>
<p>Para um LFSR de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits, os taps definem um <strong>polinômio binário</strong> na forma:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7977em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0724em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>Por exemplo, o polinômio:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>representa um LFSR de 4 bits com taps nas posições 4 e 1 (i.e. índices 3 e 0, respectivamente).</p>
<p>Se esse polinômio for <strong>primitivo</strong>, o LFSR terá <strong>período máximo</strong>, ou seja, irá percorrer todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis distintos (exceto o estado 0).</p>
<h2 id="operação-passo-a-passo"><a class="header" href="#operação-passo-a-passo">Operação Passo a Passo</a></h2>
<p>A seguir, demonstramos o funcionamento de um LFSR de 4 bits com estado inicial <code>1001</code> e taps nas posições <code>4</code> e <code>1</code> (índices 3 e 0):</p>
<ul>
<li>
<p>Passo 1</p>
<p>Estado: <code>1001</code>.</p>
<p>Feedback: <code>1 ⊕ 1 = 0</code>.</p>
<p>Novo estado: <code>0100</code>.</p>
</li>
<li>
<p>Passo 2</p>
<p>Estado: <code>0100</code>.</p>
<p>Feedback: <code>0 ⊕ 0 = 0</code>.</p>
<p>Novo estado: <code>0010</code>.</p>
</li>
<li>
<p>Passo 3</p>
<p>Estado: <code>0010</code>.</p>
<p>Feedback: <code>0 ⊕ 0 = 0</code>.</p>
<p>Novo estado: <code>0001</code>.</p>
</li>
<li>
<p>Passo 4</p>
<p>Estado: <code>0001</code>.</p>
<p>Feedback: <code>0 ⊕ 1 = 1</code>.</p>
<p>Novo estado: <code>1000</code>.</p>
</li>
<li>
<p>Passo 5</p>
<p>Estado: <code>1000</code>.</p>
<p>Feedback: <code>1 ⊕ 0 = 1</code>.</p>
<p>Novo estado: <code>1100</code>.</p>
</li>
</ul>
<p>E assim por diante.</p>
<h3 id="tabela-de-transiçãoo-de-estados"><a class="header" href="#tabela-de-transiçãoo-de-estados">Tabela de Transiçãoo de Estados</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Passo</th><th>Estado</th><th>Feedback</th><th>Novo Estado</th></tr></thead><tbody>
<tr><td>1</td><td>1001</td><td>1 ⊕ 1 = 0</td><td>0100</td></tr>
<tr><td>2</td><td>0100</td><td>0 ⊕ 0 = 0</td><td>0010</td></tr>
<tr><td>3</td><td>0010</td><td>0 ⊕ 0 = 0</td><td>0001</td></tr>
<tr><td>4</td><td>0001</td><td>0 ⊕ 1 = 1</td><td>1000</td></tr>
<tr><td>5</td><td>1000</td><td>1 ⊕ 0 = 1</td><td>1100</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
</tbody></table>
</div>
<p>A operação em cada passo pode ser descrita da seguinte forma:</p>
<ol>
<li>
<p>O feedback é calculado aplicando <code>XOR</code> entre os bits nas posições definidas pelos taps. (e.g. <code>1001</code> os taps serão os bits <code>3</code> e <code>0</code>, então <code>1 XOR 1 = 0</code>)</p>
</li>
<li>
<p>O estado é deslocado uma posição à direita. (e.g. o estado <code>1001</code> ao descolar para direita se torna <code>0100</code>)</p>
</li>
<li>
<p>O <code>feedback</code> é inserido como o <strong>novo bit</strong> mais à esquerda. (e.g. o estado <code>0100</code>, já deslocado à direita, vai receber o feedback <code>0</code>)</p>
</li>
</ol>
<p>Esse processo é iterado indefinidamente, e a sequência de estados dependerá da escolha inicial da semente (estado) e dos taps. Quando os taps não forem escolhidos adequadamente, o LFSR pode entrar em ciclos curtos, ou até mesmo repetir rapidamente os estados, falhando em percorrer todos os <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> estados possíveis.</p>
<h2 id="taps-que-geram-períodos-máximos"><a class="header" href="#taps-que-geram-períodos-máximos">Taps que geram períodos máximos</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Tamanho</th><th>Taps</th><th>Polinômio</th><th>Período máximo</th></tr></thead><tbody>
<tr><td>4 bits</td><td>[3, 0]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span></td></tr>
<tr><td>8 bits</td><td>[7, 5]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">255</span></span></span></span></td></tr>
<tr><td>16 bits</td><td>[15, 13]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr>
<tr><td>32 bits</td><td>[31, 21]</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr>
</tbody></table>
</div>
<p>Dessa forma taps mal escolhidos podem resultar em:</p>
<ul>
<li>Períodos muito curtos</li>
<li>Ciclos triviais (repetição precoce)</li>
<li>Saídas estatisticamente fracas</li>
</ul>
<p>Por isso, os taps devem ser derivados de polinômios <strong>primitivos</strong> cuidadosamente estudados. Um polinômio primitivo é um polinômio irredutível sobre o corpo finito <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, o que significa que não pode ser fatorado em polinômios de menor grau sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. [5]</p>
<h2 id="fórmula-geral"><a class="header" href="#fórmula-geral">Fórmula Geral</a></h2>
<br>
<style>
/* Estilo base para caixas */
.box {
  border: 1px solid var(--fg);
  border-left: 6px solid var(--fg);
  padding: 1rem;
  margin: 1.5rem 0;
  background-color: var(--bg);
  box-shadow: 2px 2px 6px var(--shadow);
  border-radius: 6px;
  font-size: 1.5rem;
}

/* Definição (azul adaptado) */
.box.definition {
  border-left-color: var(--primary);
}

.box.definition::before {
  content: "Definição";
  font-weight: bold;
  display: block;
  margin-bottom: 0.5rem;
  color: var(--primary);
  font-size: 1.5rem;
}

  
  </style>
<div class="box definition">
<p>O texto puro, o texto cifrado e o key stream consiste de bits individuais:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p>
<p><strong>Cifragem:</strong>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span></span></p>
<p><strong>Decifragem:</strong>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span></span></p>
</div>
<h2 id="implementações"><a class="header" href="#implementações">Implementações</a></h2>
<h3 id="gerador-de-números-pseudo-aleatórios-srand-e-rand"><a class="header" href="#gerador-de-números-pseudo-aleatórios-srand-e-rand">Gerador de números pseudo-aleatórios (srand e rand)</a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
)

type PRNG struct {
	state uint8
	taps  []int
}

// inicializa com uma semente
func srand(seed uint8) *PRNG {
	return &amp;PRNG{state: seed, taps: []int{7, 5}}
}

// gera um único bit pseudo-aleatório
// é como jogar uma moeda para escolher 0 ou 1, só que deterrminístico
func (p *PRNG) nextBit() uint8 {
	var feedback uint8
	
	for _, tap := range p.taps {
		feedback ^= (p.state &gt;&gt; tap) &amp; 1
	}

	out := p.state &amp; 1

	p.state = (p.state &gt;&gt; 1) | (feedback &lt;&lt; 7)
	return out
}

// gera um número pseudo-aleatório de 8 bits
// obtido a partir de 8 chamadas de nextBit()
func (p *PRNG) rand() uint8 {
	var b uint8
	
	for i := 0; i &lt; 8; i++ {
		b |= p.nextBit() &lt;&lt; i
	}
	return b
}

func main() {

   // inicializa o gerador com uma semente
	prng := srand(0b11001010)

	fmt.Println("Gerando 10 números pseudo-aleatórios com LFSR:")
	for i := 0; i &lt; 10; i++ {
		fmt.Printf("rand() = %3d (0b%08b)\n", prng.rand(), prng.rand())
	}
}

</code></pre>
<h3 id="explicação"><a class="header" href="#explicação">Explicação</a></h3>
<p>No loop onde percorrremos os taps, o feedback é calculado aplicando XOR entre os bits nas posições definidas pelos taps. É equivalente a:</p>
<p>feedback = 0 XOR bit5 (pega o primeito tap, que sabemos que é 5)</p>
<p>feedback = bit5 XOR bit7 (pega o segundo tap, que sabemos que é 7, e faz XOR com o resultado anterior, que sabemos que é bit5)</p>
<p>O estado é atualizando da seguinte forma:</p>
<p>Desloca o estado para a direita e insere o feedback no bit mais significativo. P.ex.:</p>
<p>10000001 &gt;&gt; 1 = 01000000 (desloca o estado para a direita, perdendo o bit menos significativo e ganhando um 0 no bit mais significativo)</p>
<p>00000001 &lt;&lt; 7 = 10000000 (o feedback é sempre apenas 0 ou 1 e não precisamos fazer AND com 1, o deslocamento joga esse bit para o bit mais significativo)</p>
<p>01000000 | 10000000 = 11000000 (faz um OR bit a bit entre o estado deslocado e o feedback deslocado, e obtém o novo estado)</p>
<p>Na função rand(), o loop percorre os 8 bits do número pseudo-aleatório e obtém cada bit usando a função nextBit().</p>
<p>O OR é feito sempre entre os bits obtidos e o valor de b, que é inicializado com 0 e cada bit é deslocado para sua posição correta (0 a 7)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="lcg---linear-congruential-generator"><a class="header" href="#lcg---linear-congruential-generator">LCG - Linear Congruential Generator</a></h1>
<p>O gerador congruencial linear (LCG) é um Pseudo-Random Number Generator (PRNG) que produz uma sequência de números inteiros por meio de uma <strong>fórmula de recorrência</strong>, que define cada novo número com base no anterior.</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<p>Esta fórmula diz que, para obter o próximo valor da sequência <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, pegamos o valor atual <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, multiplicamos por um número fixo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, somamos um descolamento <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, e aplicamos o módulo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> para que o resultado fique dentro de um intervalo limitado.</p>
<p>O que significa recorrência? <strong>Recorrência</strong> é um termo matemático para uma definição que depende do próprio valor anterior. É como uma função que chamamos com os resultados anteriores, p.ex.:</p>
<pre><code class="language-go">S0 := 123456  // semente inicial
S1 := (A * S0 + B) % m
S2 := (A * S1 + B) % m
S3 := (A * S2 + B) % m
// ...
</code></pre>
<p>A sequência inteira <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span> é construída recursivamente a partir da semente inicial <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>Esse tipo de estrutura é comum em geradores determinísticos, pois com os mesmos parâmetros iniciais e a mesma semente, a sequência será sempre igual.</p>
<p>Os valores <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> são números inteiros, mas o tamanho pode variar dependendo da aplicação. Em teoria, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ou seja, um número de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> até <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. Em código, os valores são frequentemente armazenados em um tipo de dado inteiro de 32 ou 64 bits para casos simples ou em um <code>big.Int</code> para suportar números maiores (e.g. um valor com 100 bits). Às vezes, o número inteiro é dividido em bits, caso a aplicação exigir uma saída bit a bit (como no caso de construir uma key stream para cifra de fluxo).</p>
<p>Os parâmetros fixos: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> é chamado de multiplicador e controla o "rítmo" de variação da sequência.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> é chamado de incremento e adiciona uma constante a cada passo.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é chamado de módulo e define o tamanho do espaço onde os valores vivem (e.g.: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> ou <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span></span> ou <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span></span></span></span>).</li>
</ul>
<p>O módulo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, além de manter os valores dentro de um intervalo finito (e.g. entre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>) também permite operar em espaços cíclicos, como nos corpos finitos em criptografia.</p>
<p>No código, podemos implementar uma função, convenientemente chamada rand, da seguinte forma:</p>
<pre><code class="language-go">package main

type PRNG struct {
    state *big.Int // Estado atual S_i
    A     *big.Int // Multiplicador
    B     *big.Int // Incremento
    M     *big.Int // Módulo
}

func (p *PRNG) rand() *big.Int {
    p.state.Mul(p.A, p.state)      // A * S_i
    p.state.Add(p.state, p.B)      // A * S_i + B
    p.state.Mod(p.state, p.M)      // (A * S_i + B) mod m
    return new(big.Int).Set(p.state)
}

func main() {
    // Inicialização do PRNG
    A := big.NewInt(1103515245)
    B := big.NewInt(12345)
    M := big.NewInt(1 &lt;&lt; 32)

    state := big.NewInt(123456)
    prng := PRNG{state, A, B, M}

    for i := 0; i &lt; 10; i++ {
        fmt.Println(prng.rand())
    }
}
</code></pre>
<h3 id="teorema-de-hull-dobell-para-lcgs-modulares"><a class="header" href="#teorema-de-hull-dobell-para-lcgs-modulares">Teorema de Hull-Dobell (para LCGs modulares)</a></h3>
<p>Como veremos também em LFSR, é importante que um PRNG tenha um período máximo. Ou seja, depois de um certo número de iterações, a sequência deve começar a se repetir e o número de iterações deve ser o maior possível, nesse caso <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>. O <strong>Teorema de Hull-Dobell</strong> estabelece as condições necessárias e suficientes para um LCG modular ter um período máximo. Assim, para um LCG modular ter um período máximo, é necessário que:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> são coprimos (i.e. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">d</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> é divisível por todos os fatores primos de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li>
<li>se <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é múltiplo de 4, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> também deve ser múltiplo de 4</li>
</ul>
<p>A seguinte, os valores clássicos em C (glibc):</p>
<pre><code class="language-c">A = 1103515245
B = 12345
M = 1 &lt;&lt; 32
</code></pre>
<p>Para criptografia, esses critérios são insuficientes, porque o LCG é linear e, como veremos, pode ser atacado mesmo que atacante conheça apenas algumas poucas saídas. Para maior segurança precisamos de:</p>
<ul>
<li>Tornar a função não linear</li>
<li>Ou esconder a saída (i.e. aplicar uma função hash sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
<li>Ou usar um gerador de números aleatórios criptograficamente seguro (CSPRNG)</li>
</ul>
<h2 id="variações-e-referências-clássicas-knuth-e-outros"><a class="header" href="#variações-e-referências-clássicas-knuth-e-outros">Variações e Referências Clássicas (Knuth e outros)</a></h2>
<p>O Gerador Congruencial Linear foi extensivamente estudado e documentado por Donald Knuth em sua obra fundamental The Art of Computer Programming, Volume 2: Seminumerical Algorithms [5]. Knuth fornece uma análise detalhada dos critérios estatísticos e estruturais que um bom gerador deve seguir, além de discutir limitações importantes como o ciclo curto, a baixa entropia de bits menos significativos e o comportamento previsível.</p>
<p>Ao longo dos anos, várias variações do LCG foram propostas para mitigar alguns desses problemas ou adaptar o algoritmo a restrições computacionais específicas. Algumas dessas variações incluem:</p>
<p>Gerador de Lehmer: também chamado de Multiplicative Congruential Generator, onde <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, ou seja, sem incremento. O foco é na escolha precisa de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>.</p>
<p>Método de Park-Miller: um caso específico do gerador de Lehmer com <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16807</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. Bastante usado historicamente por seu bom desempenho e simplicidade.</p>
<p>Algoritmo de Schrage: técnica usada para evitar overflow em implementações do método de Park-Miller usando aritmética inteira. Divide o cálculo de <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span> em partes menores.</p>
<p>LCGs combinados (ex: Wichmann-Hill): combinam múltiplos LCGs com diferentes parâmetros e somam as saídas para aumentar o período e melhorar propriedades estatísticas.</p>
<p>Miller’s LCG: variante pouco comum, mas citada por Knuth, com foco em evitar correlações entre bits.</p>
<p>Apesar das melhorias, todos esses métodos compartilham a característica de linearidade sobre <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, o que os torna inadequados para aplicações criptográficas. Essa linearidade permite a reconstrução de parâmetros internos ou do estado com relativamente pouca informação (ex: alguns termos consecutivos da sequência). Por esse motivo, LCGs são aceitáveis apenas em contextos não criptográficos, como simulações estatísticas ou algoritmos probabilísticos onde segurança não é uma exigência.</p>
<h3 id="caso-de-uso-clássico-em-assembly"><a class="header" href="#caso-de-uso-clássico-em-assembly">Caso de uso clássico em Assembly</a></h3>
<pre><code class="language-asm">Obs.: Essa implementação foi usada em um jogo 
escrito em assembly é uma variação do método de
Park-Miller (LCG multiplicativo), com constantes
específicas (16807 e 2836) e otimização inspirada 
no algoritmo de Schrage para evitar overflow.                                        
                                                                                                
Esteja à vontade para converter para Go
ou outra linguagem de alto nível. 


;---------------------------------------------------------;
; Função Random.                                          ;
; Parâmetros: DWORD teto.                                 ;
; Retorno:    Retorna o némero aleatério em EAX.          ;
; Descrição:  Gera um némero aleatério.                   ;
;---------------------------------------------------------;
Random:
    PUSH EBP
    MOV EBP, ESP
    SUB ESP, 4
	
    PUSH EDX
	
    CALL [GetTickCount]
    MOV DWORD [EBP - 4], EAX
	
    XOR EDX, EDX        
    PUSH 127773
    DIV DWORD [ESP]
    PUSH EAX
    MOV EAX, 16807    
    MUL EDX
    POP EDX
    PUSH EAX        
    MOV EAX, 2836              
    MUL EDX
    POP EDX                
    SUB EDX, EAX
    MOV EAX, EDX
    MOV DWORD [EBP - 4], EDX
    PUSH DWORD [EBP + 8]
    MOV EDX, 0
    DIV DWORD [ESP]
    ADD ESP, 8
    MOV EAX, EDX
	
    POP EDX
	
    MOV ESP, EBP
    POP EBP
    RET	4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-des---simplified-des"><a class="header" href="#s-des---simplified-des">S-DES - Simplified DES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="s-aes---simplified-aes"><a class="header" href="#s-aes---simplified-aes">S-AES - Simplified AES</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minides---mini-data-encryption-standard"><a class="header" href="#minides---mini-data-encryption-standard">MiniDES - Mini Data Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miniaes---mini-advanced-encryption-standard"><a class="header" href="#miniaes---mini-advanced-encryption-standard">MiniAES - Mini Advanced Encryption Standard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minirsa---mini-rivest-shamir-e-adleman"><a class="header" href="#minirsa---mini-rivest-shamir-e-adleman">MiniRSA - Mini Rivest, Shamir e Adleman</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="miniecdsa---mini-elliptic-curve-digital-signature-algorithm"><a class="header" href="#miniecdsa---mini-elliptic-curve-digital-signature-algorithm">MiniECDSA - Mini Elliptic Curve Digital Signature Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="minihmac---mini-assinaturas-seguras"><a class="header" href="#minihmac---mini-assinaturas-seguras">MiniHMAC - Mini Assinaturas Seguras</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="bibliotecas-recomendadas"><a class="header" href="#bibliotecas-recomendadas">Bibliotecas Recomendadas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="links-e-leituras-adicionais"><a class="header" href="#links-e-leituras-adicionais">Links e Leituras Adicionais</a></h1>
<p>[1] C. E. Shannon, <em>Communication Theory of Secrecy Systems</em>, Bell System Technical Journal, 1949.</p>
<p>[2] R. L. Rivest, "The MD5 Message-Digest Algorithm," RFC 1321, Apr. 1992. [Online]. Available: https://www.rfc-editor.org/rfc/rfc1321</p>
<p>[3] National Institute of Standards and Technology (NIST), "Advanced Encryption Standard (AES)," <em>FIPS PUB 197</em>, Nov. 2001. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/197/final</p>
<p>[4] National Institute of Standards and Technology (NIST), "Data Encryption Standard (DES)," <em>FIPS PUB 46-3</em>, Oct. 1999. [Online]. Available: https://csrc.nist.gov/publications/detail/fips/46/3/final</p>
<p>[5] D. E. Knuth, <em>The Art of Computer Programming: Volume 2, Seminumerical Algorithms</em>, 3rd ed. Boston, MA, USA: Addison-Wesley, 1997.</p>
<p>[6] C. Paar and J. Pelzl, <em>Understanding Cryptography: A Textbook for Students and Practitioners</em>, Berlin, Germany: Springer, 2010.</p>
<p>[7] R. Lidl and H. Niederreiter, <em>Introduction to Finite Fields and Their Applications</em>, Cambridge, U.K.: Cambridge University Press, 1994.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
